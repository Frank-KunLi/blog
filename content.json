{"pages":[{"title":"关于我","text":"「 当时只道是寻常 」 table { } 2019.2*2019.2.8 洛谷通过 100 道黑题 2019.1 2019.1.17 LibreOJ 通过 100 题 2018.12 2018.12.9 洛谷通过 500 蓝紫黑题 2018.12.8 重构博客 2018.12.4 洛谷通过 800 题 2018.11 2018.11.5 BZOJ 通过 200 题 2018.11.1 通关洛谷提高历练地 2018.10 2018.10.10 洛谷通过 600 题 2018.9 2018.9.16 洛谷通过 200 蓝紫黑题 2018.8 2018.8.30 洛谷通过 400 题 2018.8.8 重构博客 2018.7 2018-07-16 通关洛谷普及练习场 2018.5 2018.5.26 洛谷通过 200 题 2017.12 2017.12.2 开始搭建个人博客 2017.11 2017.11.16 通关洛谷新手村 2017.7 2017.7.31 发表了第一篇博客","link":"/about/index.html"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"标签","text":"","link":"/tags/index.html"},{"title":"做题总结","text":"@card{ 数学，数论均摊 线性 模拟 环形 负载平衡问题[no link] 找到a[i]和a[i+1]保证他们不会被交换（易证存在） 破环为链，变为线性 树剖换根 换根维护子树：分类讨论 P3979 $u = root$ ：整棵树 $u \\not= lca(u, root)$ ：与换根无关 $u = lca(u, root)$ ：root到u的链中u的孩子的子树在所有点中的补集 换根维护LCA CF916E 分别求出 $lca(u, v)$ 、$lca(u, root)$、$lca(u, root)$ 取上面三个中深度最大的 }","link":"/notes/ringo-is-cute.html"},{"title":"友情链接","text":"Schoolmates可爱的学长 / 学弟们 scris scris.top Isonan isonan.cn daniel14311531 cnblogs.com/daniel14311531 LNRBHAW lnrbhaw.github.io CMXRYNP cmxrynp.github.io xuanyi cnblogs.com/xuanyi zhouyuheng csdn.new/zhouyuheng2003 zx2003 csdn.net/zxin__ DreamlessDreams cnblogs.com/DreamlessDreams Romeolong cnblogs.com/Romeolong Willem willem.linshihan.cn EtaoinWu etaoinwu.win Michael Li csdn.net/qq_36056315 Dilute dilute.coding.me toxic toxic2018.ml oierlin oierlin.github.io daniel14311531 cnblogs.com/daniel14311531 Friends互加友链的朋友或者是我特别膜拜的大佬 Menci men.ci Qingnian Su cnblogs.com/cn-suqingnian ranwen ranwen.tk GNAQ fancydreams.ink OwenOwl owenowl.net yyb cnblogs.com/cjyyb yww cnblogs.com/ywwyww sky of war skyofwar.net _rqy rqy.moe hz2016 hz2016.cn Decoration illusionalsky.cn smy cnblogs.com/smyjr Himself65 himself65.com Mina! mina.moe riteme riteme.github.io 小粉兔 cnblogs.com/PinkRabbit Studying Father studyingfather.com ChenQiQian chenqiqian.com yizr-cnyali yizr-cnyali.ac.cn wjyyy wjyyy.top ZigZagK zigzagk.top 蓝先生的小站 ble.ac.cn abc1763613206 ichr.top Shq ishq.site 书海扬帆 www.ljhedp.cn M_sea m-sea-blog.com zshsh zsh2517.com JuicyMio juicymio.cf Siyuan hydingsy.github.io rainman rainman.blog.luogu.org morainzh morainzh.org Steve Braveman stevebraveman.github.io Tosaka UCW tosakaucw.github.io 杨翰奇 alanyhq.com ChenHacker ch.lol5.cn yuntianming yuntianming.pc.goabc.cn Chicago_01 chicago01.top","link":"/friends/index.html"},{"title":"每日一膜 Sooke","text":"Do You Want to Orz Sooke 点击上方按钮进行膜拜 Sooke is Our Red Sun. Without him, We Cannot Live Anymore. 回眸一笑百媚生 —— Sooke 友情链接：点击膜拜贺指导 .orz-sooke-button { display: block; width: 400px; height: 100px; margin: auto; padding: 40px; margin-bottom: 40px; } .orz-sooke-button button { display: block; color: #fff; font-size: 24px; width: 100%; height: 80px; margin-bottom: 100px; text-align: center; border: none; background: #00c6ff; background: -webkit-linear-gradient(to right, #0072ff, #00c6ff); background: linear-gradient(to right, #0072ff, #00c6ff); } .orz-sooke-notice { color: #666; font-size: 18px; text-align: center; margin-bottom: 60px; } .orz-sooke-links { color: #666; font-size: 18px; margin-bottom: 60px; } .orz-sooke-pic { font-size: 26px; text-align: center; } .orz-sooke-pic hr { margin: 20px 0; } $(document).ready(function(){ $(\"#orz-sooke-button\").click(function(){ $(\"#orz-sooke-pic\").fadeToggle(500); }); }); $(document).ready(function(){ $(\"#orz-sooke-button\").click(function(){ $(\"#orz-sooke-notice\").fadeToggle(0); }); });","link":"/orz_sooke/index.html"},{"title":"test","text":"(function(d, s) { var j, e = d.getElementsByTagName(s)[0]; if (typeof LivereTower === 'function') { return; } j = d.createElement(s); j.src = 'https://cdn-city.livere.com/js/embed.dist.js'; j.async = true; e.parentNode.insertBefore(j, e); })(document, 'script'); 为正常使用来必力评论功能请激活JavaScript","link":"/test/index.html"},{"title":"任务列表","text":"@card{ BZOJ} @card{ https://blog.csdn.net/csyzcyj/article/details/9343379[bzoj1756]Vijos1083小白逛公园 裸题- -。。线段树维护lmax,rmax,max,sum然后搞之。。 [Usaco2006 Nov]Roadblocks第二短路 我写的a*。。吐槽下。。这题的数据真的很弱。。第一次提交都忘判断第一短和第二短是否相等结果还a了。。囧 [Usaco2006 Nov]Fence Repair 切割木板 倒过来就是石子合并。。 [Usaco2007 Oct]Money奶牛的硬币 囧。。这为什么会是gold的题。。 [HNOI2003]激光炸弹 各种做法。。我看时限是10s就暴力枚举所有正方形了= =。。 [SCOI2009]粉刷匠 先dp出每一行涂k次的最多正确粉刷，再用对每行dp [Usaco2008Nov]安慰奶牛cheer 转化一下就是最小生成树。。边权=边权*2+端点点权。。再找到最小点权的起点加到ans里就好 [HNOI2004]打鼹鼠 按时间dp。。- - [bzoj1251]序列终结者 裸splay题。。- - [Scoi2010]游戏 明显是匹配。。 [Jsoi2011]括号序列 这题搞死我了。。= =。。维护flip,reverse,flipreverse三个形态。。然后狂写就好。。注意别把建树的复杂度搞成n^2。。（我是沙茶啊啊啊因为这t了一晚上。。） [JSOI2010]Group 部落划分 按边权排序，然后一次一次合并两个端点。。用并查集维护 [HNOI2008]GT考试 kmp上dp+矩阵乘。。好久不写kmp了。。 [Usaco2007 Jan]Running贝茜的晨练计划 dp。。一开始我还想暴力写2维的。。结果好像没这个必要- - [Baltic2009]monument 枚举坐标轴，在一个和这个轴垂直的所有面上做dp求出以x,y为左上角能得到的最大正方形。。然后再枚举正方形上每个点，沿着垂直于正方形的面上来回扫一遍就ok [Zjoi2011]礼物(gift) 同上= =。。 [HNOI2006]超级英雄Hero 又是裸匹配。。- - [Usaco2006 Oct]Another Cow Number Game 奶牛的数字游戏 无语的题。。 Usaco2008 Feb]Line连线游戏 囧。。。排个序然后扫一遍。。 [Usaco2008 Feb]Eating Together麻烦的聚餐 nlgn求最长非降，正着逆着都求一遍取最大。。 [Usaco2008 Mar]River Crossing渡河问题 裸dp。。 [Usaco2007 Jan]Balanced Lineup排队 裸线段树或树状数组或sparsetable。。 [Usaco2007 Dec]宝石手镯 01背包= = [Usaco2008 Oct]灌水 新增一个点连向所有的点边权是wi。。然后最小生成树之= = [ZJOI2007]仓库建设 斜率优化= =。。 [BeiJing2010组队]能量魔方 Cube 囧囧的最小割。。一开始没思路。。题解请见http://hi.baidu.com/edwardmj/blog/item/db04b53cc3fe8e3071cf6c7e.html [POI2008]砖块Klo 要求一个数据结构满足插入/删除一个数以及求中位数和对区间求和。。splay水掉。。 [BeiJing2010]取数游戏 game dp。。如果一个数能被取到，那么更新它所有&gt;=L的约数。。 [POI2008]CLO 可以发现只有树结构不满足条件。。枚举连通分量然后判断是不是树结构 [Poi2008]海报PLA 用栈维护一个递增序列。。搞搞就过了 [POI2008]激光发射器SZK 这题太囧了。。一开始不会。。去orz题解。。结果。。。。。。。。。。。。。。printf(“%d\\n”,n/2); [bzoj1475]方格取数 最大权独立集。。转化成最小割来做就好。。网络流24题里原题 [Usaco2008 Feb]Hotel 以前poj上做过，也是维护左、右、和最长连续的空位。。 [Usaco2008 Oct]笨重的石子 无语的题。。 [bzoj2045]双亲数 和poi2007zap神似，不过比zap简单好多。。可以像能量采集一样nlnn水过XD [NOI2007]货币兑换Cash 被虐到死。。 [bzoj1477]青蛙的约会 裸扩展gcd。。好像poj上也有过 [Usaco2008 Mar]土地购买 如果有大的矩形完全包住小的矩形，就先把小的去了，再斜率优化dp搞掉。。 [SCOI2009]生日礼物 排个序，然后扫一遍。。 [ZJOI2006]物流运输trans 枚举起始点和结束点，然后每次都建图跑最短路。。最后用dp [ZJOI2008]生日聚会Party dp。。dp[a][b][c][d]表示前a个人b个是男孩，其中到现在男的比女的多c个，女的比男的多d个。。（c或d必有一为0。。）。。弱死了。。一开始不会T_T。。 [SCOI2005]最大子矩阵 dp。。边界问题搞死我阿。。 [Ioi2007]Miners 矿工配餐 5维dp+滚动数组水过。。 }","link":"/todo/index.html"}],"posts":[{"title":"10000 访客 & 30000 访问量 纪念","text":"不知不觉，这个博客已经有了 10000 的访客数和 30000 的访问量，memset0.cn 也陪我走过了将近一个年头。想当初的自己看到 rxz 哥哥的博客非常帅气，经历几番波折终于折腾出了自己的博客。而那时候，这篇博客的内容也非常肤浅（大概也就初学线段树的水平 233），到现在学了越来越多的知识，能够写出稍微有点意义的题解了 qwq… 自己也从一个普及组选手，逐渐进化为一个打提高的菜鸡。 回首过往，浮想联翩。如今 PKUWC 在即，也是决定我命运的其中一站，期盼着的未来，会是那个美好的结局吗？","link":"/10000-visitors/"},{"title":"Tarjan求割点（洛谷3388）","text":"用 tarjan 遍历整个图，如果某个点是割点，当且仅当以下两种情况 当前点是根节点，且当前节点出发独立的联通分量至少有两个 当前点不是根节点，且当前节点出发的独立分量能回溯到的最早的点在当前节点之后 转换过来就是下面两个条件 u == root &amp;&amp; child &gt;= 2 u != root &amp;&amp; low[v] &gt;= dfn[u] 其他与 tarjan 算法无异。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;using namespace std;int read() { int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;}const int maxn = 100010;int n, m, u, v, pos, ans, dfn[maxn], low[maxn], cut[maxn];int tot = 2, hed[maxn], nxt[maxn &lt;&lt; 1], to[maxn &lt;&lt; 1];void add_edge(int u, int v) { nxt[tot] = hed[u]; to[tot] = v; hed[u] = tot++;}void tarjan(int u, int root) { dfn[u] = low[u] = ++pos; int child = 0; for (int i = hed[u], v = to[i]; i; i = nxt[i], v = to[i]) { if (!dfn[v]) { tarjan(v, root); low[u] = min(low[u], low[v]); if (low[v] &gt;= dfn[u] &amp;&amp; u != root) cut[u] = 1; child++; } else { low[u] = min(low[u], dfn[v]); } } if (u == root &amp;&amp; child &gt;= 2) cut[u] = 1;}int main() { n = read(), m = read(); for (int i = 1; i &lt;= m; i++) { u = read(), v = read(); add_edge(u, v); add_edge(v, u); } for (int i = 1; i &lt;= n; i++) if (!dfn[i]) tarjan(i, i); for (int i = 1; i &lt;= n; i++) ans += cut[i]; printf(\"%d\\n\", ans); for (int i = 1; i &lt;= n; i++) if (cut[i]) printf(\"%d \", i); puts(\"\"); return 0;}","link":"/algorithm-割点/"},{"title":"主席树（洛谷P3834）","text":"在 mwh 大佬的指引下，我最近学习了主席树。 思想主席树是一种特殊的线段树，能够存储线段树的历史版本，我们称这种性质叫做可持久化。 主席树的可持久化通过这样来实现：我们每次修改单个节点，必然只会经过 $log_2n​$ 条“线段”，对于这些线段，我们都新开节点来存储。显然对于每一次修改操作，根节点都会被新建。那么我们只要存储下来每一次修改说对应的根节点即可。空间占用 $O(n log n)​$ 具体思路可参考 https://www.luogu.org/blog/LonecharmRiver/zhu-xi-shu ss中的图片。 关于模板题我们要维护静态区间第 k 小。可以先把数组离散化，比如： 123离散化前 4 1 1 2 8 9 4 4 3离散化后 4 1 1 2 5 6 4 4 3离散数组 1 2 3 4 8 9 我们根据离散数组作为所维护的区间。第 i 棵树存储 [1, i] 内各数值出现的次数。 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;int read() { int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;}const int maxn = 200010, maxm = maxn * 21;int n, m, tn, l, r, x;int a[maxn], b[maxn];int tot, hed[maxn], sum[maxm], lc[maxm], rc[maxm];void build(int &amp;u, int l, int r) { u = ++tot; if (l == r) return; int mid = (l + r) &gt;&gt; 1; build(lc[u], l, mid); build(rc[u], mid + 1, r);}void modify(int &amp;u, int f, int l, int r, int k) { u = ++tot, sum[u] = sum[f] + 1; if (l == r) return; int mid = (l + r) &gt;&gt; 1; if (k &lt;= mid) modify(lc[u], lc[f], l, mid, k), rc[u] = rc[f]; else modify(rc[u], rc[f], mid + 1, r, k), lc[u] = lc[f];}int query(int p, int q, int l, int r, int k) { if (l == r) return b[l]; int mid = (l + r) &gt;&gt; 1; if (sum[lc[q]] - sum[lc[p]] &gt;= k) return query(lc[p], lc[q], l, mid, k); else return query(rc[p], rc[q], mid + 1, r, k + sum[lc[p]] - sum[lc[q]]);}int main() { n = read(), m = read(); for (int i = 1; i &lt;= n; i++) b[i] = a[i] = read(); sort(b + 1, b + n + 1); tn = unique(b + 1, b + n + 1) - b - 1; for (int i = 1; i &lt;= n; i++) a[i] = lower_bound(b + 1, b + tn + 1, a[i]) - b; build(hed[0], 1, tn); for (int i = 1; i &lt;= n; i++) modify(hed[i], hed[i - 1], 1, tn, a[i]); while (m--) { l = read(), r = read(), x = read(); printf(\"%d\\n\", query(hed[l - 1], hed[r], 1, tn, x)); } return 0;} 后续 &amp; 参考资料需要注意： 我们需要事先建一棵空树； 由于上一条，我们需要n + n log n的空间。 参考资料： https://www.luogu.org/blog/LonecharmRiver/zhu-xi-shu","link":"/algorithm-主席树/"},{"title":"可持久化并查集（洛谷3402）","text":"在主席树的基础上做可持久化数组，在可持久化数组的基础上做可持久化并查集。 然而路径压缩的话数组的修改次数可能会很大，但是每次修改是 $O(\\log n)$ 的，可能会炸。所以我们要用一种类似启发式合并的方法，把小的往大的合并，这样总的复杂度是 $O(n \\log n)$ 的。 可以把并查集中的联通块看成一颗多叉树，合并时，把最深点的深度小的往大的合并，后者把树的大小小的往大的合并。笔者采用的是后者，其实原理基本是一样的。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longint read() { int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;}const int maxn = 100010, maxm = 200010, maxl = 2200010;int n, m, u, v, k, i, pos, opt;struct pair { int fa, siz; pair() {} pair(int a, int b) { fa = a, siz = b; }} x, y;struct SEG { int pos; int root[maxm], lc[maxl], rc[maxl], val[maxl]; bool flag; void build(int &amp;u, int l, int r) { u = ++pos; if (l == r) { val[u] = flag ? l : 1; return; } int mid = (l + r) &gt;&gt; 1; build(lc[u], l, mid); build(rc[u], mid + 1, r); } int query(int u, int l, int r, int k) { if (l == r) return val[u]; int mid = (l + r) &gt;&gt; 1; if (k &lt;= mid) return query(lc[u], l, mid, k); else return query(rc[u], mid + 1, r, k); } void modify(int &amp;u, int v, int l, int r, int k, int c) { u = ++pos, lc[u] = lc[v], rc[u] = rc[v]; if (l == r) { val[u] = c; return; } int mid = (l + r) &gt;&gt; 1; if (k &lt;= mid) modify(lc[u], lc[v], l, mid, k, c); else modify(rc[u], rc[v], mid + 1, r, k, c); }} fa, siz;pair find(int root1, int root2, int u) { int f = fa.query(root1, 1, n, u); if (u == f) return pair(f, siz.query(root2, 1, n, u)); return find(root1, root2, f);}int main() { n = read(), m = read(); fa.flag = 1, siz.flag = 0; fa.build(fa.root[0], 1, n); siz.build(siz.root[0], 1, n); for (i = 1; i &lt;= m; i++) { fa.root[i] = fa.root[i - 1], siz.root[i] = siz.root[i - 1]; opt = read(); if (opt == 1) { u = read(), v = read(); x = find(fa.root[i], siz.root[i], u); y = find(fa.root[i], siz.root[i], v); if (x.fa != y.fa) { if (x.siz &gt; y.siz) std::swap(x, y); fa.modify(fa.root[i], fa.root[i - 1], 1, n, x.fa, y.fa); siz.modify(siz.root[i], siz.root[i - 1], 1, n, y.fa, x.siz + y.siz); } } else if (opt == 2) { k = read(); fa.root[i] = fa.root[k]; siz.root[i] = siz.root[k]; } else { u = read(), v = read(); x = find(fa.root[i], siz.root[i], u); y = find(fa.root[i], siz.root[i], v); if (x.fa == y.fa) puts(\"1\"); else puts(\"0\"); } } return 0;}","link":"/algorithm-可持久化并查集/"},{"title":"拉格朗日插值（洛谷4781）","text":"给你平面上的 n 个点，可以唯一确定一个多项式。 现在告诉你这些点的坐标和 k ，请你求出多项式在 k 的取值。 思路显然我们可以根据题意列出 n 个方程，利用高斯消元求解后带入。时间复杂度O(n ^ 3)。 我们可以利用插值法求解并使得时间复杂度降至O(n ^ 2)。 拉格朗日插值拉格朗日基本多项式为： 对于这个多项式，他有一个神奇的性质，如果你带入 x[j]，可以获得 1 （分子分母相同）；如果带入 x[i]，可以获得 0 （其中必有一项的分子值为 0 ）。由此，我们可以列出这个 n 次多项式。 由于某些前面所述的基本多项式的性质，带入 x[i] 可以获得 y[i] ，即该函数的图像经过题目所要求的 n 个点。可以经过严格的数学证明（知乎上有）可以证明这个多项式即所求的。 然鹅我们并不需要了解那么多，既然这个多项式就是所求多项式，我们带进去用就可以了。另外，由于其中涉及到除法和取模，我们可以考虑乘法逆元。同时，我们可以每次处理出分子和分母再求逆元（而不是实时求逆元），即可保证时间复杂度为O(n ^ 2)。 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;int read() { int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;}const int maxn = 2010, Mod = 998244353;int n, k;ll s1, s2, ans;ll x[maxn], y[maxn];ll inv(ll x) { if (x == 0 || x == 1) return 1; if (x &lt; 0) return inv((x % Mod + Mod) % Mod); return (Mod - Mod / x) * inv(Mod % x) % Mod;}int main() { n = read(), k = read(); for (int i = 1; i &lt;= n; i++) x[i] = read(), y[i] = read(); for (int i = 1; i &lt;= n; i++) { s1 = s2 = 1; for (int j = 1; j &lt;= n; j++) if (i != j) { s1 = s1 * (k - x[j]) % Mod; s2 = s2 * (x[i] - x[j]) % Mod; } ans = (ans + s1 * inv(s2) % Mod * y[i] % Mod + Mod) % Mod; } printf(\"%lld\\n\", ans); return 0;} 参考资料题目链接： 洛谷4781 【模板】拉格朗日插值 参考资料： http://www.ebola.pro/article/notes/Lagrange https://www.luogu.org/blog/user11773/solution-p4781","link":"/algorithm-拉格朗日插值/"},{"title":"圆方树学习笔记","text":"圆方树可以解决仙人掌或一类无向图问题。 建树通过 tarjan 缩点双为方点，原来的点为圆点。每个圆点连边到自己所属的点双方点，跨点双的圆点连边转换为圆方点之间的连边。 参考代码： 12345678910111213141516171819202122232425struct edge { int tot, flag, hed[N], nxt[M], to[M]; edge () { tot = 2; } void link(int u, int v) { nxt[tot] = hed[u], to[tot] = v, hed[u] = tot++; nxt[tot] = hed[v], to[tot] = u, hed[v] = tot++; }} G1, G2;void tarjan(int u, int father) { ++base, dfn[u] = low[u] = ++tim, ins[u] = 1, stk[++top] = u; for (int i = G1.hed[u], v = G1.to[i]; i; i = G1.nxt[i], v = G1.to[i]) if (v != father) { if (!dfn[v]) { tarjan(v, u), low[u] = std::min(low[u], low[v]); if (low[v] &gt;= dfn[u]) { G2.link(u, ++tot), ++val[tot]; int x; do { x = stk[top--], ins[x] = 0; G2.link(x, tot), ++val[tot]; } while (x != v); } } else if (ins[v]) low[u] = std::min(low[u], dfn[v]); }} 需要注意的是，根节点所在的点双的方点并不会创建，在大多数情况下，这并不会有影响，可根据题目的需要取舍。 性质由此我们可以发现一些有趣的性质： 现在总点数与原来的点数同阶，现在的总边数与原来的总边数同阶 所有边都是圆点和方点之间的连边，即不存在圆圆边或方方边 例题[APIO2018] 铁人两项12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// =================================// author: memset0// date: 2018.12.12 23:54:19// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;#define int long longnamespace ringo {typedef long long ll;template &lt; class T &gt; inline void read(T &amp;x) { x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;}template &lt; class T &gt; inline void print(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);}template &lt; class T &gt; inline void maxd(T &amp;a, T b) { if (b &gt; a) a = b; }template &lt; class T &gt; inline void mind(T &amp;a, T b) { if (b &lt; a) a = b; }template &lt; class T &gt; inline void print(T x, char c) { print(x), putchar(c); }const int N = 2e5 + 10, M = 8e5 + 10;int n, m, top, tot, ans, tim, base;int dfn[N], low[N], ins[N], stk[N], son[N], siz[N], val[N];struct edge { int tot, flag, hed[N], nxt[M], to[M]; edge () { tot = 2; } void link(int u, int v) { nxt[tot] = hed[u], to[tot] = v, hed[u] = tot++; nxt[tot] = hed[v], to[tot] = u, hed[v] = tot++; }} G1, G2;void tarjan(int u, int father) { ++base, dfn[u] = low[u] = ++tim, ins[u] = 1, stk[++top] = u; for (int i = G1.hed[u]; i; i = G1.nxt[i]) { int v = G1.to[i]; if (v != father) { if (!dfn[v]) { tarjan(v, u), low[u] = std::min(low[u], low[v]); if (low[v] &gt;= dfn[u]) { G2.link(u, ++tot), ++val[tot]; int x; do { x = stk[top--], ins[x] = 0; G2.link(x, tot), ++val[tot]; } while (x != v); } } else if (ins[v]) { low[u] = std::min(low[u], dfn[v]); } } }}void dfs(int u, int father) { if (u &lt;= n) val[u] = -1, siz[u] = 1; int sum = 0; for (int i = G2.hed[u], v = G2.to[i]; i; i = G2.nxt[i], v = G2.to[i]) if (v != father) { dfs(v, u); siz[u] += siz[v]; sum += (ll)siz[v] * (base - siz[v]); } sum += (ll)(siz[u]) * (base - siz[u]); if (u &lt;= n) sum += base - 1; ans += (ll)val[u] * sum;}void main() { read(n), read(m); for (int i = 1, u, v; i &lt;= m; i++) { read(u), read(v); G1.link(u, v); } tot = n; G2.flag = true; for (int i = 1; i &lt;= n; i++) if (!dfn[i]) { base = 0; tarjan(i, 0); dfs(i, 0); } print(ans, '\\n');}} signed main() { return ringo::main(), 0; } [洛谷4320] 道路相遇123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101// =================================// author: memset0// date: 2018.12.13 23:55:39// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;namespace ringo {typedef long long ll;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;}template &lt;class T&gt; inline void print(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);}template &lt;class T&gt; inline void maxd(T &amp;a, T b) { if (b &gt; a) a = b; }template &lt;class T&gt; inline void mind(T &amp;a, T b) { if (b &lt; a) a = b; }template &lt;class T&gt; inline void print(T x, char c) { print(x), putchar(c); }const int N = 1e6 + 10;int n, m, u, v, w, t, tot, pos, tim, hed;typedef int R1[N]; R1 siz, son, fa, dep, top, low, dfn, ins, stk, id, wid;struct graph { int tot, hed[N], nxt[N &lt;&lt; 1], to[N &lt;&lt; 1]; graph () { tot = 2; } inline void add_edge(int u, int v) { nxt[tot] = hed[u], to[tot] = v, hed[u] = tot++; nxt[tot] = hed[v], to[tot] = u, hed[v] = tot++; }} G1, G2;void tarjan(int u, int father) { dfn[u] = low[u] = ++tim, ins[u] = 1, stk[++hed] = u; for (int i = G1.hed[u], v = G1.to[i]; i; i = G1.nxt[i], v = G1.to[i]) if (v != father) { if (!dfn[v]) { tarjan(v, u), low[u] = std::min(low[u], low[v]); if (low[v] &gt;= dfn[u]) { G2.add_edge(u, ++tot); int x; do { x = stk[hed--]; ins[x] = false, G2.add_edge(x, tot); } while (x != v); } } else if (ins[v]) low[u] = std::min(low[u], dfn[v]); }}inline int lca(int u, int v) { while (top[u] != top[v]) { if (dep[top[u]] &gt; dep[top[v]]) std::swap(u, v); v = fa[top[v]]; } return dep[u] &lt; dep[v] ? u : v;}void dfs(int u) { siz[u] = 1; for (int i = G2.hed[u], v = G2.to[i]; i; i = G2.nxt[i], v = G2.to[i]) if (v != fa[u]) { fa[v] = u, dep[v] = dep[u] + 1, dfs(v), siz[u] += siz[v]; if (siz[v] &gt; siz[son[u]]) son[u] = v; }}void dfs(int u, int toppoint) { top[u] = toppoint, id[u] = ++pos, wid[id[u]] = u; if (siz[u] == 1) return; dfs(son[u], toppoint); for (int i = G2.hed[u], v = G2.to[i]; i; i = G2.nxt[i], v = G2.to[i]) if (v != fa[u] &amp;&amp; v != son[u]) dfs(v, v);}void main() { read(n), read(m); for (int i = 1; i &lt;= m; i++) { read(u), read(v); G1.add_edge(u, v); } tot = n; for (int i = 1; i &lt;= n; i++) if (!dfn[i]) { tarjan(i, 0), dep[i] = 1; dfs(i), dfs(i, i); } read(m); for (int i = 1; i &lt;= m; i++) { read(u), read(v), t = lca(u, v); w = dep[u] + dep[v] - (dep[t] &lt;&lt; 1) + 1; print((w + 1) &gt;&gt; 1, '\\n'); }}} signed main() { return ringo::main(), 0; }","link":"/algorithm-圆方树/"},{"title":"线性基（洛谷3812）","text":"线性基是一种解决异或相关问题的算法。 感谢 mwh 与我分享关于线性基的理解，让我了解线性基。 概念线性基理论上来说是一种贪心的思路。一般情况下，我们需要从（二进制）高位到低位贪心，然而这样可能会产生其他影响（例如当前数的选择与否会影响到之前已选择的数）。线性基就巧妙的解决了这个问题。 假设我们已经有了一个集合 $S$ ，集合中有一数为 $P$ ，现在我们需要插入 $X$ ，则插入 $X$ 和插入 $ X xor P $ 是等价的，理性证明： 假设集合 $S$ 中任意个数其中包含 $P$ 的异或和的集合为 $S1$ ，不包含 $P$ 的为 $S2$ 。则插入 $X$ 后的 $S$ 中任意数的异或和集合 $S’ = X xor S1 + X xor S2$ ；插入 $X xor P$ 后 $S$ 中任意数的异或集合 $S’’ = (X xor P) xor S1 + (X xor P) xor S2 = X xor (P xor S1) + X xor (P xor S2) = X xor S2 + X xor S1$ 。所以 $S’ = S’’$ 插入 $X$ 和插入 $X xor P$ 等价，证毕。 实现我们考虑维护一个集合S，S[i]表示（二进制）最高位是 1 的某个数，这样的数在集合中有且仅有一个。 枚举a[1...n]中的每一个数字： 假设当前数字的最高位为 j 如果S[j]为空，则S[j] = a[i]，退出 如果S[j]不为空，则a[i] xor= S[j]，回到 1 这样对于每个a[i]，只可能插入到S中一次，如果没有插入，则a[i]将会变成 0 ，异或 0 是没有意义的，可以直接省略。 接下来对于 S ，我们只需要前面所说的贪心即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;ll read() { ll x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;}const int maxn = 60;int n;ll ans;ll _2[maxn], a[maxn], f[maxn];int main() { n = read(); for (int i = 1; i &lt;= n; i++) a[i] = read(); _2[0] = 1; for (int i = 1; i &lt;= 50; i++) _2[i] = _2[i - 1] &lt;&lt; 1; for (int i = 1; i &lt;= n; i++) for (int j = 50; j &gt;= 0; j--) if (a[i] &amp; _2[j]) { if (f[j]) a[i] xor= f[j]; else { f[j] = a[i]; break; } } for (int j = 50; j &gt;= 0; j--) if ((ans &amp; _2[j]) == 0) { ans xor= f[j]; } printf(\"%lld\\n\", ans); return 0;}","link":"/algorithm-线性基/"},{"title":"虚树学习笔记","text":"题目先给定一棵树，然后每次询问和其中的一部分点有关的信息，且只考虑这些点和他们的 LCA 对答案没有影响，则可以考虑虚树。先求出所有点的欧拉序，把每次询问给出的点按照欧拉序排序，依次插入栈中，维护栈内元素使得形成一条在已插入的点中最右端的链。 其实没什么新知识，可以说是一种思想，所以代码也很好写，就是需要注意细节。 例题[SDOI2011]消耗战123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101// =================================// author: memset0// date: 2018.12.16 13:59:47// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;#define int long longnamespace ringo {typedef long long ll;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;}template &lt;class T&gt; inline void print(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);}template &lt;class T&gt; inline void maxd(T &amp;a, T b) { if (b &gt; a) a = b; }template &lt;class T&gt; inline void mind(T &amp;a, T b) { if (b &lt; a) a = b; }template &lt;class T&gt; inline void print(T x, char c) { print(x), putchar(c); }template &lt;class T&gt; inline T abs(const T &amp;a) { if (a &lt; 0) return -a; return a; }const int N = 250010, inf = 1e18;int n, m, u, v, w, t, x, c, tim, pos, til;typedef int R[N]; R f, g, in, fa, id, wid, out, top, siz, dep, son, stk, que, tag;int tot = 2, hed[N], to[N &lt;&lt; 1], nxt[N &lt;&lt; 1], val[N &lt;&lt; 1];std::vector &lt;int&gt; G[N];inline bool cmp(int a, int b) { return in[a] &lt; in[b]; }inline void add_edge(int u, int v, int w) { nxt[tot] = hed[u], to[tot] = v, val[tot] = w, hed[u] = tot++; nxt[tot] = hed[v], to[tot] = u, val[tot] = w, hed[v] = tot++;}void dfs1(int u, int min) { in[u] = ++tim, g[u] = min, siz[u] = 1; for (int i = hed[u], v = to[i]; i; i = nxt[i], v = to[i]) if (v != fa[u]) { fa[v] = u, dep[v] = dep[u] + 1, dfs1(v, std::min(min, val[i])), siz[u] += siz[v]; if (siz[v] &gt; siz[son[u]]) son[u] = v; } out[u] = ++tim;}void dfs2(int u, int toppoint) { top[u] = toppoint, id[u] = ++pos, wid[id[u]] = u; if (siz[u] == 1) return; dfs2(son[u], top[u]); for (int i = hed[u], v = to[i]; i; i = nxt[i], v = to[i]) if (v != fa[u] &amp;&amp; v != son[u]) dfs2(v, v);}int lca(int u, int v) { while (top[u] != top[v]) { if (dep[top[u]] &gt; dep[top[v]]) std::swap(u, v); v = fa[top[v]]; } return dep[u] &lt; dep[v] ? u : v;}void dp(int u) { f[u] = tag[u] ? inf : 0; for (std::vector &lt;int&gt; ::iterator it = G[u].begin(); it != G[u].end(); it++) dp(*it), f[u] += std::min(f[*it], g[*it]); G[u].clear();}void main() { read(n); for (int i = 1; i &lt; n; i++) { read(u), read(v), read(w); add_edge(u, v, w); } dfs1(1, inf), dfs2(1, 1), read(m); for (int i = 1, top; i &lt;= m; i++) { x = 0, stk[1] = top = 1, read(til); for (int i = 1; i &lt;= til; i++) read(que[i]), tag[que[i]] = 1; std::sort(que + 1, que + til + 1, cmp); for (int i = 1; i &lt;= til; i++) { u = que[i]; while (top &gt; 1 &amp;&amp; in[u] &lt; in[stk[top - 1]] &amp;&amp; out[stk[top - 1]] &lt; out[u]) G[stk[top - 1]].push_back(stk[top]), --top; if (in[u] &lt; in[stk[top]] &amp;&amp; out[stk[top]] &lt; out[u]) G[u].push_back(stk[top--]); t = lca(stk[top], u); while (top &gt; 1 &amp;&amp; in[t] &lt; in[stk[top - 1]] &amp;&amp; out[stk[top - 1]] &lt; out[t]) G[stk[top - 1]].push_back(stk[top]), --top; if (in[t] &lt; in[stk[top]] &amp;&amp; out[stk[top]] &lt; out[t]) G[t].push_back(stk[top--]); if (t != stk[top]) stk[++top] = t; if (u != stk[top]) stk[++top] = u; } for (int i = 1; i &lt; top; i++) G[stk[i]].push_back(stk[i + 1]); dp(1), print(f[1], '\\n'); for (int i = 1; i &lt;= til; i++) tag[que[i]] = 0; }}} signed main() { return ringo::main(), 0; }","link":"/algorithm-虚树/"},{"title":"高斯消元学习笔记","text":"最近的模拟赛出现了一道坑爹的数学题，正解是上一篇博文所讲的数学插值。然而高斯消元还是可以拿到 65 分的成绩，没办法，凭借着我对其原理的依稀记忆我只能考场上手推高斯消元。 原理高斯消元其实是个很简单的东西，无非就小学奥数的难度罢了。按照小学奥数的加减消元和代入消元即可完成。模板题给了你 n 个的 n 元一次多项式求解。我们可以通过加减消元合并为 n - 1 个 n - 1 元的一次多项式（合并相邻两个）；于是，经过 n - 1 次合并我们就可以得到一个一元一次方程，可以很方便的得到解。我们再将解回代，即可解出方程。 代码其实没什么好说的，直接看代码就行。鉴于大部分洛谷题解的质量堪忧（经常被 Hack ），所以这篇代码也是经过了重重考验吧。欢迎 Hack 。 为避免误会，事先声明洛谷此题有无数组解和无解都属于 No solution. 如果这两种情况要分开来你可能需要另外一种写法，我也会给出。 需要注意一下无解的情况和主元不能为 0 ，大部分题解被 Hack 也都是因为这个原因。 AC 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 110;const double inf = 1e10;int n;double t, ans[maxn], f[maxn][maxn];int work() { for (int i = 1; i &lt;= n; i++) { // f[i][i]即所谓的主元 if (f[i][i] == 0) { // 主元不能为0，要交换 int j = i + 1; while (f[j][i] == 0 &amp;&amp; j &lt;= n) j++; if (j &gt; n) return -1; // 肯定无解 swap(f[i], f[j]); } for (int j = i + 1; j &lt;= n; j++) { t = -f[j][i] / f[i][i]; for (int k = i; k &lt;= n + 1; k++) f[j][k] += f[i][k] * t; } } for (int i = n; i &gt;= 1; i--) { for (int j = i + 1; j &lt;= n; j++) f[i][n + 1] -= ans[j] * f[i][j]; ans[i] = f[i][n + 1] / f[i][i]; } return 0;}int main() { scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n + 1; j++) scanf(\"%lf\", &amp;f[i][j]); if (work() == -1) printf(\"No Solution\\n\"); else for (int i = 1; i &lt;= n; i++) printf(\"%.2lf\\n\", ans[i]); return 0;} 可以区分无数解和无解的算法，无数解在有些题目中是可行的（也许有 SPJ ），叫做自由元，你可以取任意一个值： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 110;const double inf = 1e10;int n;double t, ans[maxn], f[maxn][maxn];int work() { for (int i = 1; i &lt;= n; i++) { if (f[i][i] == 0) { int j = i + 1; while (f[j][i] == 0 &amp;&amp; j &lt;= n) j++; swap(f[i], f[j]); } for (int j = i + 1; j &lt;= n; j++) { t = -f[j][i] / f[i][i]; for (int k = i; k &lt;= n + 1; k++) f[j][k] += f[i][k] * t; } } for (int i = n; i &gt;= 1; i--) { for (int j = i + 1; j &lt;= n; j++) f[i][n + 1] -= ans[j] * f[i][j]; if (f[i][i] == 0) { if (ans[i] == 0) return -1; // 无数解 else return -2; // 无解 } ans[i] = f[i][n + 1] / f[i][i]; } return 0;}int main() { scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n + 1; j++) scanf(\"%lf\", &amp;f[i][j]); if (work() &lt; 0) printf(\"No Solution\\n\"); else for (int i = 1; i &lt;= n; i++) printf(\"%.2lf\\n\", ans[i]); return 0;} 后续 &amp; 参考资料哦，对了，还记得我开头说的那个模拟赛上的高斯消元么？因为某些原因其实不是正解只有 65 分，另外由于那题的某些限制，任意元不能取 0 ，所以只有 45 了，还好那场模拟赛大家分都不高，勉强凑活啦。","link":"/algorithm-高斯消元/"},{"title":"欧拉筛求质数","text":"欧拉筛是一种优秀的筛质数方法。 埃氏筛一般的筛法，时间复杂度 $O(n \\times log (log n))$ 。 123456789101112void sieve(int n) { cnt = 0; memset(flag, 0, sizeof(flag)); for (int i = 2; i &lt;= sqrt(n); i++) { if (!flag[i]) { prime[cnt++] = i; for (int j = i * i; j &lt;= n; j += i) { flag[j] = true; } } }} 欧拉筛欧拉筛可以保证每个数只会被筛到一次，故时间复杂度为 $O(n)$ 。12345678910111213void sieve(int n) { cnt = 0; memset(flag, 0, sizeof(flag)); for (int i = 2; i &lt;= n; i++) { if (!flag[i]) prime[cnt++] = i; for (int j = 0; i * prime[j] &lt;= n; j++) { flag[i * prime[j]] = true; if (i % prime[j] == 0) break; } }}","link":"/algorithm-欧拉筛/"},{"title":"树状数组 区间修改 & 区间查询（LOJ132）","text":"单点修改 &amp; 区间查询 傻逼都会。 区间修改 &amp; 单点查询 假设 $a$ 数组为我们当前维护的数组，定义 $b_i = a_i - a_{i - 1}$ ，则 $a_i = \\sum_{j = 1}^{i}b_j$ 。用单点修改 &amp; 区间查询的树状数组维护 $b$ ，修改区间 $l$ 到 $r$ 只需使 $b_{l-1} + value$ 且 $b_r - value$ ，查询 $a_i$ 只需求 $\\sum_{j = 1}^{i}b_j$ 。 区间修改 &amp; 区间查询 同 2 的假设下，求 $\\sum_{i=l}^{r} a_i$ 即求 $\\sum_{i=1}^{r} a_i - \\sum_{i=1}^{l-1} a_i$ ，我们只需考虑如何求 $\\sum_{i=1}^{k} a_i$ 。 $\\sum_{i=1}^{k} a_i = \\sum_{i=1}^{k} \\sum_{j=1}^{i} b_j = \\sum_{i=1}^{k} b_i \\times (i + 1 - x) = (k+1) \\times \\sum_{i=1}^{k} b_i + \\sum_{i=1}^{k} (i \\times b_i)$ 所以我们开两个树状数组，分别维护 $b_i$ 和 $i \\times b_i$ 即可。 由于树状数组中不能有 0 我们需要将下标整体右移一位 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;int read() { int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;}#define lowbit(i) ((i)&amp;(-(i)))const int maxn = 1000010;int n, m, l, r, x, opt, a[maxn];ll s[maxn], c[2][maxn];void modify(int k, ll x) { for (int i = k; i &lt;= n; i += lowbit(i)) c[0][i] += x, c[1][i] += x * (k + 1);}ll query(int k) { ll ans = 0; for (ll i = k; i &gt; 0; i -= lowbit(i)) ans += c[0][i] * (k + 1) - c[1][i]; return ans;}int main() { n = read(), m = read(); for (int i = 1; i &lt;= n; i++) a[i] = read(), s[i] = s[i - 1] + a[i]; for (int i = 1; i &lt;= m; i++) { opt = read(); if (opt == 1) { l = read(), r = read(), x = read(); modify(l, x), modify(r + 1, -x); } else { l = read(), r = read(); printf(\"%lld\\n\", query(r + 1) - query(l) + s[r] - s[l - 1]); } } return 0;}","link":"/bit/"},{"title":"使用 Hexo Hey 进行 Hexo 下的写作","text":"之前特别喜欢那种动态博客，因为它能够提供一种更加简洁直观的编辑页面，而不是像 Hexo 一样，要从一堆 .md 文件中找出自己需要编辑的那个。 当然， Hexo 下这个问题也不是无解，所以这篇文章就来简单的介绍下在 Hexo 的文章管理插件。 首先先要明确一下自己的需求： 界面好看，颜值高 能通过文章标题来检索文章而不是 markdown 文件的文件名 能够快捷的调整文章的日期、标签等设置 在 Github 上搜索 hexo admin ，我找到了一下几款插件： hexo-admin 优点：功能齐全，一键部署 缺点：界面难看，有些时候会有些卡顿？（个人感觉） hexo-local-admin 装不起来，略 hexo-hey 优点：界面好看，响应速度快 缺点：不支持 Latex （不过这个问题我们马上解决），不能一键部署？ 综上，我选择了 Hexo Hey。 安装参考官方文档的 README.md 即可，并不难。 不要忘记去配置 _config.yml 使用前小修改虽说界面好看，但还是有些我个人觉得反人类的小问题，比如： Markdown 源码编辑框不是等宽字体 toolbar 的文字没有居中对齐？ sidebar 宽度太小，有些文章的标题太长显示不下… 右侧预览的 margin 太少，看起来十分拥挤 所以自己加了点 CSS ，利用 Stylus. 123456789101112131415pre, code { font-family: Menlo !important;}md-toolbar span.ng-scope { display: none;}md-sidenav { width: 600px !important;}.markdown-body { margin: 60px !important;} MathJax 公式支持在 your-hexo-path/node_modules/hexo-hey/www/index.html 下粘贴以下代码 12345678910111213141516171819202122232425&lt;script type=\"text/x-mathjax-config\"&gt;MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], [\"\\\\(\",\"\\\\)\"] ], processEscapes: true, skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'] }});MathJax.Hub.Queue(function() { var all = MathJax.Hub.getAllJax(), i; for(i=0; i &lt; all.length; i += 1) { all[i].SourceElement().parentNode.className += ' has-jax'; }});function funcDemo(){ window.setInterval(\"MathJax.Hub.Typeset()\", 500);}window.onload = funcDemo;&lt;/script&gt;&lt;script async src=\"//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML\"&gt;&lt;/script&gt; 由于不会检测 markdown 文件发生改变时渲染，所以默认是每隔 0.5s 重新渲染一次。 已知的小问题分类和 tag 修改后无法保存… ↑ 好吧只是窝不会用…","link":"/blog-with-hexo-hey/"},{"title":"多项式学习笔记","text":"持续学习中… 快速傅里叶变换 FFT12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;#define il inline#define rg register#define ll long long#define getc getchar#define putc putchar#define rep(i, l, r) for (int i = l; i &lt;= r; ++i)namespace ringo {template &lt; class T &gt; il void read(T &amp;x) { x = 0; rg char c = getc(); rg bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getc(); while (isdigit(c)) x = x * 10 + c - '0', c = getc(); if (f) x = -x;}template &lt; class T &gt; il void print(T x) { if (x &lt; 0) putc('-'), x = -x; if (x &gt; 9) print(x / 10); putc('0' + x % 10);}const int maxn = 4e6 + 10;const double pi = acos(-1);int n, k, n1, n2, rev[maxn];struct complex { double x, y; il complex(const double &amp;a = 0, const double &amp;b = 0) { x = a, y = b; } il complex operator + (const complex &amp;b) const { return complex(x + b.x, y + b.y); } il complex operator - (const complex &amp;b) const { return complex(x - b.x, y - b.y); } il complex operator * (const complex &amp;b) const { return complex(x * b.x - y * b.y, x * b.y + y * b.x); }} a[maxn], b[maxn];void fft(complex *a, int flag) { for (int i = 0; i &lt; n; i++) if (i &lt; rev[i]) std::swap(a[i], a[rev[i]]); for (int len = 1; len &lt; n; len &lt;&lt;= 1) { complex wn(cos(pi / len), flag * sin(pi / len)); for (int i = 0; i &lt; n; i += (len &lt;&lt; 1)) { complex w(1, 0); for (int j = 0; j &lt; len; j++, w = w * wn) { complex x = a[i + j], y = w * a[i + j + len]; a[i + j] = x + y, a[i + j + len] = x - y; } } }}void main() { read(n1), read(n2); for (int i = 0; i &lt;= n1; i++) read(a[i].x); for (int i = 0; i &lt;= n2; i++) read(b[i].x); n = 1; while (n &lt;= (n1 + n2)) n &lt;&lt;= 1, ++k; for (int i = 0; i &lt; n; i++) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (k - 1)); fft(a, 1), fft(b, 1); for (int i = 0; i &lt; n; i++) a[i] = a[i] * b[i]; fft(a, -1); for (int i = 0; i &lt;= n1 + n2; i++) print((int)(a[i].x / n + 0.5)), putc(i == n1 + n2 ? '\\n' : ' ');}} int main() { return ringo::main(), 0; } 数论傅里叶变换 NTT12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;#define il inline#define rg register#define ll long long#define getc getchar#define putc putchar#define rep(i, l, r) for (int i = l; i &lt;= r; ++i)namespace ringo {template &lt; class T &gt; il void read(T &amp;x) { x = 0; rg char c = getc(); rg bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getc(); while (isdigit(c)) x = x * 10 + c - '0', c = getc(); if (f) x = -x;}template &lt; class T &gt; il void print(T x) { if (x &lt; 0) putc('-'), x = -x; if (x &gt; 9) print(x / 10); putc('0' + x % 10);}const int maxn = 4e6 + 10, P = 998244353, G = 3;int n, k, n1, n2, tmp, rev[maxn];ll a[maxn], b[maxn];int inv(int x) { if (x == 0 || x == 1) return 1; return 1ll * (P - P / x) * inv(P % x) % P;}int pow(ll x, int b) { ll s = 1; while (b) { if (b &amp; 1) (s *= x) %= P; (x *= x) %= P, b &gt;&gt;= 1; } return s;}void ntt(ll *a, int G) { for (int i = 0; i &lt; n; i++) if (i &lt; rev[i]) std::swap(a[i], a[rev[i]]); for (int len = 1; len &lt; n; len &lt;&lt;= 1) { ll wn = pow(G, (P - 1) / (len &lt;&lt; 1)); for (int i = 0; i &lt; n; i += (len &lt;&lt; 1)) { ll w = 1; for (int j = 0; j &lt; len; j++, w = w * wn % P) { ll x = a[i + j], y = w * a[i + j + len] % P; a[i + j] = (x + y) % P, a[i + j + len] = (x - y + P) % P; } } }}void main() { read(n1), read(n2); for (int i = 0; i &lt;= n1; i++) read(a[i]), a[i] %= P; for (int i = 0; i &lt;= n2; i++) read(b[i]), b[i] %= P; n = 1; while (n &lt;= (n1 + n2)) n &lt;&lt;= 1, ++k; for (int i = 0; i &lt; n; i++) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (k - 1)); ntt(a, G), ntt(b, G); for (int i = 0; i &lt; n; i++) a[i] = a[i] * b[i] % P; ntt(a, inv(G)), tmp = inv(n); for (int i = 0; i &lt;= n1 + n2; i++) print(a[i] * tmp % P), putc(i == n1 + n2 ? '\\n' : ' ');}} int main() { return ringo::main(), 0; } 任意模数 NTT123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;namespace ringo {typedef long long ll;template &lt; class T &gt;inline void read(T &amp;x) { x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;}template &lt; class T &gt;inline void print(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);}template &lt; class T &gt;inline void print(T x, char c) { print(x), putchar(c);}const int N = 4e5 + 10, G = 3, P[3] = {469762049, 998244353, 1004535809};int n1, n2, k, n, p, p1, p2, M2;int a[N], b[N], f[3][N], g[N], rev[N], ans[N];int inv(int x, int p) { if (x &gt;= p) return inv(x % p, p); return !x || x == 1 ? 1 : (ll)(p - p / x) * inv(p % x, p) % p;}int pow(int a, int b, int p) { int s = 1; while (b) { if (b &amp; 1) s = (ll)s * a % p; b &gt;&gt;= 1, a = (ll)a * a % p; } return s;}void ntt(int *a, int g, int p) { for (int i = 0; i &lt; n; i++) if (i &lt; rev[i]) std::swap(a[i], a[rev[i]]); for (int len = 1; len &lt; n; len &lt;&lt;= 1) { int wn = pow(g, (p - 1) / (len &lt;&lt; 1), p); for (int i = 0; i &lt; n; i += (len &lt;&lt; 1)) { int w = 1; for (int j = 0; j &lt; len; j++, w = (ll)w * wn % p) { int x = a[i + j], y = (ll)w * a[i + j + len] % p; a[i + j] = (x + y) % p, a[i + j + len] = (x - y + p) % p; } } }}int merge(int a1, int a2, int A2) { ll M1 = (ll)p1 * p2; ll A1 = ((ll)inv(p2, p1) * a1 % p1 * p2 + (ll)inv(p1, p2) * a2 % p2 * p1) % M1; ll K = ((A2 - A1) % M2 + M2) % M2 * inv(M1 % M2, M2) % M2; int ans = (A1 + M1 % p * K) % p; return ans;}void main() { read(n1), read(n2), read(p); p1 = P[0], p2 = P[1], M2 = P[2]; for (int i = 0; i &lt;= n1; i++) read(a[i]); for (int i = 0; i &lt;= n2; i++) read(b[i]); n = 1; while (n &lt;= (n1 + n2)) n &lt;&lt;= 1, ++k; for (int i = 0; i &lt; n; i++) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (k - 1)); for (int k = 0; k &lt; 3; k++) { for (int i = 0; i &lt; n; i++) f[k][i] = a[i] % P[k]; for (int i = 0; i &lt; n; i++) g[i] = b[i] % P[k]; ntt(f[k], G, P[k]), ntt(g, G, P[k]); for (int i = 0; i &lt; n; i++) f[k][i] = (ll)f[k][i] * g[i] % P[k]; ntt(f[k], inv(G, P[k]), P[k]); for (int i = 0; i &lt; n; i++) f[k][i] = (ll)f[k][i] * inv(n, P[k]) % P[k]; } for (int i = 0; i &lt;= n1 + n2; i++) ans[i] = merge(f[0][i], f[1][i], f[2][i]); for (int i = 0; i &lt;= n1 + n2; i++) print(ans[i], \" \\n\"[i == n1 + n2]); }} signed main() { return ringo::main(), 0; } 多项式求逆1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// =================================// author: memset0// date: 2018.12.03 12:19:03// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;namespace ringo {typedef long long ll;template &lt; class T &gt;inline void read(T &amp;x) { x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;}template &lt; class T &gt;inline void print(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);}template &lt; class T &gt;inline void print(T x, char c) { print(x), putchar(c);}const int N = 4e5 + 10, p = 998244353;int n, k, i, lim, lim_inv;int a[N], b[N], f[N], g[N], rev[N];int fpow(int a, int b) { int s = 1; while (b) { if (b &amp; 1) s = (ll)s * a % p; b &gt;&gt;= 1, a = (ll)a * a % p; } return s;}void ntt(int *a, int g) { for (int i = 0; i &lt; lim; i++) if (i &lt; rev[i]) std::swap(a[i], a[rev[i]]); for (int len = 1; len &lt; lim; len &lt;&lt;= 1) { int wn = fpow(g, (p - 1) / (len &lt;&lt; 1)); for (int i = 0; i &lt; lim; i += (len &lt;&lt; 1)) { int w = 1; for (int j = 0; j &lt; len; j++, w = (ll)w * wn % p) { int x = a[i + j], y = (ll)w * a[i + j + len] % p; a[i + j] = (x + y) % p, a[i + j + len] = (x - y + p) % p; } } }}void solve(int *a, int *b, int n) { if (n == 1) { b[0] = fpow(a[0], p - 2); return; } solve(a, b, n &gt;&gt; 1); memset(f, 0, sizeof(f)), memset(g, 0, sizeof(g)); for (int i = 0; i &lt; n; i++) f[i] = a[i], g[i] = b[i]; lim = 1, k = 0; while (lim != (n &lt;&lt; 1)) lim &lt;&lt;= 1, ++k; for (int i = 0; i &lt; lim; i++) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (k - 1)); ntt(f, 3), ntt(g, 3); for (int i = 0; i &lt; lim; i++) f[i] = (ll)f[i] * g[i] % p * g[i] % p; ntt(f, fpow(3, p - 2)), lim_inv = fpow(lim, p - 2); for (int i = 0; i &lt; n; i++) b[i] = (2ll * b[i] - (ll)f[i] * lim_inv % p + p) % p;}void main() { for (read(n), i = 0; i &lt; n; i++) read(a[i]); lim = 1; while (lim &lt; n) lim &lt;&lt;= 1; solve(a, b, lim); for (int i = 0; i &lt; n; i++) print(b[i], \" \\n\"[i == n - 1]);}} signed main() { return ringo::main(), 0; }","link":"/algorithm-多项式/"},{"title":"AT2064 - Many Easy Problems","text":"容斥可得： $$ans_k = n {n \\choose k} - \\sum\\limits_{u=1}^n ({n - siz_u\\choose k} + \\sum\\limits_{v \\in son_u} {siz_v \\choose k})$$ NTT 一波即可。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// =================================// author: memset0// date: 2019.01.25 22:26:04// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;#define ll long longnamespace ringo {template &lt;class T&gt; inline void read(T &amp;x) { x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;}template &lt;class T&gt; inline void print(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);}template &lt;class T&gt; inline void print(T x, char c) { print(x), putchar(c); }const int N = 2e5 + 10, mod = 924844033;int n, k, lim = 1, inv_lim;int f[N &lt;&lt; 2], g[N &lt;&lt; 2], w[N &lt;&lt; 2], rev[N &lt;&lt; 2];;int cnt[N], fac[N], fac_inv[N], fa[N], siz[N], ans[N];int tot = 2, hed[N], to[N &lt;&lt; 1], nxt[N &lt;&lt; 1];inline int C(int n, int m) { return (ll)fac[n] * fac_inv[m] % mod * fac_inv[n - m] % mod; }inline int inv(int x) { return !x || x == 1 ? 1 : (ll)(mod - mod / x) * inv(mod % x) % mod; }inline int fpow(int a, int b) { int s = 1; for (; b; b &gt;&gt;= 1, a = (ll)a * a % mod) if (b &amp; 1) s = (ll)s * a % mod; return s;}void ntt(int *a, int lim) { for (int i = 0; i &lt; lim; i++) if (i &lt; rev[i]) std::swap(a[i], a[rev[i]]); for (int len = 1; len &lt; lim; len &lt;&lt;= 1) for (int i = 0; i &lt; lim; i += (len &lt;&lt; 1)) for (int j = 0; j &lt; len; j++) { int x = a[i + j], y = (ll)w[j + len] * a[i + j + len] % mod; a[i + j] = (x + y) % mod, a[i + j + len] = (x - y + mod) % mod; }}void dfs(int u) { siz[u] = 1; for (int i = hed[u], v = to[i]; i; i = nxt[i], v = to[i]) if (v != fa[u]) { fa[v] = u, dfs(v), siz[u] += siz[v]; } ++cnt[n - siz[u]]; if (u != 1) ++cnt[siz[u]];}void main() { read(n), fac[0] = fac[1] = fac_inv[0] = fac_inv[1] = 1; for (int i = 2; i &lt;= n; i++) fac[i] = (ll)fac[i - 1] * i % mod; for (int i = 2; i &lt;= n; i++) fac_inv[i] = inv(fac[i]); for (int i = 1, u, v; i &lt; n; i++) { read(u), read(v); nxt[tot] = hed[u], to[tot] = v, hed[u] = tot++; nxt[tot] = hed[v], to[tot] = u, hed[v] = tot++; } dfs(1); while (lim &lt;= (n + 1 + n + 1)) lim &lt;&lt;= 1, ++k; for (int i = 0; i &lt; lim; i++) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (k - 1)); for (int len = 1, wn; len &lt; lim; len &lt;&lt;= 1) { wn = fpow(5, (mod - 1) / (len &lt;&lt; 1)), w[len] = 1; for (int i = 1; i &lt; len; i++) w[i + len] = (ll)w[i + len - 1] * wn % mod; } for (int i = 0; i &lt;= n; i++) f[i] = (ll)cnt[i] * fac[i] % mod; for (int i = 0; i &lt;= n; i++) g[i] = fac_inv[n - i]; ntt(f, lim), ntt(g, lim), inv_lim = inv(lim); for (int i = 0; i &lt; lim; i++) f[i] = (ll)f[i] * g[i] % mod; std::reverse(f + 1, f + lim), ntt(f, lim); for (int i = 0; i &lt; lim; i++) f[i] = (ll)f[i] * inv_lim % mod; for (int i = 1; i &lt;= n; i++) ans[i] = (ll)f[i + n] * fac_inv[i] % mod; for (int i = 1; i &lt;= n; i++) ans[i] = ((ll)n * C(n, i) - ans[i] + mod) % mod; for (int i = 1; i &lt;= n; i++) print(ans[i], \" \\n\"[i == n]);}} signed main() { return ringo::main(), 0; }","link":"/at2054/"},{"title":"BZOJ1070 - [SCOI2007]修车","text":"最小费用最大流。由于一个工人在给一个顾客服务后还能再给一个顾客服务， 所以把每个顾客和每个工人建点显然不能完成任务。 那么我们考虑把第 $i$ 个工人建成 $n$ 个点，表示为 $P(i,j) (i \\in [1, m], j \\in [1, n])$。把第 $i$ 个顾客表示为 $T(k)$。 把 $T(k)$ 依次向 $P(i,j)$ 连边，流量为 $1$ ，费用为 $w(k,i) \\times j$ 。表示第 $k$ 个顾客被第 $i$ 个工人倒数第 $j$ 个服务对答案产生的贡献（即包括在它之后的人的等待时间，而不是这个人自己的花费）。 最后从源点向每个顾客连流量 $1$ ，费用 $0$ 的边，$n \\times m$ 个工人向汇点连流量 $1$ ，费用为 $0$ 的边，跑最小费用最大流即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long long#define rep(i,l,r) for (int i = l; i &lt;= r; i++)#define getc(x) getchar(x)#define putc(x) putchar(x)template &lt;typename T&gt; inline void read(T &amp;x) { x = 0; register char ch; register bool fl = 0; while (ch = getc(), ch &lt; 48 || 57 &lt; ch) fl ^= ch == '-'; x = (ch &amp; 15); while (ch = getc(), 47 &lt; ch &amp;&amp; ch &lt; 58) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch &amp; 15); if (fl) x = -x;}template &lt;typename T&gt; inline void print(T x, char c = '\\n') { static int buf[40]; if (x == 0) { putc('0'); return; } if (x &lt; 0) putc('-'), x = -x; for (buf[0] = 0; x; x /= 10) buf[++buf[0]] = x % 10 + 48; while (buf[0]) putc((char) buf[buf[0]--]); putc(c);}const int maxn = 4010, maxm = 1000010;#define at(i,j) ((i) * m + (j))int n, m, u, v, w, s, e, l, r, ans, flag;int dis[maxn], pre[maxn], inq[maxn], q[maxn];int tot = 2, hed[maxn], nxt[maxm], to[maxm], val[maxm], cst[maxm];inline void add_simple_edge(int u, int v, int w, int c) { nxt[tot] = hed[u], to[tot] = v, val[tot] = w, cst[tot] = c; hed[u] = tot++;}inline void add_edge(int u, int v, int w, int c) { add_simple_edge(u, v, w, c); add_simple_edge(v, u, 0, -c);}bool spfa() { memset(dis, 63, sizeof(dis)); memset(pre, 0, sizeof(pre)); l = r = 1, q[1] = s, inq[s] = 1, dis[s] = 0; while (l &lt;= r) { u = q[(l++) % (e + 2)], inq[u] = 0; for (int i = hed[u], v = to[i]; i; i = nxt[i], v = to[i]) if (val[i] &amp;&amp; dis[v] &gt; dis[u] + cst[i]) { dis[v] = dis[u] + cst[i]; pre[v] = i; if (!inq[v]) { inq[v] = 1; q[(++r) % (e + 2)] = v; } } } return pre[e];}int main() { read(n), read(m); s = n * m + m + 1, e = s + 1; for (int i = 1; i &lt;= m; i++) { for (int j = 1; j &lt;= n; j++) { read(w); for (int k = 1; k &lt;= m; k++) add_edge(i, at(j, k), 1, w * k); } } for (int i = 1; i &lt;= m; i++) add_edge(s, i, 1, 0); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) add_edge(at(i, j), e, 1, 0); while (spfa()) { for (int i = pre[e]; i; i = pre[to[i ^ 1]]) val[i] -= 1, val[i ^ 1] += 1; for (int i = pre[e]; i; i = pre[to[i ^ 1]]) ans += cst[i]; } printf(\"%.2lf\\n\", ans / (double)m); return 0;}","link":"/bzoj1070/"},{"title":"BZOJ1002 - [FJOI2007]轮状病毒","text":"这题的规律是很好找的，难的就是需要用高精度进行计算。 于是我…厚颜无耻地逃避了高精度，用 Python 打了个表： 12345678910111213141516def locate(x): a = [1, 3] for i in range(2, x): a.append(a[-1] + a[-2]) # print(a) return a[x - 1]def solve(x): t = locate(x) if x % 2 == 1: return t ** 2 else: return t ** 2 - 4n = int(input())print(solve(n)) C++ 交表： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long long#define rep(i,l,r) for (int i = l; i &lt;= r; i++)#define getc(x) getchar(x)#define putc(x) putchar(x)template &lt;typename T&gt; inline void read(T &amp;x) { x = 0; register char ch; register bool fl = 0; while (ch = getc(), ch &lt; 48 || 57 &lt; ch) fl ^= ch == '-'; x = (ch &amp; 15); while (ch = getc(), 47 &lt; ch &amp;&amp; ch &lt; 58) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch &amp; 15); if (fl) x = -x;}template &lt;typename T&gt; inline void print(T x, char c = ' ') { static int buf[40]; if (x == 0) { putc('0'); putc(c); return; } if (x &lt; 0) putc('-'), x = -x; for (buf[0] = 0; x; x /= 10) buf[++buf[0]] = x % 10 + 48; while (buf[0]) putc((char) buf[buf[0]--]); putc(c);}void init();int n;std::string ans[101];int main() { init(); read(n); std::cout &lt;&lt; ans[n] &lt;&lt; std::endl; return 0;} void init() { ans[1] = \"1\"; ans[2] = \"5\"; ans[3] = \"16\"; ans[4] = \"45\"; ans[5] = \"121\"; ans[6] = \"320\"; ans[7] = \"841\"; ans[8] = \"2205\"; ans[9] = \"5776\"; ans[10] = \"15125\"; ans[11] = \"39601\"; ans[12] = \"103680\"; ans[13] = \"271441\"; ans[14] = \"710645\"; ans[15] = \"1860496\"; ans[16] = \"4870845\"; ans[17] = \"12752041\"; ans[18] = \"33385280\"; ans[19] = \"87403801\"; ans[20] = \"228826125\"; ans[21] = \"599074576\"; ans[22] = \"1568397605\"; ans[23] = \"4106118241\"; ans[24] = \"10749957120\"; ans[25] = \"28143753121\"; ans[26] = \"73681302245\"; ans[27] = \"192900153616\"; ans[28] = \"505019158605\"; ans[29] = \"1322157322201\"; ans[30] = \"3461452808000\"; ans[31] = \"9062201101801\"; ans[32] = \"23725150497405\"; ans[33] = \"62113250390416\"; ans[34] = \"162614600673845\"; ans[35] = \"425730551631121\"; ans[36] = \"1114577054219520\"; ans[37] = \"2918000611027441\"; ans[38] = \"7639424778862805\"; ans[39] = \"20000273725560976\"; ans[40] = \"52361396397820125\"; ans[41] = \"137083915467899401\"; ans[42] = \"358890350005878080\"; ans[43] = \"939587134549734841\"; ans[44] = \"2459871053643326445\"; ans[45] = \"6440026026380244496\"; ans[46] = \"16860207025497407045\"; ans[47] = \"44140595050111976641\"; ans[48] = \"115561578124838522880\"; ans[49] = \"302544139324403592001\"; ans[50] = \"792070839848372253125\"; ans[51] = \"2073668380220713167376\"; ans[52] = \"5428934300813767249005\"; ans[53] = \"14213134522220588579641\"; ans[54] = \"37210469265847998489920\"; ans[55] = \"97418273275323406890121\"; ans[56] = \"255044350560122222180445\"; ans[57] = \"667714778405043259651216\"; ans[58] = \"1748099984655007556773205\"; ans[59] = \"4576585175559979410668401\"; ans[60] = \"11981655542024930675232000\"; ans[61] = \"31368381450514812615027601\"; ans[62] = \"82123488809519507169850805\"; ans[63] = \"215002084978043708894524816\"; ans[64] = \"562882766124611619513723645\"; ans[65] = \"1473646213395791149646646121\"; ans[66] = \"3858055874062761829426214720\"; ans[67] = \"10100521408792494338631998041\"; ans[68] = \"26443508352314721186469779405\"; ans[69] = \"69230003648151669220777340176\"; ans[70] = \"181246502592140286475862241125\"; ans[71] = \"474509504128269190206809383201\"; ans[72] = \"1242282009792667284144565908480\"; ans[73] = \"3252336525249732662226888342241\"; ans[74] = \"8514727565956530702536099118245\"; ans[75] = \"22291846172619859445381409012496\"; ans[76] = \"58360810951903047633608127919245\"; ans[77] = \"152790586683089283455442974745241\"; ans[78] = \"400010949097364802732720796316480\"; ans[79] = \"1047242260609005124742719414204201\"; ans[80] = \"2741715832729650571495437446296125\"; ans[81] = \"7177905237579946589743592924684176\"; ans[82] = \"18791999880010189197735341327756405\"; ans[83] = \"49198094402450621003462431058585041\"; ans[84] = \"128802283327341673812651951847998720\"; ans[85] = \"337208755579574400434493424485411121\"; ans[86] = \"882823983411381527490828321608234645\"; ans[87] = \"2311263194654570182037991540339292816\"; ans[88] = \"6050965600552329018623146299409643805\"; ans[89] = \"15841633607002416873831447357889638601\"; ans[90] = \"41473935220454921602871195774259272000\"; ans[91] = \"108580172054362347934782139964888177401\"; ans[92] = \"284266580942632122201475224120405260205\"; ans[93] = \"744219570773534018669643532396327603216\"; ans[94] = \"1948392131377969933807455373068577549445\"; ans[95] = \"5100956823360375782752722586809405045121\"; ans[96] = \"13354478338703157414450712387359637585920\"; ans[97] = \"34962478192749096460599414575269507712641\"; ans[98] = \"91532956239544131967347531338448885552005\"; ans[99] = \"239636390525883299441443179440077148943376\"; ans[100] = \"627376215338105766356982006981782561278125\";}","link":"/bzoj1002/"},{"title":"BZOJ1001 - [BJOI2006]狼抓兔子","text":"最大流最小割模板题。 想当年第一次打开 BZOJ 做完 A + B 之后看得一脸懵逼的就是这道题，没想到现如今看起来这么简单 不过还是没有秒切，双向边没看到调了好久 QAQ 好了，关于那个连边。这是本人单向边网络流连边： 12345inline void add_edge(int u, int v, int w) { nxt[tot] = hed[u], to[tot] = v, val[tot] = w, hed[u] = tot++; nxt[tot] = hed[v], to[tot] = u, val[tot] = 0, hed[v] = tot++; return;} 这是本人的双向网络流连边（连两遍也是一样的）： 12345inline void add_edge(int u, int v, int w) { nxt[tot] = hed[u], to[tot] = v, val[tot] = w, hed[u] = tot++; nxt[tot] = hed[v], to[tot] = u, val[tot] = w, hed[v] = tot++; return;} 另外 $最大流 = 最小割$ 不必多说了吧，贴个直观的证明（来自：https://jecvay.com/2014/11/what-is-min-cut.html）： 1.最大流不可能大于最小割, 因为最大流所有的水流都一定经过最小割那些割边, 流过的水流怎么可能比水管容量还大呢? 2.最大流不可能小于最小割, 如果小, 那么说明水管容量没有物尽其用, 可以继续加大水流. 那么 SAP + 当前弧优化 + 断层优化 + 反向 BFS 一遍轻松跑过。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long long#define rep(i,l,r) for (int i = l; i &lt;= r; i++)#define getc(x) getchar(x)#define putc(x) putchar(x) template &lt;typename T&gt; inline void read(T &amp;x) { x = 0; register char ch; register bool fl = 0; while (ch = getc(), ch &lt; 48 || 57 &lt; ch) fl ^= ch == '-'; x = (ch &amp; 15); while (ch = getc(), 47 &lt; ch &amp;&amp; ch &lt; 58) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch &amp; 15); if (fl) x = -x;}template &lt;typename T&gt; inline void print(T x, char c = '\\n') { static int buf[40]; if (x == 0) { putc('0'); return; } if (x &lt; 0) putc('-'), x = -x; for (buf[0] = 0; x; x /= 10) buf[++buf[0]] = x % 10 + 48; while (buf[0]) putc((char) buf[buf[0]--]); putc(c);} const int maxn = 1000010, maxm = maxn * 6, inf = 1e9; int n, m, x, u, l, r, ans, flow, flag;int pre[maxn], dep[maxn], gap[maxn], cur[maxn], q[maxn];int tot = 2, hed[maxn], to[maxm], val[maxm], nxt[maxm]; #define at(i,j) (((i) - 1) * m + (j)) inline void add_edge(int u, int v, int w) { nxt[tot] = hed[u], to[tot] = v, val[tot] = w, hed[u] = tot++; nxt[tot] = hed[v], to[tot] = u, val[tot] = w, hed[v] = tot++; return;} void bfs() { for (int i = 1; i &lt;= n * m; i++) cur[i] = hed[i]; l = r = 1, q[1] = n * m, gap[1] = 1, dep[n * m] = 1; while (l &lt;= r) { u = q[l++]; for (int i = hed[u], v = to[i]; i; i = nxt[i], v = to[i]) { if (!dep[v]) { dep[v] = dep[u] + 1; gap[dep[v]]++; q[++r] = v; } } }} void isap(int s, int e) { u = s; while (dep[s] &lt;= e) { flag = 0; for (int &amp;i = cur[u], v = to[i]; i; i = nxt[i], v = to[i]) if (val[i] &amp;&amp; dep[v] + 1 == dep[u]) { u = v; pre[v] = i; flag = 1; break; } if (!flag) { if (!--gap[dep[u]]) break; dep[u] = e; for (int i = hed[u], v = to[i]; i; i = nxt[i], v = to[i]) if (val[i] &amp;&amp; dep[v] + 1 &lt; dep[u]) { dep[u] = dep[v] + 1; cur[u] = i; } ++gap[dep[u]]; if (u ^ s) u = to[pre[u] ^ 1]; } if (u == e) { flow = inf; for (int i = pre[e]; i; i = pre[to[i ^ 1]]) flow = std::min(flow, val[i]); for (int i = pre[e]; i; i = pre[to[i ^ 1]]) val[i] -= flow, val[i ^ 1] += flow; ans += flow, u = s; } }} int main() { read(n), read(m); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt; m; j++) read(x), add_edge(at(i, j), at(i, j + 1), x); for (int i = 1; i &lt; n; i++) for (int j = 1; j &lt;= m; j++) read(x), add_edge(at(i, j), at(i + 1, j), x); for (int i = 1; i &lt; n; i++) for (int j = 1; j &lt; m; j++) read(x), add_edge(at(i, j), at(i + 1, j + 1), x); bfs(); isap(1, n * m); print(ans); return 0;}","link":"/bzoj1001/"},{"title":"BZOJ2588 - Count on a tree","text":"询问树上路径第 $k$ 大：二分答案 + 树上查询。查询时用主席树差分： $$tree[now] = tree[u] + tree[v] - tree[lca(u,v)] - tree[father(lca(u,v))]$$ 时间复杂度 $O(n \\log ^2 n)$ 。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long long#define rep(i,l,r) for (int i = l; i &lt;= r; i++)#define getc(x) getchar(x)#define putc(x) putchar(x)template &lt;typename T&gt; inline void read(T &amp;x) { x = 0; register char ch; register bool fl = 0; while (ch = getc(), ch &lt; 48 || 57 &lt; ch) fl ^= ch == '-'; x = (ch &amp; 15); while (ch = getc(), 47 &lt; ch &amp;&amp; ch &lt; 58) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch &amp; 15); if (fl) x = -x;}template &lt;typename T&gt; inline void print(T x, char c = '\\n') { static int buf[40]; if (x == 0) { putc('0'); putc(c); return; } if (x &lt; 0) putc('-'), x = -x; for (buf[0] = 0; x; x /= 10) buf[++buf[0]] = x % 10 + 48; while (buf[0]) putc((char) buf[buf[0]--]); putc(c);}const int maxn = 100010, maxe = maxn * 40;int n, m, u, v, l, r, k, t, tn, pos, mid, ans, now, lastans;int val[maxn], tmp[maxn], root[maxn], dep[maxn];int f[maxn][20];int sum[maxe], lc[maxe], rc[maxe];int tot = 2, hed[maxn], to[maxn &lt;&lt; 1], nxt[maxn &lt;&lt; 1];inline void add_edge(int u, int v) { nxt[tot] = hed[u], to[tot] = v; hed[u] = tot++;}void build(int &amp;u, int l = 1, int r = tn) { u = ++pos; if (l == r) return; int mid = (l + r) &gt;&gt; 1; build(lc[u], l, mid); build(rc[u], mid + 1, r);}void modify(int &amp;u, int v, int k, int l = 1, int r = tn) { u = ++pos; lc[u] = lc[v], rc[u] = rc[v], sum[u] = sum[v] + 1; if (l == r) return; int mid = (l + r) &gt;&gt; 1; if (k &lt;= mid) modify(lc[u], lc[v], k, l, mid); else modify(rc[u], rc[v], k, mid + 1, r);}int query(int a, int b, int c, int d, int k, int l = 1, int r = tn) { if (l == r) return l; int now = sum[lc[a]] + sum[lc[b]] - sum[lc[c]] - sum[lc[d]]; int mid = (l + r) &gt;&gt; 1; if (k &lt;= now) return query(lc[a], lc[b], lc[c], lc[d], k, l, mid); else return query(rc[a], rc[b], rc[c], rc[d], k - now, mid + 1, r);}void dfs(int u) { modify(root[u], root[f[u][0]], val[u]); for (int i = hed[u], v = to[i]; i; i = nxt[i], v = to[i]) if (v ^ f[u][0]) { f[v][0] = u; dep[v] = dep[u] + 1; dfs(v); }}int lca(int u, int v) { if (dep[u] &gt; dep[v]) std::swap(u, v); for (int i = 19; i &gt;= 0; i--) if (dep[f[v][i]] &gt;= dep[u]) v = f[v][i]; if (u == v) return u; for (int i = 19; i &gt;= 0; i--) if (f[u][i] ^ f[v][i]) u = f[u][i], v = f[v][i]; return f[u][0];}int main() {// freopen(\"INPUT\", \"r\", stdin); read(n), read(m); for (int i = 1; i &lt;= n; i++) { read(val[i]); tmp[i] = val[i]; } std::sort(tmp + 1, tmp + n + 1); tn = std::unique(tmp + 1, tmp + n + 1) - tmp - 1; for (int i = 1; i &lt;= n; i++) val[i] = std::lower_bound(tmp + 1, tmp + tn + 1, val[i]) - tmp;// for (int i = 1; i &lt;= n; i++)// print(val[i], ' ');// putc('\\n');// for (int i = 1; i &lt;= tn; i++)// print(tmp[i], ' ');// putc('\\n'); for (int i = 1; i &lt; n; i++) { read(u), read(v); add_edge(u, v); add_edge(v, u); } build(root[0]); dep[1] = 1, dfs(1); for (int i = 1; i &lt; 20; i++) for (int j = 1; j &lt;= n; j++) f[j][i] = f[f[j][i - 1]][i - 1]; for (int i = 1; i &lt;= m; i++) { read(u), read(v), read(k); u ^= lastans, t = lca(u, v); print(lastans = tmp[query(root[u], root[v], root[t], root[f[t][0]], k)]); } return 0;}","link":"/bzoj2588/"},{"title":"BZOJ2410 - Nim游戏","text":"@GNAQ 给的博弈劲爆题，让人无言以对 233. 题解k &gt; 2对于这种情况，我们可以发现任何时候一定可以给空白格子染色。所以我们只需要判断剩余空白格子的奇偶性即可 k = 1显然被已经染色的格子分隔出的连续空白格子是不会相互影响的，所以我们可以把他看做一个组合 Nim 游戏，最后判断求一下每个游戏的 SG 函数异或和。 首先你要知道 mex 函数是什么，这里不再赘述，以下的打表程序中用到的实现是： 123456int mex(const std::set &lt;int&gt; &amp;set) { if (!set.size() || *set.begin()) return 0; for (auto i = set.begin(), j = ++set.begin(); j != set.end(); i = j, j++) if ((*i) + 1 != (*j)) return (*i) + 1; return (*--set.end()) + 1;} 此时题目可以转换为每次染色的格子必须与已经染色的格子不相邻。设 $ sg1 ( x ) $ 为有连续 $x$ 个空白格子可以放的 SG 值，则可以推出式子（注意边界情况）： $$ sg1(i) = mex ( sg1 ( j ) \\oplus sg1 ( i - j - 3) ( 1 \\leq j \\leq i - 4), sg1(i - 2), sg(i - 3)) $$ 写个程序打表： 1234567sg[0] = 0, sg[1] = 1, sg[2] = 1, sg[3] = 2;for (int i = 4; i &lt;= n; i++) { set.clear(), set.insert(sg[i - 2]), set.insert(sg[i - 3]); for (int j = 1; i - j - 3 &gt;= 1; j++) set.insert(sg[j] ^ sg[i - j - 3]); sg[i] = mex(set);} 跑出来以后，你可能会大叫这是什么 ** 玩意儿，下面是表： 123451 1 2 0 3 1 1 0 3 3 2 2 4 0 5 2 2 3 3 0 1 1 3 0 2 1 1 0 4 5 2 7 4 01 1 2 0 3 1 1 0 3 3 2 2 4 4 5 5 2 3 3 0 1 1 3 0 2 1 1 0 4 5 3 7 4 81 1 2 0 3 1 1 0 3 3 2 2 4 4 5 5 9 3 3 0 1 1 3 0 2 1 1 0 4 5 3 7 4 81 1 2 0 3 1 1 0 3 3 2 2 4 4 5 5 9 3 3 0 1 1 3 0 2 1 1 0 4 5 3 7 4 81 1 2 0 3 1 1 0 3 3 2 2 4 4 5 5 9 3 3 0 1 1 3 0 2 1 1 0 4 5 3 7 4 8 可以发现每 34 位一循环，除了第一行和第二行有些特例（我才不会告诉你我是因为当初没仔细看后几位的差别才找到这个循环节的…） k = 2同理，我们可以这样假设 SG 函数（请注意这里的定义与 $k = 1$ 有略微的差别）： $sg2(x, 0)$ 表示连续 $x$ 个空白格子且两端格子相同 $sg2(x, 1)$ 表示连续 $x$ 个空白格子且两端格子不同 $sg2(x, 2)$ 表示连续 $x$ 个空白格子且一端是已经染色的格子，另一端是边缘 $sg2(x, 3)$ 表示连续 $x$ 个空白格子且两端都是边缘 虽然最后一种情况，但是数据里并没有，你不判断也没什么关系。 然后推一波式子（懒得写 $\\LaTeX$ 了，直接看下面的打表程序） 123456789101112131415161718192021222324252627sg[0][0] = sg[0][1] = sg[0][2] = sg[0][3] = sg[1][1] = 0;sg[1][0] = sg[1][2] = sg[1][3] = 1;for (int i = 2; i &lt;= n; i++) { set.clear(), set.insert(sg[i - 1][1]); for (int j = 1; i - j - 1 &gt;= 1; j++) { set.insert(sg[j][0] ^ sg[i - j - 1][0]); set.insert(sg[j][1] ^ sg[i - j - 1][1]); } sg[i][0] = mex(set); set.clear(), set.insert(sg[i - 1][0]); for (int j = 1; i - j - 1 &gt;= 1; j++) set.insert(sg[j][0] ^ sg[i - j - 1][1]); sg[i][1] = mex(set); set.clear(), set.insert(sg[i - 1][2]), set.insert(sg[i - 1][0]), set.insert(s[i - 1][1]); for (int j = 1; i - j - 1 &gt;= 1; j++) { set.insert(sg[j][0] ^ sg[i - j - 1][2]); set.insert(sg[j][1] ^ sg[i - j - 1][2]); } sg[i][2] = mex(set); set.clear(), set.insert(sg[i - 1][2]); for (int j = 1; i - j - 1 &gt;= 1; j++) set.insert(sg[j][2] ^ sg[i - j - 1][2]); sg[i][3] = mex(set);} 可以发现： $sg2(x, 0) = 1$ $sg2(x, 1) = 0$ $sg2(x, 2) = x$ $sg2(x, 3) = x \\mod 2$ 综上所述即可写出程序。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// =================================// author: memset0// date: 2019.01.04 10:26:33// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;#define ll long longnamespace ringo {template &lt;class T&gt; inline void read(T &amp;x) { x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;}template &lt;class T&gt; inline void print(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);}template &lt;class T&gt; inline void print(T x, char c) { print(x), putchar(c); }const int N = 1e5 + 10;int T, n, m, a[N];inline void finally(bool flag) { putchar(flag ? 'y' : 'n'), putchar('\\n');}int sg1_1[] = { 0, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 0, 5, 2, 2, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 2, 7, 4, 0, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 2, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4}, sg1_2[] = { 8, 1, 1, 2, 0, 3, 1, 1, 0, 3, 3, 2, 2, 4, 4, 5, 5, 9, 3, 3, 0, 1, 1, 3, 0, 2, 1, 1, 0, 4, 5, 3, 7, 4};inline int sg1(int x) { if (x &lt;= 0) return 0; if (x &lt; 68) return sg1_1[x]; return sg1_2[x % 34]; }inline int sg2(int x, int y) { if (!x) return 0; if (y &lt; 2) return y ^ 1; if (y == 3) return x &amp; 1; return x;}void main() { for (read(T); T--; ) { read(n), read(m); for (register int i = 1; i &lt;= n; i++) read(a[i]); if (m == 1) { int cnt = 1, ans = 0; for (int i = 1; i &lt;= n; i++) if (a[i]) { ans ^= sg1(cnt - 2); cnt = 0; } else ++cnt; ++cnt, ans ^= sg1(cnt - 2); finally(ans); } else if (m == 2) { int cnt = 0, lst = 0, ans = 0; for (register int i = 1; i &lt;= n; i++) if (a[i]) { if (lst == 0) ans ^= sg2(cnt, 2); else if (lst == a[i]) ans ^= sg2(cnt, 0); else if (lst != a[i]) ans ^= sg2(cnt, 1); cnt = 0, lst = a[i]; } else ++cnt; if (lst == 0) ans ^= sg2(cnt, 3); else ans ^= sg2(cnt, 2); finally(ans); } else { int cnt = 0; for (register int i = 1; i &lt;= n; i++) cnt += !a[i]; finally(cnt &amp; 1); } }}} signed main() { return ringo::main(), 0; } 打表程序1： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// =================================// author: memset0// date: 2019.01.04 09:37:28// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;#define ll long longnamespace ringo {template &lt;class T&gt; inline void read(T &amp;x) { x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;}template &lt;class T&gt; inline void print(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);}template &lt;class T&gt; inline void print(T x, char c) { print(x), putchar(c); }const int N = 1e5 + 10;int n, sg[N];std::set &lt;int&gt; set;int mex(const std::set &lt;int&gt; &amp;set) { if (!set.size() || *set.begin()) return 0; for (auto i = set.begin(), j = ++set.begin(); j != set.end(); i = j, j++) if ((*i) + 1 != (*j)) return (*i) + 1; return (*--set.end()) + 1;}void main() { n = 200; sg[0] = 0, sg[1] = 1, sg[2] = 1, sg[3] = 2; for (int i = 4; i &lt;= n; i++) { set.clear(), set.insert(sg[i - 2]), set.insert(sg[i - 3]); for (int j = 1; i - j - 3 &gt;= 1; j++) set.insert(sg[j] ^ sg[i - j - 3]); sg[i] = mex(set); } for (int i = 1; i &lt;= n; i++) { print(sg[i], ' '); if (i % 34 == 0) putchar('\\n'); }}} signed main() { return ringo::main(), 0; } 打表程序2： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// =================================// author: memset0// date: 2019.01.04 09:37:28// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;#define ll long longnamespace ringo {template &lt;class T&gt; inline void read(T &amp;x) { x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;}template &lt;class T&gt; inline void print(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);}template &lt;class T&gt; inline void print(T x, char c) { print(x), putchar(c); }const int N = 1e5 + 10;int n, sg[N][4];std::set &lt;int&gt; set;int mex(const std::set &lt;int&gt; &amp;set) { if (!set.size() || *set.begin()) return 0; for (auto i = set.begin(), j = ++set.begin(); j != set.end(); i = j, j++) if ((*i) + 1 != (*j)) return (*i) + 1; return (*--set.end()) + 1;}void main() { n = 200; sg[0][0] = sg[0][1] = sg[0][2] = sg[0][3] = 0; sg[1][0] = 1, sg[1][1] = 0, sg[1][2] = 1, sg[1][3] = 1; for (int i = 2; i &lt;= n; i++) { set.clear(), set.insert(sg[i - 1][1]); for (int j = 1; i - j - 1 &gt;= 1; j++) { set.insert(sg[j][0] ^ sg[i - j - 1][0]); set.insert(sg[j][1] ^ sg[i - j - 1][1]); } sg[i][0] = mex(set); set.clear(), set.insert(sg[i - 1][0]); for (int j = 1; i - j - 1 &gt;= 1; j++) set.insert(sg[j][0] ^ sg[i - j - 1][1]); sg[i][1] = mex(set); set.clear(), set.insert(sg[i - 1][2]), set.insert(sg[i - 1][0]), set.insert(s[i - 1][1]); for (int j = 1; i - j - 1 &gt;= 1; j++) { set.insert(sg[j][0] ^ sg[i - j - 1][2]); set.insert(sg[j][1] ^ sg[i - j - 1][2]); } sg[i][2] = mex(set); set.clear(), set.insert(sg[i - 1][2]); for (int j = 1; i - j - 1 &gt;= 1; j++) set.insert(sg[j][2] ^ sg[i - j - 1][2]); sg[i][3] = mex(set); } for (int i = 1; i &lt;= n; i++) printf(\"%d %d %d %d\\n\", sg[i][0], sg[i][1], sg[i][2], sg[i][3]);}} signed main() { return ringo::main(), 0; }","link":"/bzoj2410/"},{"title":"BZOJ3551 - [ONTAK2010]Peaks加强版","text":"这题洛谷的数据太…水，克鲁斯卡尔重构树不连通都可水过。 3545: [ONTAK2010]Peaks 3551: [ONTAK2010]Peaks加强版 在线算法：克鲁斯卡尔重构树套主席树。 在克鲁斯卡尔重构树上维护 DFS 序（或树链剖分）再套上主席树，维护第 $k$ 大。 当然非加强版由于你是重构树（被针对了）可能要大力卡常。比如加个 fread 以及离散化一下什么的。 代码（ Fast IO 直接用了别人的板子不要在意 qwq）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long long#define il inline#define re register #define DEBUG std::cerr &lt;&lt; std::clock() &lt;&lt; endl#define rep(i,l,r) for (int i = l; i &lt;= r; i++)#define getc(x) getchar(x)#define putc(x) putchar(x)namespace FastIO { const size_t str = 1 &lt;&lt; 20; struct Reader { char buf[str], *s, *t; Reader ( ) : s( ), t( ), buf() { } inline char pick ( ) { return (s == t) ? ( t = buf + fread ( s = buf, 1, str , stdin ), *s++ ) : ( *s++ ); } template &lt; class T &gt; inline Reader&amp; operator &gt;&gt; ( T&amp; x ) { static char ch; static short opt; opt = (ch != 45); while ( !isdigit ( ch = pick () ) &amp;&amp; (ch ^ -1) &amp;&amp; ( ch ^ 45 ) ); if ( ch == -1 ) return *this; if ( ch == 45 ) { opt = 0; ch = pick (); } for ( x = -48 + ch; isdigit ( ch = pick () ); ( x *= 10 ) += ch - 48 ); opt ? 1 : x = -x; return *this; } } cin; struct Writer { char buf[str], *s, *t; Writer () : s ( buf ), t( buf + str ), buf ( ) { } ~Writer () { fwrite( buf, 1, s - buf, stdout ); } inline void echo ( char c ) { ( s == t ) ? ( fwrite ( s = buf, 1, str, stdout ), *s++ = c ) : ( *s++ = c ); } inline Writer&amp; operator &lt;&lt; ( long long x ) { if( !x ) return echo( 48 ), *this; static int t[21], top; if (x &lt; 0) x = -x, echo ( '-' ); while ( x ) t[++top] = x % 10, x /= 10; while ( top ) echo(t[top--] + 48); return *this; } inline Writer&amp; operator &lt;&lt; (const char* s) { while ( *s ) echo( *s++ ) ; return *this; } } cout; const char *endl = \"\\n\";} using FastIO::cin;using FastIO::cout;using FastIO::endl;const int N = 200010, M = 500010, E = N * 30;int n, m, p, u, v, w, t, x, k, tn, cnt, pos, ord, lastans;int b[N], fa[N], id[N], wid[N], val[N], siz[N];int f[N][20], g[N][20];int lc[E], rc[E], sum[E], root[N];bool vis[N];struct edge { int u, v, w;} e[M];bool operator &lt; (const edge &amp;a, const edge &amp;b) { return a.w &lt; b.w;}int tot = 2, hed[N], nxt[N &lt;&lt; 1], to[N &lt;&lt; 1];il void add_edge(int u, int v) { nxt[tot] = hed[u], to[tot] = v, hed[u] = tot++; nxt[tot] = hed[v], to[tot] = u, hed[v] = tot++;}il int find(int u) { if (fa[u] == u) return u; return fa[u] = find(fa[u]);}void dfs(int u) { siz[u] = 1, id[u] = ++pos, wid[id[u]] = u, vis[u] = 1; for (int i = hed[u], v = to[i]; i; i = nxt[i], v = to[i]) if (v ^ f[u][0]) { f[v][0] = u; g[v][0] = (u &lt;= n ? 0 : val[u]); dfs(v); siz[u] += siz[v]; }}void build(int &amp;u, int v, int l, int r, int k) { u = ++ord, lc[u] = lc[v], rc[u] = rc[v], sum[u] = sum[v] + 1; if (l == r) return; int mid = (l + r) &gt;&gt; 1; if (k &lt;= mid) build(lc[u], lc[v], l, mid, k); else build(rc[u], rc[v], mid + 1, r, k);}int query(int u, int v, int l, int r, int k) { if (l == r) return (k &lt;= (sum[v] - sum[u]) ? b[l] : -1); if (l == r) return l; int mid = (l + r) &gt;&gt; 1, tmp; tmp = sum[rc[v]] - sum[rc[u]]; if (k &lt;= tmp) return query(rc[u], rc[v], mid + 1, r, k); else return query(lc[u], lc[v], l, mid, k - tmp);}int main() { cin &gt;&gt; n &gt;&gt; m &gt;&gt; p; for (re int i = 1; i &lt;= n; i++) cin &gt;&gt; val[i]; for (re int i = 1; i &lt;= m; i++) cin &gt;&gt; e[i].u &gt;&gt; e[i].v &gt;&gt; e[i].w; std::sort(e + 1, e + m + 1); for (re int i = 1; i &lt;= (n &lt;&lt; 1); i++) fa[i] = i; cnt = n; for (re int i = 1; i &lt;= n; i++) b[i] = val[i]; std::sort(b + 1, b + n + 1); tn = std::unique(b + 1, b + n + 1) - b - 1; for (re int i = 1; i &lt;= n; i++) val[i] = std::lower_bound(b + 1, b + tn + 1, val[i]) - b; for (re int i = 1; i &lt;= m; i++) { u = e[i].u, v = e[i].v, w = e[i].w; if (find(u) ^ find(v)) { t = ++cnt; u = find(u), v = find(v); fa[u] = fa[v] = t; add_edge(u, t); add_edge(v, t); val[t] = w; } } val[++cnt] = 1e9; for (re int i = 1; i &lt; cnt; i++) if (find(i) != find(cnt)) { add_edge(find(i), cnt); fa[find(i)] = find(cnt); } dfs(cnt); for (re int i = 1; i &lt;= cnt; i++) if (wid[i] &lt;= n) build(root[i], root[i - 1], 1, tn, val[wid[i]]); else root[i] = root[i - 1]; for (re int i = 1; i &lt;= 19; i++) for (re int j = 1; j &lt;= cnt; j++) { f[j][i] = f[f[j][i - 1]][i - 1]; g[j][i] = std::max(g[j][i - 1], g[f[j][i - 1]][i - 1]); } for (re int i = 1; i &lt;= p; i++) { cin &gt;&gt; u &gt;&gt; x &gt;&gt; k; if (~lastans) { u ^= lastans; x ^= lastans; k ^= lastans; } for (re int i = 19; i &gt;= 0; i--) if (x &gt;= g[u][i] &amp;&amp; f[u][i]) { u = f[u][i]; } cout &lt;&lt; (lastans = query(root[id[u] - 1], root[id[u] + siz[u] - 1], 1, tn, k)) &lt;&lt; endl; } return 0;}","link":"/bzoj3551/"},{"title":"BZOJ3211 - 花神游历各国","text":"已知每个数最多能被开方而减小的次数是有限的，当当前的数是 $0$ 或 $1$ 时就没有必要操作。 所以我们可以用线段树维护区间最大值，如果当前的最大值已经等于 $0$ 或 $1$ ，就无需操作，否则逐个修改。 复杂度 $O(n \\sqrt {10^9} \\log n)$ ，可过。 区间取模操作同理。 理论上来说资瓷区间开方 / 取模和单点修改，算是优美的暴力吧。 多倍经验（数据范围和要求略有不同）： BZOJ3211 - 花神游历各国 洛谷4145 - 上帝造题的七分钟2 / 花神游历各国 SPOJ2713 - GSS4 - Can you answer these queries IV 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std; ll read() { ll x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;} const int maxn = 100010;int n, m, l, r, opt;ll a[maxn]; struct node { int l, r, mid; ll sum, max;} p[maxn &lt;&lt; 2]; void build(int l, int r, int u = 1) { p[u].l = l, p[u].r = r, p[u].mid = (l + r) &gt;&gt; 1; if (l == r) { if (a[l] == 0) { p[u].max = 1, p[u].sum = 0; } else p[u].max = p[u].sum = a[l]; return; } build(l, p[u].mid, u &lt;&lt; 1); build(p[u].mid + 1, r, u &lt;&lt; 1 | 1); p[u].sum = p[u &lt;&lt; 1].sum + p[u &lt;&lt; 1 | 1].sum; p[u].max = max(p[u &lt;&lt; 1].max, p[u &lt;&lt; 1 | 1].max);} void modify(int l, int r, int u = 1) { if (p[u].max == 1) { return; } if (p[u].l == p[u].r) { p[u].sum = p[u].max = sqrt(p[u].sum); return; } if (r &lt;= p[u].mid) modify(l, r, u &lt;&lt; 1); else if (l &gt; p[u].mid) modify(l, r, u &lt;&lt; 1 | 1); else modify(l, p[u].mid, u &lt;&lt; 1), modify(p[u].mid + 1, r, u &lt;&lt; 1 | 1); p[u].sum = p[u &lt;&lt; 1].sum + p[u &lt;&lt; 1 | 1].sum; p[u].max = max(p[u &lt;&lt; 1].max, p[u &lt;&lt; 1 | 1].max);} ll query(int l, int r, int u = 1) { if (p[u].l == l &amp;&amp; p[u].r == r) { return p[u].sum; } if (r &lt;= p[u].mid) return query(l, r, u &lt;&lt; 1); else if (l &gt; p[u].mid) return query(l, r, u &lt;&lt; 1 | 1); else return query(l, p[u].mid, u &lt;&lt; 1) + query(p[u].mid + 1, r, u &lt;&lt; 1 | 1);} int main() { n = read(); for (int i = 1; i &lt;= n; i++) a[i] = read(); build(1, n); m = read(); for (int i = 1; i &lt;= m; i++) { opt = read(), l = read(), r = read(); if (l &gt; r) swap(l, r); if (opt == 2) { modify(l, r); } else { printf(\"%lld\\n\", query(l, r)); } } return 0;}","link":"/bzoj3211/"},{"title":"BZOJ2839 - 集合计数","text":"设 $a(i)$ 表示大于等于 $i$ 的方案数，则： $$a(i) = {n \\choose i} (2^{2^{n-i}}-1)$$ 设 $f(i)$ 表示容斥系数，使得： $$ans = \\sum\\limits_{i=0}^n f(i) \\times a(i)$$ 考虑单个集合并为 $x$ 的选取方案对 $ans$ 的贡献，设： $$g(x) = [ x = k ]$$ 则： $$g(x) = \\sum\\limits_{i=0}^x {x \\choose i} f(i)$$ 二项式反演得： $$\\begin{aligned}f(x) &amp;= \\sum\\limits_{i=0}^x {x \\choose i} (-1)^{x-i} g(x) \\\\ &amp;= {x \\choose k} (-1)^{x-k} [x \\ge k]\\end{aligned}$$ 代入得： $$\\begin{aligned}ans &amp;= \\sum\\limits_{i=0}^n f(i) \\times a(i) \\\\ &amp;= \\sum\\limits_{i=0}^n {i \\choose k} (-1)^{i-k} [i \\ge k] \\times {n \\choose i} (2^{2^{n-i}} - 1) \\\\ &amp;= \\sum\\limits_{i=k}^n (-1)^{i-k} (2^{2^{n-i}} - 1) {i \\choose k} {n \\choose i}\\end{aligned}$$ 即可 $O(n \\log n)$ 求解 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// =================================// author: memset0// date: 2019.01.13 20:04:47// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;#define ll long longnamespace ringo {template &lt;class T&gt; inline void read(T &amp;x) { x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;}template &lt;class T&gt; inline void print(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);}template &lt;class T&gt; inline void print(T x, char c) { print(x), putchar(c); }const int N = 1e6 + 10, mod = 1e9 + 7;int n, k, now, ans;int fac[N], inv[N];inline int C(int n, int m) { return (ll)fac[n] * inv[m] % mod * inv[n - m] % mod;}inline int fpow(int a, int b, int mod) { int s = 1; for (; b; b &gt;&gt;= 1, a = (ll)a * a % mod) if (b &amp; 1) s = (ll)s * a % mod; return s;}void main() { read(n), read(k), fac[0] = fac[1] = inv[0] = inv[1] = 1; for (int i = 2; i &lt;= n; i++) fac[i] = (ll)fac[i - 1] * i % mod; for (int i = 2; i &lt;= n; i++) inv[i] = (ll)(mod - mod / i) * inv[mod % i] % mod; for (int i = 2; i &lt;= n; i++) inv[i] = (ll)inv[i - 1] * inv[i] % mod; for (int i = k; i &lt;= n; i++) { now = (i - k) &amp; 1 ? -1 : 1; now = (ll)now * C(n, i) % mod; now = (ll)now * C(i, k) % mod; now = (ll)now * (fpow(2, fpow(2, n - i, mod - 1), mod) - 1) % mod; ans = (ans + now) % mod; } print((ans + mod) % mod, '\\n');}} signed main() { return ringo::main(), 0; }","link":"/bzoj2839/"},{"title":"BZOJ4945 - [NOI2017] 游戏","text":"洛谷 SPJ 坏了，一个月了没修好。怎么回事啊？ UPD: QQ 群里 @ 了一下 chen_zhe 竟然很快修好了 回到正题：本题是 2-SAT 裸题，做之前可以参考一下洛谷的模板题，下面假装你已经看过并 AC 了那道题。 对于 $a$ 、 $b$ 、 $c$ 三种地图，都是不允许一辆车，而允许另外两辆。对于 $x$ 地图，显然不能交给 2-SAT 算法解决，暴力枚举他是 $a$ 地图还是 $b$ 地图（如果 $a$ 和 $b$ 都不行那么 $c$ 也不行）。 关于连边，用 $u$ 表示第 $i$ 场游戏使用赛车 $h_i$ 所对应的点，$v$ 表示 第 $j$ 场游戏赛车 $h_j$ 所对应的点，$u’$ 和 $v’$ 则表示对应地图可以使用的另一辆赛车所对应的点。 如果 $h_i$ 不符合第 $i$ 张地图的限制条件，那么这种约束肯定不会遇到，跳过即可。 如果 $h_j$ 不符合第 $j$ 张地图的限制条件，那么说明 $i$ 的这种情况肯定不能取到，就从 $u$ 向 $u’$ 连一条边。 否则说明如果取了 $h_i$ 就一定要取 $h_j$ ，连接边 $u$ 到 $v$ 和 $u’$ 到 $v’$ 即可。 另外，由于 2-SAT 要跑很多遍，所以请注意清空数组（我不会告诉你我没有清空 dfn 拿到了 $90$ 分的好成绩）。 照例上代码啦： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;int read() { int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;}char readc() { char c = getchar(); while (c != 'A' &amp;&amp; c != 'B' &amp;&amp; c != 'C') c = getchar(); return c;}const int maxn = 50010, maxm = 200010;int n, m, l, u, v, w, w1, w2, tim, top, pos;int a[maxm], b[maxm], c[maxm], d[maxm];int low[maxn &lt;&lt; 1], dfn[maxn &lt;&lt; 1], stk[maxn &lt;&lt; 1], col[maxn &lt;&lt; 1], t[10];char s[maxn];bool ins[maxn &lt;&lt; 1];int tot = 2, hed[maxn &lt;&lt; 1], to[maxm &lt;&lt; 1], nxt[maxm &lt;&lt; 1];void add_edge(int u, int v) { nxt[tot] = hed[u], to[tot] = v; hed[u] = tot++;}void tarjan(int u) { dfn[u] = low[u] = ++tim; ins[u] = 1, stk[++top] = u; for (int i = hed[u], v = to[i]; i; i = nxt[i], v = to[i]) { if (!dfn[v]) { tarjan(v); low[u] = min(low[u], low[v]); } else if (ins[v]) { low[u] = min(low[u], dfn[v]); } } if (low[u] == dfn[u]) { ++pos; while (top) { int v = stk[top--]; ins[v] = 0; col[v] = pos; if (u == v) break; } }}void solve() { tot = 2; memset(hed, 0, sizeof(hed)); memset(dfn, 0, sizeof(dfn)); for (int i = 1; i &lt;= m; i++) { u = a[i], w1 = c[i], v = b[i], w2 = d[i]; if (w1 == s[u] || (u == v &amp;&amp; w1 == w2)) continue; if (w2 == s[v] || (u == v &amp;&amp; w1 != w2)) { switch (s[u]) { case 'a': w1 = w1 == 'b' ? 0 : 1; break; case 'b': w1 = w1 == 'a' ? 0 : 1; break; case 'c': w1 = w1 == 'a' ? 0 : 1; break; } add_edge(w1 ? u + n : u, w1 ? u : u + n); continue; } switch (s[u]) { case 'a': w1 = w1 == 'b' ? 0 : 1; break; case 'b': w1 = w1 == 'a' ? 0 : 1; break; case 'c': w1 = w1 == 'a' ? 0 : 1; break; } switch (s[v]) { case 'a': w2 = w2 == 'b' ? 0 : 1; break; case 'b': w2 = w2 == 'a' ? 0 : 1; break; case 'c': w2 = w2 == 'a' ? 0 : 1; break; } add_edge(w1 ? u + n : u, w2 ? v + n : v); add_edge(w2 ? v : v + n, w1 ? u : u + n); } for (int i = 1; i &lt;= (n &lt;&lt; 1); i++) if (!dfn[i]) tarjan(i); for (int i = 1; i &lt;= n; i++) if (col[i] == col[i + n]) return; for (int i = 1; i &lt;= n; i++) { w = col[i] &lt; col[i + n]; switch (s[i]) { case 'a': putchar(w ? 'B' : 'C'); break; case 'b': putchar(w ? 'A' : 'C'); break; case 'c': putchar(w ? 'A' : 'B'); break; } } putchar('\\n'); exit(0);}void dfs(int k) { if (k &gt; l) { solve(); return; } s[t[k]] = 'a', dfs(k + 1); s[t[k]] = 'b', dfs(k + 1);}int main() { n = read(), l = read(), scanf(\"%s\", s + 1), m = read(); for (int i = 1; i &lt;= m; i++) { a[i] = read(), c[i] = readc() - 'A' + 'a'; b[i] = read(), d[i] = readc() - 'A' + 'a'; } for (int i = 1; i &lt;= n; i++) if (s[i] == 'x') t[++t[0]] = i; dfs(1); printf(\"-1\\n\"); return 0;}","link":"/bzoj4945/"},{"title":"BZOJ2956 - 模积和","text":"$$\\sum_{i=1}^{n} \\sum_{j=1}^{m} (n \\% i) \\times (m \\% j) \\ \\ \\ (i \\not= j)$$ $$= (\\sum_{i=1}^{n} n \\% i) \\times (\\sum_{j=1}^{m} m \\% j) - \\sum_{i=1}^{\\min(n, m)} (n \\% i) \\times (m \\% j)$$ 可以转化成 $A \\times B - C$ 的形式，分别来求。 其中求 $A$ 和 $B$ 的方式是一样的，可以数论分块，也可以直接打表找规律。鉴于这部分不难，笔者写了后者，而描述起来而笔者又非常懒因此忽略求 $A$ 、 $B$ 直接讲求 $C$ 。当然你也可以通过推 $C$ 的方式自己推一下 $A$ 、 $B$ 。 $$C = \\sum_{i=1}^{\\min(n, m)} (n \\% i) \\times (m \\% i)$$ $$= \\sum_{i=1} ^ {\\min(n, m)} (n - i \\times \\lfloor \\frac {n} {i} \\rfloor) \\times (m - i \\times \\lfloor \\frac {m} {i} \\rfloor )$$ $$= \\sum_{i=1} ^ {\\min(n, m)} n \\times m - m \\times i \\times \\lfloor \\frac {n} {i} \\rfloor - n \\times i \\times \\lfloor \\frac {m} {i} \\rfloor + i ^ 2 \\times \\lfloor \\frac {m} {i} \\rfloor \\lfloor \\frac {m} {i} \\rfloor $$ 数论分块即可。 鉴于笔者写代码时思路非常混乱，下面仅供对拍： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long long#define rep(i,l,r) for (int i = l; i &lt;= r; i++)#define getc(x) getchar(x)#define putc(x) putchar(x)template &lt;typename T&gt; inline void read(T &amp;x) { x = 0; register char ch; register bool fl = 0; while (ch = getc(), ch &lt; 48 || 57 &lt; ch) fl ^= ch == '-'; x = (ch &amp; 15); while (ch = getc(), 47 &lt; ch &amp;&amp; ch &lt; 58) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch &amp; 15); if (fl) x = -x;}template &lt;typename T&gt; inline void print(T x, char c = '\\n') { static int buf[40]; if (x == 0) { putc('0'); putc(c); return; } if (x &lt; 0) putc('-'), x = -x; for (buf[0] = 0; x; x /= 10) buf[++buf[0]] = x % 10 + 48; while (buf[0]) putc((char) buf[buf[0]--]); putc(c);}const ll p = 19940417;ll n, m;void update(ll &amp;x) { x = (x % p + p) % p;}ll sum(ll n) { ll a = n, b = n - 1; if (a % 2 == 0) a /= 2; else b /= 2; a %= p, b %= p; return a * b % p;}ll sum(ll l, ll r) { ll a = l + r, b = r - l + 1; if (a % 2 == 0) a /= 2; else b /= 2; a %= p, b %= p; return a * b % p;}ll sum2(ll n) { ll a = n, b = n + 1, c = (n &lt;&lt; 1) + 1; if (a % 2 == 0) a /= 2; else if (b % 2 == 0) b /= 2; else c /= 2; if (a % 3 == 0) a /= 3; else if (b % 3 == 0) b /= 3; else c /= 3; a %= p, b %= p, c %= p; return a * b % p * c % p;}ll solve(ll n) { ll m, ans = 0, sqn = sqrt(n), x, i, t; for (i = 2, x = n; x &gt; sqn; i++) { t = m = (n - (n / i)) - (n - x); m %= p; ans += (n % x) % p * (m % p) % p, update(ans); ans += sum(m) % p * ((i - 1) % p) % p, update(ans); x -= t; } for (i = 1; i &lt;= x; i++) ans += (n % i) % p, update(ans); return ans;}ll solve2(ll n, ll m) { if (n &gt; m) std::swap(n, m); ll ans = n * n % p * m % p; for (ll l = 1, r; l &lt;= n; l = r + 1) { r = std::min(n / (n / l), m / (m / l)); ans -= n % p * (m / l % p) % p * sum(l, r) % p, update(ans); ans -= m % p * (n / l % p) % p * sum(l, r) % p, update(ans); ans += (n / l % p) * (m / l % p) % p * ((sum2(r) - sum2(l - 1) + p) % p) % p, update(ans); } return ans;}int main() { read(n), read(m); print((solve(n) * solve(m) % p - solve2(n, m) + p) % p); return 0;}","link":"/bzoj2956/"},{"title":"BZOJ4939 - [YNOI2016] 掉进兔子洞","text":"bitset 套莫队板子题。 题意是如果第一个区间里有 $ a $ 个 $ x $ ，第二个区间 $ b $ 个，第三个区间 $ c $ 个，只会对答案产生 $ \\min(a, b, c) $ 的贡献；每次询问给你三个区间，问你三个区间里能产生这样的贡献的大小。 考虑 bitset 套莫队。通过一个简单的 trick 使得 bitset 既能反映出每种数又能反映出每种数的个数，每个查询就用三个区间的 bitset 的按位并，取结果的 count 。\u001e 然而 $ 10^5 $ 个 $ 10^5 $ 的 bitset 会 MLE 。我们把莫队分成三次，只需要三分之一的空间，可以卡进。 看起来这样 $ O(n ^ 2) $ 的复杂度过不了 $ n = 10^5 $ ，但是由于使用了 bitset 的关系，常数只有 1 / 32 ，实际跑的飞快。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// =================================// author: memset0// date: 2018.12.07 10:39:36// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;namespace ringo {typedef long long ll;template &lt; class T &gt;inline void read(T &amp;x) { x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;}template &lt; class T &gt;inline void print(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);}template &lt; class T &gt;inline void print(T x, char c) { print(x), putchar(c);}const int N = 1e5 + 10;int n, m, ul, ur, ql, qr, pos, sqn, sqm, tail;int a[N], b[N], id[N], ans[N], cnt[N];std::bitset &lt; N &gt; now, f[N / 3];struct query { int l1, r1, l2, r2, l3, r3; inline void read_query(int i) { // printf(\"read query %d\\n\", i); read(l1), read(r1), read(l2), read(r2), read(l3), read(r3); ans[i] += r1 - l1 + r2 - l2 + r3 - l3 + 3; }} q[N];struct query_small { int l, r, i; inline bool operator &lt; (const query_small &amp;other) const { if (l / sqn == other.l / sqn) return r &lt; other.r; return l &lt; other.l; }} p[N];inline void add(int x) { ++cnt[x]; now.set(x + cnt[x] - 1);}inline void del(int x) { now.reset(x + cnt[x] - 1); --cnt[x];}void solve(int L, int R) { pos = 0, tail = 0, now.reset(), memset(cnt, 0, sizeof(cnt)); for (int i = L; i &lt;= R; i++) { id[i] = ++pos; p[++tail] = (query_small){q[i].l1, q[i].r1, i}; p[++tail] = (query_small){q[i].l2, q[i].r2, i}; p[++tail] = (query_small){q[i].l3, q[i].r3, i}; } for (int i = 1; i &lt;= pos; i++) f[i].set(); std::sort(p + 1, p + tail + 1); ul = 1, ur = 0; for (int i = 1; i &lt;= tail; i++) { ql = p[i].l, qr = p[i].r; while (ul &gt; ql) add(a[--ul]); while (ur &lt; qr) add(a[++ur]); while (ul &lt; ql) del(a[ul++]); while (ur &gt; qr) del(a[ur--]); f[id[p[i].i]] &amp;= now; } for (int i = L; i &lt;= R; i++) ans[i] -= f[id[i]].count() * 3;}void main() { read(n), read(m), sqn = sqrt(n), sqm = m / 3 + 1; for (int i = 1; i &lt;= n; i++) read(a[i]), b[i] = a[i]; std::sort(b + 1, b + n + 1); for (int i = 1; i &lt;= n; i++) a[i] = std::lower_bound(b + 1, b + n + 1, a[i]) - b; for (int i = 1; i &lt;= m; i++) q[i].read_query(i); for (int i = 1; i &lt;= m; i += sqm) solve(i, std::min(m, i + sqm - 1)); for (int i = 1; i &lt;= m; i++) print(ans[i], '\\n');}} signed main() { return ringo::main(), 0; }","link":"/bzoj4939/"},{"title":"BZOJ4178 - A","text":"今天模拟赛的第一题， NTT 作多项式乘法，把后面的转移快速幂一下就过了。需要注意的是 950009857 的原根是 7 而不是 3 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// =================================// author: memset0// date: 2019.01.07 08:16:44// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;#define ll long longnamespace ringo {template &lt;class T&gt; inline void read(T &amp;x) { x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;}template &lt;class T&gt; inline void print(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);}template &lt;class T&gt; inline void print(T x, char c) { print(x), putchar(c); }const int N = 1e4 + 10, mod = 950009857;int n, m, k, x;int inv(int x) { return !x || x == 1 ? 1 : (ll)(mod - mod / x) * inv(mod % x) % mod; }inline int fpow(int a, int b) { int s = 1; for (; b; b &gt;&gt;= 1, a = (ll)a * a % mod) if (b &amp; 1) s = (ll)s * a % mod; return s;}typedef std::vector &lt;int&gt; vector;std::vector &lt;int&gt; a, b;int _a[N &lt;&lt; 2], _b[N &lt;&lt; 2], rev[N &lt;&lt; 2], g[2][30];inline void print(const vector &amp;a) { for (int i = 0, lim = a.size(); i &lt; lim; i++) print(a[i], \" \\n\"[i == lim - 1]);}inline void ntt(int *a, int lim, bool flag) { for (int i = 0; i &lt; lim; i++) if (i &lt; rev[i]) std::swap(a[i], a[rev[i]]); for (int len = 1, cnt = 1; len &lt; lim; len &lt;&lt;= 1, ++cnt) for (int i = 0, wn = g[flag][cnt]; i &lt; lim; i += (len &lt;&lt; 1)) for (int j = 0, w = 1; j &lt; len; j++, w = (ll)w * wn % mod) { int x = a[i + j], y = (ll)w * a[i + j + len] % mod; a[i + j] = (x + y) % mod, a[i + j + len] = (x - y + mod) % mod; }}inline vector operator * (const vector &amp;a, const vector &amp;b) { int lim = 1, k = 0, size_a = a.size(), size_b = b.size(); if (!size_a) return b; if (!size_b) return a; while (lim &lt;= (size_a + size_b)) lim &lt;&lt;= 1, ++k; for (int i = 0; i &lt; size_a; i++) _a[i] = a[i]; for (int i = 0; i &lt; size_b; i++) _b[i] = b[i]; for (int i = size_a; i &lt; lim; i++) _a[i] = 0; for (int i = size_b; i &lt; lim; i++) _b[i] = 0; for (int i = 0; i &lt; lim; i++) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (k - 1)); ntt(_a, lim, 0), ntt(_b, lim, 0); for (int i = 0; i &lt; lim; i++) _a[i] = (ll)_a[i] * _b[i] % mod; ntt(_a, lim, 1), lim = inv(lim); vector c(std::min(size_a + size_b - 1, n)); for (int i = 0; i &lt; (int)c.size(); i++) c[i] = (ll)_a[i] * lim % mod; return c;}void main() { for (int i = 0; i &lt; 30; i++) { g[0][i] = fpow(7, (mod - 1) / (1 &lt;&lt; i)); g[1][i] = fpow(fpow(7, mod - 2), (mod - 1) / (1 &lt;&lt; i)); } read(n), read(m), read(k); for (int i = 1; i &lt;= n; i++) read(x), a.push_back(x); b.resize(n); for (int i = 1; i &lt;= m; i++) read(x), ++b[x]; for (; k; k &gt;&gt;= 1, b = b * b) if (k &amp; 1) a = a * b; a.resize(n), print(a);}} signed main() { return ringo::main(), 0; }","link":"/bzoj4178/"},{"title":"BZOJ4179 - B","text":"今天模拟赛的第二题，还是大水题，但是由于 SPFA 打错调了好久，还有这个 SB 出题人怎么说都不说一句读入的 $L$ 是 long long 范围的啊，你™咋不上高精？ 好了，回归正常的题解。本题可以理解为 POI2000 病毒 的加强版（连样例都一样），于是按照惯例，我们只需要建造一棵 AC 自动机。如果能够找到环，那么一定能够产生无限长度的答案串，直接输出 Yes 即可。否则就是一棵 DAG ，跑一下 SPFA （或 BFS）求出最长的答案串，和要求的 $L$ 比较一下就好。 我不会说我写了个 SPFA 还写挂调了两个小时的… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103// =================================// author: memset0// date: 2019.01.07 08:46:27// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;#define ll long longnamespace ringo {template &lt;class T&gt; inline void read(T &amp;x) { x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;}template &lt;class T&gt; inline void print(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);}template &lt;class T&gt; inline void print(T x, char c) { print(x), putchar(c); }const int N = 1e5 + 10, M = 2e6 + 10;int n, x, tot, q[M], dis[M];bool inq[M], vis[M], found[M], find_answer;char a[N];ll m;struct node { int ch[2], fail; bool tag;} e[M];void insert(char *a) { int len = strlen(a), p = 1; for (int i = 0, x; i &lt; len; i++) { x = a[i] == 'A' ? 0 : 1; if (!e[p].ch[x]) e[p].ch[x] = ++tot; p = e[p].ch[x]; } e[p].tag = 1;}void build_fail() { std::queue &lt;int&gt; q; int p, t; if (e[1].ch[0]) q.push(e[1].ch[0]), e[e[1].ch[0]].fail = 1; if (e[1].ch[1]) q.push(e[1].ch[1]), e[e[1].ch[1]].fail = 1; while (q.size()) { p = q.front(), q.pop(); for (int i = 0; i &lt; 2; i++) if (e[p].ch[i]) { q.push(e[p].ch[i]); t = e[p].fail; while (t != 1 &amp;&amp; !e[t].ch[i]) t = e[t].fail; if (!e[t].ch[i]) e[e[t].ch[i]].fail = 1; else e[e[p].ch[i]].fail = e[t].ch[i], e[e[p].ch[i]].tag |= e[e[t].ch[i]].tag; } else e[p].ch[i] = e[e[p].fail].ch[i]; }}void find_circle(int u) { if (find_answer) return; vis[u] = 1; for (int i = 0; i &lt; 2; i++) { if (!e[u].ch[i]) continue; if (vis[e[u].ch[i]]) { find_answer = true; return; } else if (!e[e[u].ch[i]].tag &amp;&amp; !found[e[u].ch[i]]) { found[e[u].ch[i]] = 1; find_circle(e[u].ch[i]); } } vis[u] = 0;}bool spfa() { int u, v, l = 0, r = 0, max = 0; q[0] = 1, dis[1] = 0; while (l &lt;= r) { u = q[(l++) % tot]; for (int i = 0; i &lt; 2; i++) { v = e[u].ch[i]; if (dis[u] + 1 &gt; dis[v] &amp;&amp; v &amp;&amp; !e[v].tag) { dis[v] = dis[u] + 1; if (!inq[v]) inq[q[(++r) % tot] = v]; } } } for (int i = 1; i &lt;= tot; i++) max = std::max(dis[i], max); return max &gt;= m;}void main() { while (scanf(\"%d%lld\", &amp;n, &amp;m) != EOF) { for (int i = 1; i &lt;= tot; i++) e[i].ch[0] = e[i].ch[1] = e[i].fail = e[i].tag = 0; find_answer = 0, tot = 1; for (int i = 1; i &lt;= n; i++) scanf(\"%s\", a), insert(a); build_fail(), find_circle(1); if (!find_answer) find_answer = spfa(); puts(find_answer ? \"Yes\" : \"No\"); for (int i = 1; i &lt;= tot; i++) vis[i] = found[i] = dis[i] = inq[i] = 0; }}} signed main() { return ringo::main(), 0; }","link":"/bzoj4179/"},{"title":"BZOJ5405 - platform","text":"首先，我们需要知道如何利用后缀数组对一个指定的字符串计算字典序 Rank 。我们以 abaab 为例： 12345678910 a a b11 10 9 a b x 8 a b a a b x x 7 6 5 b 4 b a a b x 3 2 1 按照顺序进行编号，因为本质相同的字符串不重复计算次数，所以每一行的前 $height_i$ 个不计入个数，所以我们也有了一个很自然的 $O(n ^ 2)$ 做法。 接下来我们考虑正解，可以发现，每次可以看做对上面的字典序 Rank 数组进行了依次递减的区间覆盖，可以使用线段树维护。同时我们可以发现，这个 Rank 是递减的，而前缀和是递增的，所以我们可以二分出相等的那个位置。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124// =================================// author: memset0// date: 2019.01.10 10:37:10// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;#define ll long longnamespace ringo {template &lt;class T&gt; inline void read(T &amp;x) { x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;}template &lt;class T&gt; inline void print(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);}template &lt;class T&gt; inline void print(T x, char c) { print(x), putchar(c); }const int N = 4e5 + 10;int n, m, len, siz;int a[N], sa[N], rnk[N], tax[N], tmp[N], rank[N], height[N];char s[N];ll cnt, sum[N];std::vector &lt;std::pair &lt;int, int&gt; &gt; ans;inline ll get_sum(int l, int r) { return sum[r] - sum[l - 1]; }inline void check_ans(int l, int r, int x) { if (x == sum[r] - sum[l - 1]) ans.push_back(std::make_pair(l, r)); }void get_sa_sort() { for (int i = 1; i &lt;= siz; i++) tax[i] = 0; for (int i = 1; i &lt;= len; i++) tax[rnk[i]]++; for (int i = 1; i &lt;= siz; i++) tax[i] += tax[i - 1]; for (int i = len; i &gt;= 1; i--) sa[tax[rnk[tmp[i]]]--] = tmp[i];}void get_sa() { siz = 300, len = n; for (int i = 1; i &lt;= len; i++) rnk[i] = s[i], tmp[i] = i; get_sa_sort(); for (int now = 1, cnt = 0; cnt &lt; len; siz = cnt, now &lt;&lt;= 1) { cnt = 0; for (int i = len; i &gt;= len - now + 1; i--) tmp[++cnt] = i; for (int i = 1; i &lt;= len; i++) if (sa[i] &gt; now) tmp[++cnt] = sa[i] - now; get_sa_sort(), std::swap(rnk, tmp), rnk[sa[1]] = cnt = 1; for (int i = 2; i &lt;= len; i++) rnk[sa[i]] = (tmp[sa[i]] == tmp[sa[i - 1]] &amp;&amp; tmp[sa[i] + now] == tmp[sa[i - 1] + now]) ? cnt : ++cnt; }}void get_height() { for (int i = 1, j, ans = 0; i &lt;= len; i++) { j = sa[rnk[i] - 1]; if (ans) --ans; while (s[i + ans] == s[j + ans]) ++ans; height[rnk[i]] = ans; } height[1] = 0;}struct node { int l, r, mid, siz; ll tag; } p[N &lt;&lt; 2];inline void pushup(int u, ll x) { p[u].tag = x;}inline void pushdown(int u) { if (!~p[u].tag || p[u].l == p[u].r) return; pushup(u &lt;&lt; 1, p[u].tag); pushup(u &lt;&lt; 1 | 1, p[u].tag - p[u &lt;&lt; 1].siz); p[u].tag = -1;}void build(int u, int l, int r) { p[u].l = l, p[u].r = r, p[u].mid = (l + r) &gt;&gt; 1; p[u].tag = -1, p[u].siz = r - l + 1; if (l == r) return; build(u &lt;&lt; 1, l, p[u].mid); build(u &lt;&lt; 1 | 1, p[u].mid + 1, r);}void modify(int u, int l, int r, ll x) { pushdown(u); if (p[u].l == l &amp;&amp; p[u].r == r) return pushup(u, x); if (r &lt;= p[u].mid) modify(u &lt;&lt; 1, l, r, x); else if (l &gt; p[u].mid) modify(u &lt;&lt; 1 | 1, l, r, x); else modify(u &lt;&lt; 1, l, p[u].mid, x), modify(u &lt;&lt; 1 | 1, p[u].mid + 1, r, x - p[u].mid + l - 1);}ll query(int u, int k) { pushdown(u); if (p[u].l == p[u].r) return p[u].tag; return k &lt;= p[u].mid ? query(u &lt;&lt; 1, k) : query(u &lt;&lt; 1 | 1, k);}void dfs(int u, int l, int r) { pushdown(u); if (p[u].l == p[u].r) return print(p[u].tag, ' '); if (r &lt;= p[u].mid) dfs(u &lt;&lt; 1, l, r); else if (l &gt; p[u].mid) dfs(u &lt;&lt; 1 | 1, l, r); else dfs(u &lt;&lt; 1, l, p[u].mid), dfs(u &lt;&lt; 1 | 1, p[u].mid + 1, r);}void main() { scanf(\"%s\", s + 1), n = strlen(s + 1), get_sa(), get_height(); for (int i = 1; i &lt;= n; i++) read(a[i]), sum[i] = sum[i - 1] + a[i]; build(1, 1, n), cnt = n + (ll)n * (n - 1) / 2; for (int i = 1; i &lt;= n; i++) cnt -= height[i]; ll L, R; for (int i = 1; i &lt;= n; i++) { modify(1, height[i] + 1, n - sa[i] + 1, cnt); cnt -= n - sa[i] - height[i] + 1; for (int l = sa[i], r = n, mid; l &lt;= r; ) { mid = (l + r) &gt;&gt; 1, L = query(1, mid - sa[i] + 1), R = get_sum(sa[i], mid); if (L == R) { ans.push_back(std::make_pair(sa[i], mid)); break; } else (L &gt; R) ? l = mid + 1 : r = mid - 1; } } std::sort(ans.begin(), ans.end()), print(ans.size(), '\\n'); for (std::vector &lt;std::pair &lt;int, int&gt; &gt; ::iterator it = ans.begin(); it != ans.end(); it++) print(it-&gt;first, ' '), print(it-&gt;second, '\\n');}} signed main() { return ringo::main(), 0; }","link":"/bzoj5405/"},{"title":"BZOJ5404 - party","text":"和其他题解不太一样，这里没有用线段树…… 首先肯定会在 LCA 处集合，通过树剖 + bitset 维护出可选的集合。然后利用 Hall 定理进行完美匹配统计答案。可以发现直接树剖 + 暴力跳是 $O(n ^ 2)$ 的，所以限制树链的长度至多为 $S$ ，则复杂度为：$O(n + qcS\\times\\frac{m}{32} + qc \\times \\frac{n}{S} + q \\times 2^c \\times \\frac{m}{32})$ ，取 $S = \\sqrt n$ 。 然后跑的飞快 233333. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// =================================// author: memset0// date: 2019.01.10 14:41:24// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;#define ll long longnamespace ringo {template &lt;class T&gt; inline void read(T &amp;x) { x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;}template &lt;class T&gt; inline void print(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);}template &lt;class T&gt; inline void print(T x, char c) { print(x), putchar(c); }const int N = 3e5 + 10, M = 1001;int n, m, q, pos, lca, sqn;int a[N], c[10], top[N], fa[N], dep[N], siz[N], son[N], id[N], wid[N];std::bitset &lt;M&gt; mix, f[10], pre[N];std::vector &lt;int&gt; G[N];const std::bitset &lt;M&gt; empty_bitset;void dfs(int u) { siz[u] = 1; if (!G[u].size()) return; for (int i = 0, v = G[u][0]; i &lt; (int)G[u].size(); i++, v = G[u][i]) if (v != fa[u]) { fa[v] = u, dep[v] = dep[u] + 1, dfs(v), siz[u] += siz[v]; if (siz[v] &gt; siz[son[u]]) son[u] = v; }}void dfs(int u, int toppoint, int dep = 1, const std::bitset &lt;M&gt; &amp;from = empty_bitset) { top[u] = toppoint, id[u] = ++pos, wid[id[u]] = u; pre[u] = from, pre[u].set(a[u]); if (siz[u] == 1) return; if (dep &lt;= sqn) { dfs(son[u], toppoint, dep + 1, pre[u]); if (!G[u].size()) return; for (int i = 0, v = G[u][0]; i &lt; (int)G[u].size(); i++, v = G[u][i]) if (v != fa[u] &amp;&amp; v != son[u]) dfs(v, v); } else { if (!G[u].size()) return; for (int i = 0, v = G[u][0]; i &lt; (int)G[u].size(); i++, v = G[u][i]) if (v != fa[u]) dfs(v, v); }}inline int get_lca(int u, int v) { while (top[u] != top[v]) { if (dep[top[u]] &gt; dep[top[v]]) std::swap(u, v); v = fa[top[v]]; } return dep[u] &lt; dep[v] ? u : v;}inline void get_bitset(int u, int v, std::bitset &lt;M&gt; &amp;f) { f.reset(); while (top[u] != top[v]) f |= pre[u], u = fa[top[u]]; while (u != v) f.set(a[u]), u = fa[u]; f.set(a[v]);}void main() { read(n), read(m), read(q), sqn = sqrt(n); for (int i = 2, x; i &lt;= n; i++) read(x), G[x].push_back(i); for (int i = 1; i &lt;= n; i++) read(a[i]); dfs(1), dfs(1, 1); for (int i = 1, t, ans; i &lt;= q; i++) { read(t), read(c[1]), lca = c[1]; for (int i = 2; i &lt;= t; i++) read(c[i]), lca = get_lca(lca, c[i]); for (int i = 1; i &lt;= t; i++) get_bitset(c[i], lca, f[i]); ans = m / t + 1; for (int x = 1; x &lt; (1 &lt;&lt; t) &amp;&amp; ans; x++) { mix.reset(); for (int i = 1; i &lt;= t; i++) if (x &amp; (1 &lt;&lt; (i - 1))) mix |= f[i]; ans = std::min(ans, (int)mix.count() / __builtin_popcount(x)); } print(ans * t, '\\n'); }}} signed main() { return ringo::main(), 0; }","link":"/bzoj5404/"},{"title":"BZOJ5403 - marshland","text":"这个数据范围容易让人想到网络流，问题在于这个网络流怎么流？ 首先可以发现，如果我们要放石头，一定只会放在 $x + y$ 为奇数的格子，否则放了不如不放。所以把这些点拆点，连一条费用为 $a[x][y]$ ，流量为 $1$ 的边。 接下来，我们可以构造一种对 $x + y$ 为偶数的格子的黑白染色方案，使得一个 L 型石头的两个 $x + y$ 为偶数的格子异色。容易发现，我们只需要对所有 $x$ 和 $y$ 都是奇数的格子染黑， $x$ 和 $y$ 都是偶数的格子染白。同理，拆成两个点，中间连一条费用为 $0$ ，流量为 $1$ 的边。 同时，为了使得总放置的石头数为 $m$ ，我们还需要再建一个点 $P$ 。 于是源点 $S$ 向 $P$ 连边， $P$ 向黑点连边，黑点向 $x + y$ 为奇数的点连边， $x + y$ 为奇数的点向白点连边，白点向汇点 $E$ 连边即可。 需要注意的是，我们跑最大费用最大流，但是我们只需要费用最大，而不是流量。由于我们采用增广路算法，每次新增的流量的花费一定递减，所以当花费是负数时直接跳出即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// =================================// author: memset0// date: 2019.01.10 08:14:13// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;#define ll long longnamespace ringo {template &lt;class T&gt; inline void read(T &amp;x) { x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;}template &lt;class T&gt; inline void print(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);}template &lt;class T&gt; inline void print(T x, char c) { print(x), putchar(c); }const int N = 55, Nd = 5010, Ed = 1000010;int n, m, k, l, r, u, s, e, ts, nod, flow, cost;int a[N][N], id[N][N], id2[N][N], pre[Nd], dis[Nd], q[Nd];int tot = 2, hed[Nd], nxt[Ed], to[Ed], val[Ed], cst[Ed];bool b[N][N], inq[Nd];ll ans;inline void add_edge(int u, int v, int w, int c) { nxt[tot] = hed[u], to[tot] = v, val[tot] = w, cst[tot] = c, hed[u] = tot++; nxt[tot] = hed[v], to[tot] = u, val[tot] = 0, cst[tot] =-c, hed[v] = tot++;}bool spfa() { memset(pre, 0, sizeof(pre)); memset(dis, -63, sizeof(dis)); q[l = r = 0] = s, dis[s] = 0, inq[s] = 1; while (l &lt;= r) { u = q[(l++) % Nd], inq[u] = 0; for (int i = hed[u], v = to[i]; i; i = nxt[i], v = to[i]) if (val[i] &amp;&amp; dis[u] + cst[i] &gt; dis[v]) { dis[v] = dis[u] + cst[i], pre[v] = i; if (!inq[v]) inq[q[(++r) % Nd] = v] = 1; } } return pre[e];}void main() { read(n), read(m), read(k); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) read(a[i][j]), ans += a[i][j]; for (int i = 1, x, y; i &lt;= k; i++) read(x), read(y), b[x][y] = 1; s = ++nod, e = ++nod, ts = ++nod; add_edge(s, ts, m, 0); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) id[i][j] = ++nod, id2[i][j] = ++nod; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) { static const int nxt[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; if (b[i][j]) continue; if ((i + j) &amp; 1) { add_edge(id[i][j], id2[i][j], 1, a[i][j]); for (int t = 0, x, y; t &lt; 4; t++) { x = i + nxt[t][0], y = j + nxt[t][1]; if (b[x][y] || x &lt; 1 || y &lt; 1 || x &gt; n || y &gt; n) continue; if (x &amp; 1) add_edge(id2[x][y], id[i][j], 1, 0); else add_edge(id2[i][j], id[x][y], 1, 0); } } else { add_edge(id[i][j], id2[i][j], 1, 0); if (i &amp; 1) add_edge(ts, id[i][j], 1, 0); else add_edge(id2[i][j], e, 1, 0); } } while (spfa()) { flow = 1e9, cost = 0; for (int i = pre[e]; i; i = pre[to[i ^ 1]]) flow = std::min(flow, val[i]); for (int i = pre[e]; i; i = pre[to[i ^ 1]]) val[i] -= flow, val[i ^ 1] += flow; for (int i = pre[e]; i; i = pre[to[i ^ 1]]) cost += flow * cst[i]; if (cost &lt;= 0) break; ans -= cost; } print(ans, '\\n');}} signed main() { return ringo::main(), 0; }","link":"/bzoj5403/"},{"title":"CF1043F - Make It One","text":"考虑加入一个数如果不能使公因数减少，则可以不放。计算可得答案必定 $\\leq 7$。又发现不能直接对存在性进行容斥，容斥方案数即可。 （$cnt_i$ 表示以 $i$ 为因数的数的个数，$f_i$ 表示选 $ans$ 个数使得公因数为 $i$ 的方案数。） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// =================================// author: memset0// date: 2019.01.27 11:20:11// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;#define ll long longnamespace ringo {template &lt;class T&gt; inline void read(T &amp;x) { x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;}template &lt;class T&gt; inline void print(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);}template &lt;class T&gt; inline void print(T x, char c) { print(x), putchar(c); }const int N = 3e5 + 10, mod = 998244353;int n, a[N], cnt[N], f[N], inv[N], fac[N];inline void decd(int &amp;a, int b) { a -= b; if (a &lt; 0) a += mod; }inline void sumd(int &amp;a, int b) { a += b; if (a &gt;= mod) a -= mod; }inline int C(int n, int m) { return n &lt; m ? 0 : (ll)fac[n] * inv[m] % mod * inv[n - m] % mod; }void main() { read(n), fac[0] = fac[1] = inv[0] = inv[1] = 1; for (int i = 1; i &lt;= n; i++) read(a[i]), ++cnt[a[i]]; for (int i = 2; i &lt; N; i++) fac[i] = (ll)fac[i - 1] * i % mod; for (int i = 2; i &lt; N; i++) inv[i] = (ll)(mod - mod / i) * inv[mod % i] % mod; for (int i = 2; i &lt; N; i++) inv[i] = (ll)inv[i - 1] * inv[i] % mod; for (int i = 1; i &lt; N; i++) for (int j = i &lt;&lt; 1; j &lt; N; j += i) sumd(cnt[i], cnt[j]); for (int ans = 1; ans &lt;= 7; ans++) { for (int i = N - 1; i &gt;= 1; i--) { f[i] = C(cnt[i], ans); for (int j = i &lt;&lt; 1; j &lt; N; j += i) decd(f[i], f[j]); } if (f[1]) return print(ans, '\\n'); } puts(\"-1\");}} signed main() { return ringo::main(), 0; }","link":"/cf1043f/"},{"title":"CF1100F - Ivan and Burgers","text":"一道线性基傻逼题。然而我一开始智商掉线连写了两个假算法。 首先这题三只 $\\log$ 肯定是过不去的，除非你是 wys；然后也不能用多个线性基来更新一个答案。 上面都是废话，直接整体二分就过了。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// =================================// author: memset0// date: 2019.02.06 18:12:38// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;#define ll long longnamespace ringo {template &lt;class T&gt; inline void read(T &amp;x) { x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;}template &lt;class T&gt; inline void print(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);}template &lt;class T&gt; inline void print(T x, char c) { print(x), putchar(c); }const int N = 5e5 + 10, L = 20;int n, m, a[N], ans[N];struct func { int f[L]; inline void insert(int x) { for (int i = L - 1; ~i; i--) if ((x &gt;&gt; i) &amp; 1) { if (f[i]) x ^= f[i]; else { f[i] = x; return; } } } inline int query() { int ans = 0; for (int i = L - 1; ~i; i--) if (!((ans &gt;&gt; i) &amp; 1)) ans ^= f[i]; return ans; } inline func() {} inline func(int x) { memset(f, 0, sizeof(f)); insert(x); } friend inline func merge(const func &amp;a, const func &amp;b) { static func x; x = a; for (int i = 0; i &lt; L; i++) x.insert(b.f[i]); return x; }} pre[N];struct query { int l, r, id;};std::vector &lt;query&gt; q;void solve(int l, int r, std::vector &lt;query&gt; vet) { if (l &gt; r) return; int mid = (l + r) &gt;&gt; 1; std::vector &lt;query&gt; vet_l, vet_r; pre[mid] = func(a[mid]); for (int i = mid - 1; i &gt;= l; i--) pre[i] = pre[i + 1], pre[i].insert(a[i]); for (int i = mid + 1; i &lt;= r; i++) pre[i] = pre[i - 1], pre[i].insert(a[i]); for (auto it : vet) { if (it.r &lt; mid) vet_l.push_back(it); else if (it.l &gt; mid) vet_r.push_back(it); else ans[it.id] = merge(pre[it.l], pre[it.r]).query(); } solve(l, mid - 1, vet_l), solve(mid + 1, r, vet_r);}void main() { read(n); for (int i = 1; i &lt;= n; i++) read(a[i]); read(m); for (int i = 1, l, r; i &lt;= m; i++) read(l), read(r), q.push_back({l, r, i}); solve(1, n, q); for (int i = 1; i &lt;= m; i++) print(ans[i], '\\n');}} signed main() { return ringo::main(), 0; }","link":"/cf1100f/"},{"title":"CF1059D - Nature Reserve","text":"该死的精度问题让我调了一个小时还没有调出来（事实说明我还是太菜了。） 大概意思就是说平面上给了你一些点然后你要构造一个与 x 轴相切的圆把这些圆都包裹进去。 考虑二分圆的半径，这样就知道了圆心的 y 坐标，根据点在圆内的充要条件——点到圆心的距离小于等于半径计算出圆心的 x 坐标的范围。如果存在两个范围不相交，说明无法构造出一个符合条件的圆心。 需要注意浮点数运算的精度问题，比如计算 x 坐标的范围时这么写： 1dis = r * r - (r - y) * (r - y); 就容易被卡，而： 1dis = 2 * r * y - y * y; 就不容易。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long long#define rep(i,l,r) for (int i = l; i &lt;= r; i++)#define getc(x) getchar(x)#define putc(x) putchar(x)template &lt;typename T&gt; inline void read(T &amp;x) { x = 0; register char ch; register bool fl = 0; while (ch = getc(), ch &lt; 48 || 57 &lt; ch) fl ^= ch == '-'; x = (ch &amp; 15); while (ch = getc(), 47 &lt; ch &amp;&amp; ch &lt; 58) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch &amp; 15); if (fl) x = -x;}template &lt;typename T&gt; inline void readc(T &amp;x) { while (x = getc(), !islower(x) &amp;&amp; !isupper(x));}template &lt;typename T&gt; inline void print(T x, char c = ' ') { static int buf[40]; if (x == 0) { putc('0'); putc(c); return; } if (x &lt; 0) putc('-'), x = -x; for (buf[0] = 0; x; x /= 10) buf[++buf[0]] = x % 10 + 48; while (buf[0]) putc((char) buf[buf[0]--]); putc(c);}const int maxn = 100010;const long double eps = 1e-7;int n, cnt = 1000;int x[maxn], y[maxn];bool flag1, flag2;long double l, r, mid, ans, tmp;long double dis, min_rx, max_lx;long double lx[maxn], rx[maxn];bool check(long double r) { for (int i = 1; i &lt;= n; i++) { tmp = (2 * r - y[i]) * y[i]; if (tmp &lt; 0) return false; dis = sqrt(tmp); lx[i] = x[i] - dis; rx[i] = x[i] + dis; } min_rx = rx[1]; for (int i = 2; i &lt;= n; i++) min_rx = std::min(min_rx, rx[i]); max_lx = lx[1]; for (int i = 2; i &lt;= n; i++) max_lx = std::max(max_lx, lx[i]); if (max_lx &gt; min_rx) return false; return true;}int main() { read(n); for (int i = 1; i &lt;= n; i++) { read(x[i]); read(y[i]); } for (int i = 1; i &lt;= n; i++) if (y[i] &lt; 0) flag1 = 1; else if (y[i] &gt; 0) flag2 = 1; if (flag1 &amp;&amp; flag2) { print(-1, '\\n'); return 0; } if (flag1) { for (int i = 1; i &lt;= n; i++) y[i] = -y[i]; } l = 0, r = 1000000000000001; while (r - l &gt;= eps &amp;&amp; --cnt) { mid = (l + r) * 0.5; if (check(mid)) { ans = mid; r = mid; } else { l = mid; } } std::cout &lt;&lt; std::fixed; std::cout &lt;&lt; std::setprecision(8) &lt;&lt; ans; std::cout &lt;&lt; std::endl; return 0;}","link":"/codeforces1059d/"},{"title":"CF1059E - Split the Tree","text":"一个永远只能在考完后调出 Codeforces 的题的菜鸡厚颜无耻得跑来写题解了。。。 本题要求把树分成的链必须是垂直路径，也就是说不能同时跨越一颗子树的两个根。也就是说每次选中的路径都是到根节点的一串。 所以我们可以通过树上倍增预处理出每个节点 $u$ 如果被选中那么最多可以向上形成长度为 $dp[u]$ 的链。接着跑一遍树上 DP 即可。 预处理时间复杂度 $O(n \\log n)$ ，树上 DP 时间复杂度 $O(n)$ 。 貌似因为 D 题比较难调试，做这题的人比较少？反正我这种菜鸡就算考场有时间写了估计也调不出来吧。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long long#define rep(i,l,r) for (int i = l; i &lt;= r; i++)#define getc(x) getchar(x)#define putc(x) putchar(x)template &lt;typename T&gt; inline void read(T &amp;x) { x = 0; register char ch; register bool fl = 0; while (ch = getc(), ch &lt; 48 || 57 &lt; ch) fl ^= ch == '-'; x = (ch &amp; 15); while (ch = getc(), 47 &lt; ch &amp;&amp; ch &lt; 58) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch &amp; 15); if (fl) x = -x;}template &lt;typename T&gt; inline void readc(T &amp;x) { while (x = getc(), !islower(x) &amp;&amp; !isupper(x));}template &lt;typename T&gt; inline void print(T x, char c = ' ') { static int buf[40]; if (x == 0) { putc('0'); putc(c); return; } if (x &lt; 0) putc('-'), x = -x; for (buf[0] = 0; x; x /= 10) buf[++buf[0]] = x % 10 + 48; while (buf[0]) putc((char) buf[buf[0]--]); putc(c);}const int maxn = 100010;int n, m, x, ans;int c[maxn], f[maxn][20], cnt[maxn], dp[maxn];ll s, a[maxn], g[maxn][20], sum[maxn];int tot = 2, hed[maxn], to[maxn &lt;&lt; 1], nxt[maxn &lt;&lt; 1];inline void add_edge(int u, int v) { nxt[tot] = hed[u], to[tot] = v, hed[u] = tot++; nxt[tot] = hed[v], to[tot] = u, hed[v] = tot++; }void dfs1(int u) { for (int i = hed[u], v = to[i]; i; i = nxt[i], v = to[i]) if (v ^ f[u][0]) { f[v][0] = u; g[v][0] = a[u]; dfs1(v); }}int dfs2(int u) { int max = 0; for (int i = hed[u], v = to[i]; i; i = nxt[i], v = to[i]) if (v ^ f[u][0]) { max = std::max(max, dfs2(v)); } if (!max) { ans++; max = dp[u]; } return max - 1;}int main() { read(n), read(m), read(s); for (int i = 1; i &lt;= n; i++) { read(a[i]); if (a[i] &gt; s) { puts(\"-1\"); return 0; } } for (int i = 2; i &lt;= n; i++) { read(x); add_edge(x, i); } dfs1(1); for (int i = 1; i &lt; 20; i++) for (int j = 1; j &lt;= n; j++) { f[j][i] = f[f[j][i - 1]][i - 1]; g[j][i] = g[f[j][i - 1]][i - 1] + g[j][i - 1]; } for (int k = 1, u = k; k &lt;= n; k++, u = k) { int stp = 1, sum = a[u]; for (int i = 19; i &gt;= 0; i--) if ((stp + (1 &lt;&lt; i)) &lt;= m &amp;&amp; (sum + g[u][i]) &lt;= s &amp;&amp; f[u][i]) { stp += 1 &lt;&lt; i; sum += g[u][i]; u = f[u][i]; } dp[k] = stp; } dfs2(1); print(ans, '\\n'); return 0;}","link":"/codeforces1059e/"},{"title":"CF1105E - Helping Hiasat","text":"可以发现，在两个 1 操作之间的人中最多满足一个。我们可以两两连边，这样问题就转换为最大独立集问题，按照套路此时我们作补图，将最大独立集转换为求补图最大团。 最大团的常用算法是 Bron Kerbosch ，我们甚至不需要很强的优化剪枝就可以过掉这题。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// =================================// author: memset0// date: 2019.01.26 13:36:04// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;#define ll long longnamespace ringo {template &lt;class T&gt; inline void read(T &amp;x) { x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;}template &lt;class T&gt; inline void print(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);}template &lt;class T&gt; inline void print(T x, char c) { print(x), putchar(c); }const int N = 45;int n, m, ans;bool G[N][N];char s[N];std::set &lt;int&gt; set;std::map &lt;std::string, int&gt; map;int id(std::string s) { static int cnt = 0; if (map.find(s) == map.end()) return map[s] = ++cnt; return map[s];}void dfs(std::vector &lt;int&gt; all, std::vector &lt;int&gt; some, std::vector &lt;int&gt; none) { if (!some.size()) { if (!none.size()) ans = std::max(ans, (int)all.size()); return; } int u = *some.begin(); for (auto v : some) if (!G[u][v]) { std::vector &lt;int&gt; all_t = all, some_t, none_t; all_t.push_back(v); for (auto t : some) if (G[v][t]) some_t.push_back(t); for (auto t : none) if (G[v][t]) none_t.push_back(t); dfs(all_t, some_t, none_t); none.push_back(v); }}void main() { read(m), read(n); for (int i = 1, op; i &lt;= m; i++) if (read(op), op == 1) { for (auto i : set) for (auto j : set) G[i][j] = 1; set.clear(); } else { scanf(\"%s\", s); set.insert(id((std::string)s)); } for (auto i : set) for (auto j : set) G[i][j] = 1; set.clear(); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) G[i][j] ^= 1; for (int i = 1; i &lt;= n; i++) G[i][i] = 0; std::vector &lt;int&gt; all, some, none; for (int i = 1; i &lt;= n; i++) some.push_back(i); dfs(all, some, none), print(ans, '\\n');}} signed main() { return ringo::main(), 0; }","link":"/cf1105e/"},{"title":"CF706E - Working routine","text":"题意： 给你个 $1000 \\times 1000$ 的矩阵，每次交换任意两个不重合的子矩阵，求最后的结果 如果你是一位数据结构学傻的选手（像我），那么第一感觉肯定是用平衡树做，复杂度 $O(m \\times n \\log n)$ ，不过不幸的是，由于常数巨大，最后得分甚至可能不如暴力的 memcpy 。 如果你是一个不会高级数据结构的普及选手你说不定就能想到链表。维护一个矩形的链表，然后每次交换就分别把两块矩阵取出再拼接上去。 彩蛋——在摸你赛中的题面： 之所以续走的那些香港记者，是因为他们掌握了长者钦点董先生的关键证据，现在这份证据落到了你的手里。这份文件是一个 $n \\times m$ 的矩形，矩形内每一个元素是一个字符串。这份文件经过了 $q$ 次加密，每次加密是交换两个长宽分别相等的矩形，由于长者有点老花眼，所以他加密的时候两个矩形间任意一对元素曼哈顿距离大于 $1$。由于好奇，你开始解密这份文件，方便起见，加密操作已经倒序给你，你只要按顺序操作一遍便能解密。当你破解完这个文件，你会发现你的生命少了做这道题的时间。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longint read() { int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;}const int maxn = 1010, maxm = 1000010;int n, m, q, ax, ay, bx, by, l, c, lst, tmp;int al[maxn][maxn], ar[maxn][maxn];char s[10000010];void reads(int &amp;l, int &amp;r) { char c = getchar(); while (c == ' ' || c == '\\n') c = getchar(); l = ++lst, r = l - 1; while (c != ' ' &amp;&amp; c != '\\n') { s[++r] = c; c = getchar(); } lst = r;}void prints(int l, int r) { for (int i = l; i &lt;= r; i++) putchar(s[i]);}struct node { int x, y; node () {} node (int a, int b) { x = a, y = b; }};node au, bu, as, bs;node ex[maxn][maxn], ey[maxn][maxn];struct pair { node a, b; pair () {} pair (node x, node y) { a = x, b = y; }};std::vector &lt; pair &gt; todo_ex, todo_ey;node lead_to(int x, int y) { node u = node(0, 0); while (x--) u = ex[u.x][u.y]; while (y--) u = ey[u.x][u.y]; return u;}void print() { node u(0, 0); for (int i = 1; i &lt;= n; i++) { node v = u = ex[u.x][u.y]; for (int j = 1; j &lt;= m; j++) { v = ey[v.x][v.y]; prints(al[v.x][v.y], ar[v.x][v.y]); putchar(' '); } putchar('\\n'); }}void swap_ex(node a, node b) { todo_ex.push_back(pair(a, b));}void swap_ey(node a, node b) { todo_ey.push_back(pair(a, b));}int main() { n = read(), m = read(), q = read(); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) { reads(al[i][j], ar[i][j]); } for (int i = 0; i &lt;= n; i++) for (int j = 0; j &lt;= m; j++) { ex[i][j] = node(i + 1, j); ey[i][j] = node(i, j + 1); } for (int t = 1; t &lt;= q; t++) { ax = read(), ay = read(); bx = read(), by = read(); l = read(), c = read(); as = lead_to(ax - 1, ay - 1); bs = lead_to(bx - 1, by - 1); au = as, bu = bs; for (int i = 1; i &lt;= l; i++) { au = ex[au.x][au.y]; bu = ex[bu.x][bu.y]; swap_ey(au, bu); } au = as, bu = bs; for (int i = 1; i &lt;= c; i++) { au = ey[au.x][au.y]; bu = ey[bu.x][bu.y]; swap_ex(au, bu); } au = as, bu = bs; for (int i = 1; i &lt;= l; i++) { au = ex[au.x][au.y]; bu = ex[bu.x][bu.y]; } for (int i = 1; i &lt;= c; i++) { au = ey[au.x][au.y]; bu = ey[bu.x][bu.y]; swap_ex(au, bu); } au = as, bu = bs; for (int i = 1; i &lt;= c; i++) { au = ey[au.x][au.y]; bu = ey[bu.x][bu.y]; } for (int i = 1; i &lt;= l; i++) { au = ex[au.x][au.y]; bu = ex[bu.x][bu.y]; swap_ey(au, bu); } for (std::vector &lt; pair &gt; ::iterator it = todo_ex.begin(); it != todo_ex.end(); it++) std::swap(ex[it-&gt;a.x][it-&gt;a.y], ex[it-&gt;b.x][it-&gt;b.y]); for (std::vector &lt; pair &gt; ::iterator it = todo_ey.begin(); it != todo_ey.end(); it++) std::swap(ey[it-&gt;a.x][it-&gt;a.y], ey[it-&gt;b.x][it-&gt;b.y]); todo_ex.clear(); todo_ey.clear(); } print(); return 0;}","link":"/codeforces706e/"},{"title":"CF702E - Analysis of Pathes in Functional Graph","text":"倍增，处理出每个点往后 $2^i$ 的点、和、最大值，然后倍增乱搞即可。复杂度 $O(n log k)$ ，可过。 需要注意的是 $k$ 是 $10^{10}$ ，需要开 long long。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;int read() { int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;}ll readll() { ll x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;}const int maxn = 100010;const ll inf = 3e18;int n, u;ll k, stp, ans1, ans2;ll mi2[40], f[maxn][35], f1[maxn][35], f2[maxn][35];int main() { n = read(), k = readll(); for (int i = 1; i &lt;= n; i++) f[i][0] = (read() + 1); for (int i = 1; i &lt;= n; i++) f1[i][0] = f2[i][0] = read(); mi2[0] = 1; for (int i = 1; i &lt; 35; i++) mi2[i] = mi2[i - 1] &lt;&lt; 1; for (int i = 1; i &lt; 35; i++) for (int j = 1; j &lt;= n; j++) { f[j][i] = f[f[j][i - 1]][i - 1]; f1[j][i] = f1[f[j][i - 1]][i - 1] + f1[j][i - 1]; f2[j][i] = min(f2[f[j][i - 1]][i - 1], f2[j][i - 1]); } for (int now = 1; now &lt;= n; now++) { u = now, stp = k, ans1 = 0, ans2 = inf; for (int i = 34; i &gt;= 0; i--) if (stp - mi2[i] &gt;= 0) { stp -= mi2[i]; ans1 = ans1 + f1[u][i]; ans2 = min(ans2, f2[u][i]); u = f[u][i]; } printf(\"%lld %lld\\n\", ans1, ans2); } return 0;}","link":"/codeforces702e/"},{"title":"CF1096G - Lucky Tickets","text":"一道生成函数板题，定义生成函数 $f$：$$f(x) = \\sum\\limits_{i=0}^{\\infty} tag(i) \\times x^i$$ 若集合中有 $i$ 则，$tag(i) = 1$ ；否则 $tag(i) = 0$ 。 则 $[x^i]f^n(x)$ 表示选 $n$ 项时和为 $i$ 的方案数。 容易发现答案即： $$\\sum\\limits_{i=0}^{\\infty} ([x^i] f^n(x))^2$$ 多项式快速幂即可。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// =================================// author: memset0// date: 2019.01.13 11:37:52// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;#define ll long longnamespace ringo {template &lt;class T&gt; inline void read(T &amp;x) { x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;}template &lt;class T&gt; inline void print(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);}template &lt;class T&gt; inline void print(T x, char c) { print(x), putchar(c); }const int N = 2e6 + 10, mod = 998244353;int n, m, ans;int s[11], pre_g[2][30];inline void print(const std::vector &lt;int&gt; &amp;a) { for (auto i : a) print(i, ' '); putchar('\\n');}inline int fpow(int a, int b) { int s = 1; for (; b; b &gt;&gt;= 1, a = (ll)a * a % mod) if (b &amp; 1) s = (ll)s * a % mod; return s;}int inv(int x) { if (!x || x == 1) return 1; return (ll)(mod - mod / x) * inv(mod % x) % mod;}int f[N &lt;&lt; 2], g[N &lt;&lt; 2], rev[N &lt;&lt; 2];inline void ntt(int *a, int lim, int flag) { for (int i = 0; i &lt; lim; i++) if (i &lt; rev[i]) std::swap(a[i], a[rev[i]]); for (int len = 1, cnt = 1; len &lt; lim; len &lt;&lt;= 1, ++cnt) for (int i = 0, wn = pre_g[flag][cnt]; i &lt; lim; i += (len &lt;&lt; 1)) for (int j = 0, w = 1; j &lt; len; j++, w = (ll)w * wn % mod) { int x = a[i + j], y = (ll)w * a[i + j + len] % mod; a[i + j] = (x + y) % mod, a[i + j + len] = (x - y + mod) % mod; }}inline std::vector &lt;int&gt; operator * (const std::vector &lt;int&gt; &amp;a, const std::vector &lt;int&gt; &amp;b) { int len = 1, k = 0, a_size = a.size(), b_size = b.size(), c_size = a_size + b_size - 1; while (len &lt;= (a_size + b_size)) len &lt;&lt;= 1, ++k; // printf(\" \"), print(a), printf(\" * \"), print(b); for (int i = 0; i &lt; len; i++) { rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (k - 1)); f[i] = i &lt; a_size ? a[i] : 0; g[i] = i &lt; b_size ? b[i] : 0; } ntt(f, len, 0), ntt(g, len, 0); for (int i = 0; i &lt; len; i++) f[i] = (ll)f[i] * g[i] % mod; ntt(f, len, 1), len = inv(len); std::vector &lt;int&gt; c(c_size); for (int i = 0; i &lt; c_size; i++) c[i] = (ll)f[i] * len % mod; // printf(\" = \"), print(c); return c;}std::vector &lt;int&gt; fpow(std::vector &lt;int&gt; a, int b) { std::vector &lt;int&gt; s; s.push_back(1); for (; b; b &gt;&gt;= 1, a = a * a) if (b &amp; 1) s = s * a; return s;}void main() { for (int i = 0; i &lt; 30; i++) { pre_g[0][i] = fpow(3, (mod - 1) / (1 &lt;&lt; i)); pre_g[1][i] = fpow((998244353 + 1) / 3, (mod - 1) / (1 &lt;&lt; i)); } read(n), read(m); for (int i = 1; i &lt;= m; i++) read(s[i]); std::vector &lt;int&gt; f(10); for (int i = 1; i &lt;= m; i++) f[s[i]] = 1; f = fpow(f, n &gt;&gt; 1); for (size_t i = 0; i &lt; f.size(); i++) ans = (ans + (ll)f[i] * f[i]) % mod; print(ans, '\\n');}} signed main() { return ringo::main(), 0; }","link":"/codeforces1096g/"},{"title":"CF1093G - Multidimensional Queries","text":"这题需要用到一个惯用的套路。 $$a - b \\leq |a - b|$$ 显然如果是 $a - b$ 非负的，直接取等号；如果 $ a - b $ 负数，那么绝对值就是正数，负数一定小于正数。 考虑到 $ 2 ^ 5 ​$ 并不是很大，我们可以暴力枚举每个数的符号(用状态压缩的方式)。然后维护一棵线段树进行修改和查询即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// =================================// author: memset0// date: 2019.01.06 18:16:41// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;#define ll long longnamespace ringo {template &lt;class T&gt; inline void read(T &amp;x) { x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;}template &lt;class T&gt; inline void print(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);}template &lt;class T&gt; inline void print(T x, char c) { print(x), putchar(c); }const int N = 2e5 + 10, M = 5;int n, m, t, ans;struct node { int b[M];} u, a[N];struct status { int ans[1 &lt;&lt; M]; inline status () {} inline status (const node &amp;a) { memset(ans, 0, sizeof(ans)); for (int x = 0; x &lt; (1 &lt;&lt; m); x++) { for (int i = 0; i &lt; m; i++) ans[x] += (x &amp; (1 &lt;&lt; i) ? 1 : -1) * a.b[i]; } }} ret;inline status operator ^ (const status &amp;x, const status &amp;y) { status ans; for (int i = 0; i &lt; (1 &lt;&lt; m); i++) ans.ans[i] = std::max(x.ans[i], y.ans[i]); return ans;}struct seg_node { int l, r, mid; status x;} p[N &lt;&lt; 2];void build(int u, int l, int r) { p[u].l = l, p[u].r = r, p[u].mid = (l + r) &gt;&gt; 1; if (l == r) return (void)(p[u].x = status(a[l])); build(u &lt;&lt; 1, l, p[u].mid); build(u &lt;&lt; 1 | 1, p[u].mid + 1, r); p[u].x = p[u &lt;&lt; 1].x ^ p[u &lt;&lt; 1 | 1].x;}void modify(int u, int k, const node &amp;x) { if (p[u].l == p[u].r) return (void)(p[u].x = status(x)); if (k &lt;= p[u].mid) modify(u &lt;&lt; 1, k, x); else modify(u &lt;&lt; 1 | 1, k, x); p[u].x = p[u &lt;&lt; 1].x ^ p[u &lt;&lt; 1 | 1].x;}status query(int u, int l, int r) { if (p[u].l == l &amp;&amp; p[u].r == r) return p[u].x; if (r &lt;= p[u].mid) return query(u &lt;&lt; 1, l, r); if (l &gt; p[u].mid) return query(u &lt;&lt; 1 | 1, l, r); return query(u &lt;&lt; 1, l, p[u].mid) ^ query(u &lt;&lt; 1 | 1, p[u].mid + 1, r);}void main() { read(n), read(m); for (int i = 1; i &lt;= n; i++) for (int j = 0; j &lt; m; j++) read(a[i].b[j]); build(1, 1, n), read(t); for (int i = 1, k, l, r, op; i &lt;= t; i++) if (read(op), op == 1) { read(k); for (int i = 0; i &lt; m; i++) read(u.b[i]); modify(1, k, u); } else { read(l), read(r), ans = 0; ret = query(1, l, r); for (int x = 0; x &lt; (1 &lt;&lt; m); x++) ans = std::max(ans, ret.ans[x] + ret.ans[((1 &lt;&lt; m) - 1) ^ x]); print(ans, '\\n'); }}} signed main() { return ringo::main(), 0; }","link":"/codeforces1093g/"},{"title":"CF776D - The Door Problem","text":"由于每个门只会被两个钥匙控制，那么两个钥匙的选或不选就能建立起一种对应关系。即如果门本来是开着的，那么用了一把必须用另一把，不用一把必须不用另一把；如果们本来是开着的，那么不用一把必须用另一把，用了一把必须不用另一把。 Tarjan 跑 2-SAT 随手切，注意 $n$ 和 $m$ 不要搞反。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long long#define rep(i,l,r) for (int i = l; i &lt;= r; i++)#define getc(x) getchar(x)#define putc(x) putchar(x)template &lt;typename T&gt; inline void read(T &amp;x) { x = 0; register char ch; register bool fl = 0; while (ch = getc(), ch &lt; 48 || 57 &lt; ch) fl ^= ch == '-'; x = (ch &amp; 15); while (ch = getc(), 47 &lt; ch &amp;&amp; ch &lt; 58) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch &amp; 15); if (fl) x = -x;}template &lt;typename T&gt; inline void print(T x, char c = '\\n') { static int buf[40]; if (x == 0) { putc('0'); putc(c); return; } if (x &lt; 0) putc('-'), x = -x; for (buf[0] = 0; x; x /= 10) buf[++buf[0]] = x % 10 + 48; while (buf[0]) putc((char) buf[buf[0]--]); putc(c);}const int maxn = 200010, maxm = 400010;int n, m, t, x, cnt, pos, top;int a[maxn], b[maxn][2], low[maxn], dfn[maxn], stk[maxn], ins[maxn], col[maxn];int tot = 2, hed[maxn], nxt[maxm], to[maxm];inline void add_edge(int u, int v) { nxt[tot] = hed[u], to[tot] = v; hed[u] = tot++;}void tarjan(int u) { dfn[u] = low[u] = ++pos; ins[u] = 1, stk[++top] = u; for (int i = hed[u]; i; i = nxt[i]) { int v = to[i]; if (!dfn[v]) { tarjan(v); low[u] = std::min(low[u], low[v]); } else if (ins[v]) { low[u] = std::min(low[u], dfn[v]); } } if (dfn[u] == low[u]) { ++cnt; while (top) { int v = stk[top--]; col[v] = cnt; ins[v] = 0; if (u == v) break; } }}int main() { read(n), read(m); for (int i = 1; i &lt;= n; i++) read(a[i]); for (int i = 1; i &lt;= m; i++) { read(t); for (int j = 1; j &lt;= t; j++) { read(x); b[x][b[x][0] ? 1 : 0] = i; } } for (int i = 1; i &lt;= n; i++) if (a[i]) { add_edge(b[i][0], b[i][1]); add_edge(b[i][1], b[i][0]); add_edge(b[i][0] + m, b[i][1] + m); add_edge(b[i][1] + m, b[i][0] + m); } else { add_edge(b[i][0], b[i][1] + m); add_edge(b[i][1] + m, b[i][0]); add_edge(b[i][1], b[i][0] + m); add_edge(b[i][0] + m, b[i][1]); } for (int i = 1; i &lt;= (m &lt;&lt; 1); i++) if (!dfn[i]) tarjan(i); for (int i = 1; i &lt;= (m &lt;&lt; 1); i++) if (col[i] == col[i + m]) { puts(\"NO\"); return 0; } puts(\"YES\"); return 0;}","link":"/codeforces776d/"},{"title":"20181211 - NOI模拟赛","text":"T1、T3 的思路基本都成型但是由于自己傻逼最后一个都没调出来。 LCM考虑一个数最多被分解为一个大于 $\\sqrt {\\max a_i}$ 的质数和一些小于 $\\sqrt {\\max a_i} $ 的质数的乘积。考虑小于的部分，最多有 4320 种状态，我们可以用一种简单背包的方法统计出每一种值的个数。对于大于的部分，相当于我们给上一步统计的个数的时候给个数加上一个权值。通过一些简单的处理避免超过 $\\sqrt { \\max a_i }$ 的质数被重复计算。理论复杂度 $O(n \\times 4320 \\times (\\log n + \\log 4320))$ 。 Xor不知道为什么出题人要把题意搞的这么迷。我们直接把边权异或到两个端点上，计算割的价值就是一边的点的权值的异或和。考虑贪心，把点按照权值从大到小排序，利用线性基维护会不会产生 $0$ ，不会就加上价值，否则减掉即可。 Lis考虑把从左到右的最长上升子序列转变为从右到左的最长下降子序列，这样每次操作最多影响十棵树。树套树（树状数组套权值线段树）维护一个后缀高度大于指定值的 dp 值的最大值，每次暴力重算那十棵树即可。复杂度 $O(n \\log^2 n \\times 10)$ 。需要注意的是需要动态开的节点个数可能会很多，一定要开够。","link":"/contest-20181211/"},{"title":"动态 DP 学习笔记","text":"（好懒不想写博客） 把每个点的 dp 转移分成 重儿子 和 自己+轻儿子 两个部分。重儿子的转移把矩阵放树上维护，利用矩阵乘法的性质；轻儿子的转移的每次修改时暴力维护，利用 dp 的性质。详情参考 txc 哥哥的博客。 树剖代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155// =================================// author: memset0// date: 2018.12.18 09:15:21// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;#define int long long#define rep(i, l, r) for (register int i = l; i &lt;= r; i++)namespace ringo {typedef long long ll;typedef unsigned long long ull;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;}template &lt;class T&gt; inline void print(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);}template &lt;class T&gt; inline void maxd(T &amp;a, T b) { if (b &gt; a) a = b; }template &lt;class T&gt; inline void mind(T &amp;a, T b) { if (b &lt; a) a = b; }template &lt;class T&gt; inline void print(T x, char c) { print(x), putchar(c); }template &lt;class T&gt; inline T abs(const T &amp;a) { if (a &lt; 0) return -a; return a; }const int N = 1e5 + 10, inf = 1e18;int n, m, u, v, w, dta, pos;typedef int R[N]; R a, son, fa, top, id, wid, bot, siz, dep;int tot = 2, hed[N], nxt[N &lt;&lt; 1], to[N &lt;&lt; 1];struct matrix { int a[2][2]; inline int* operator[] (const size_t &amp;i) { return a[i]; } void operator ~ () { rep(i, 0, 1) rep(j, 0, 1) print(a[i][j], \" \\n\"[j == 1]); }} f[N], g[N];struct node { int l, r, mid; matrix x;} p[N &lt;&lt; 2];inline matrix operator * (const matrix &amp;a, const matrix &amp;b) { matrix c; memset(c.a, -0x3f, sizeof(c.a)); for (int i = 0; i &lt; 2; i++) for (int j = 0; j &lt; 2; j++) for (int k = 0; k &lt; 2; k++) maxd(c[i][j], a.a[i][k] + b.a[k][j]); return c;}void dfs1(int u) { siz[u] = 1; for (int i = hed[u], v = to[i]; i; i = nxt[i], v = to[i]) if (v != fa[u]) { fa[v] = u, dep[v] = dep[u] + 1, dfs1(v), siz[u] += siz[v]; if (siz[v] &gt; siz[son[u]]) son[u] = v; }}void dfs2(int u, int toppoint) { top[u] = toppoint, id[u] = ++pos, wid[id[u]] = u; if (siz[u] == 1) { bot[u] = u; return; } dfs2(son[u], toppoint), bot[u] = bot[son[u]]; for (int i = hed[u], v = to[i]; i; i = nxt[i], v = to[i]) if (v != fa[u] &amp;&amp; v != son[u]) dfs2(v, v);}void dfs3(int u) { f[u][0][0] = g[u][0][0] = 0, f[u][1][0] = g[u][1][0] = a[u]; for (int i = hed[u], v = to[i]; i; i = nxt[i], v = to[i]) if (v != fa[u]) { dfs3(v); f[u][0][0] += std::max(f[v][0][0], f[v][1][0]); f[u][1][0] += f[v][0][0]; if (v != son[u]) { g[u][0][0] += std::max(f[v][0][0], f[v][1][0]); g[u][1][0] += f[v][0][0]; } }}void build(int l = 1, int r = n, int u = 1) { p[u].l = l, p[u].r = r, p[u].mid = (l + r) &gt;&gt; 1; if (l == r) { p[u].x = g[wid[l]]; return; } build(l, p[u].mid, u &lt;&lt; 1); build(p[u].mid + 1, r, u &lt;&lt; 1 | 1); p[u].x = p[u &lt;&lt; 1].x * p[u &lt;&lt; 1 | 1].x;}void modify(int k, const matrix &amp;x, int u = 1) { if (p[u].l == p[u].r) { p[u].x = x; return; } if (k &lt;= p[u].mid) modify(k, x, u &lt;&lt; 1); else modify(k, x, u &lt;&lt; 1 | 1); p[u].x = p[u &lt;&lt; 1].x * p[u &lt;&lt; 1 | 1].x;}matrix query(int l, int r, int u = 1) { if (p[u].l == l &amp;&amp; p[u].r == r) return p[u].x; if (r &lt;= p[u].mid) return query(l, r, u &lt;&lt; 1); if (l &gt; p[u].mid) return query(l, r, u &lt;&lt; 1 | 1); return query(l, p[u].mid, u &lt;&lt; 1) * query(p[u].mid + 1, r, u &lt;&lt; 1 | 1);}void maintain(int u) { if (bot[u] == u) return; f[u] = query(id[u], id[fa[bot[u]]]) * f[bot[u]];} void update(int u, int dta) { if (u == top[u]) { g[fa[top[u]]][0][0] -= std::max(f[top[u]][1][0], f[top[u]][0][0]); g[fa[top[u]]][0][1] -= std::max(f[top[u]][1][0], f[top[u]][0][0]); } a[u] += dta, f[u][1][0] += dta, g[u][1][0] += dta, modify(id[u], g[u]); if (u == top[u]) { g[fa[top[u]]][0][0] += std::max(f[top[u]][1][0], f[top[u]][0][0]); g[fa[top[u]]][0][1] += std::max(f[top[u]][1][0], f[top[u]][0][0]); } while (u) { g[fa[top[u]]][0][0] -= std::max(f[top[u]][1][0], f[top[u]][0][0]); g[fa[top[u]]][0][1] -= std::max(f[top[u]][1][0], f[top[u]][0][0]); g[fa[top[u]]][1][0] -= f[top[u]][0][0]; maintain(top[u]); g[fa[top[u]]][0][0] += std::max(f[top[u]][1][0], f[top[u]][0][0]); g[fa[top[u]]][0][1] += std::max(f[top[u]][1][0], f[top[u]][0][0]); g[fa[top[u]]][1][0] += f[top[u]][0][0]; if (fa[top[u]]) modify(id[fa[top[u]]], g[fa[top[u]]]); u = fa[top[u]]; }}void main() { read(n), read(m); for (int i = 1; i &lt;= n; i++) read(a[i]); for (int i = 1; i &lt; n; i++) { read(u), read(v); nxt[tot] = hed[u], to[tot] = v, hed[u] = tot++; nxt[tot] = hed[v], to[tot] = u, hed[v] = tot++; } dfs1(1), dfs2(1, 1), dfs3(1); for (int i = 1; i &lt;= n; i++) g[i][0][1] = g[i][0][0], g[i][1][1] = -inf; build(); for (int i = 1; i &lt;= n; i++) if (i != bot[i]) maintain(i); for (int i = 1; i &lt;= m; i++) { read(u), read(w), dta = w - a[u], update(u, dta); print(std::max(f[1][0][0], f[1][1][0]), '\\n'); } for (int i = 1; i &lt;= n; i++) if (i != bot[i]) maintain(i);}} signed main() { return ringo::main(), 0; } 全局平衡二叉树代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136// =================================// author: memset0// date: 2018.12.19 09:56:29// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (register int i = l; i &lt;= r; i++)namespace ringo {typedef long long ll;typedef unsigned long long ull;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;}template &lt;class T&gt; inline void print(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);}template &lt;class T&gt; inline void maxd(T &amp;a, T b) { if (b &gt; a) a = b; }template &lt;class T&gt; inline void mind(T &amp;a, T b) { if (b &lt; a) a = b; }template &lt;class T&gt; inline void print(T x, char c) { print(x), putchar(c); }template &lt;class T&gt; inline T abs(const T &amp;a) { if (a &lt; 0) return -a; return a; }const int N = 1e5 + 10, inf = 1e9;int n, m, u, v, w, rt, top, dta, ch[N][2];typedef int R[N]; R a, stk, son, fa, siz, fat, dep;int tot = 2, hed[N], to[N &lt;&lt; 1], nxt[N &lt;&lt; 1];struct matrix { int a[2][2]; inline int* operator [] (const size_t i) { return a[i]; } void operator ~ () const { printf(\"[%d %d %d %d]\", a[0][0], a[0][1], a[1][0], a[1][1]); }} f[N], g[N], sum[N];inline matrix operator * (const matrix &amp;a, const matrix &amp;b) { return (matrix) {{{ std::max(a.a[0][0] + b.a[0][0], a.a[0][1] + b.a[1][0]), std::max(a.a[0][0] + b.a[0][1], a.a[0][1] + b.a[1][1])},{ std::max(a.a[1][0] + b.a[0][0], a.a[1][1] + b.a[1][0]), std::max(a.a[1][0] + b.a[0][1], a.a[1][1] + b.a[1][1]) }}};}void dfs(int u) { siz[u] = 1; for (int i = hed[u], v = to[i]; i; i = nxt[i], v = to[i]) if (v != fat[u]) { fat[v] = u, dep[v] = dep[u] + 1, dfs(v), siz[u] += siz[v]; if (siz[v] &gt; siz[son[u]]) son[u] = v; }}void dfs2(int u) { f[u][0][0] = g[u][0][0] = 0, f[u][1][0] = g[u][1][0] = a[u]; for (int i = hed[u], v = to[i]; i; i = nxt[i], v = to[i]) if (v != fat[u]) { dfs2(v); f[u][0][0] += std::max(f[v][0][0], f[v][1][0]); f[u][1][0] += f[v][0][0]; if (v != son[u]) { g[u][0][0] += std::max(f[v][0][0], f[v][1][0]); g[u][0][1] += std::max(f[v][0][0], f[v][1][0]); g[u][1][0] += f[v][0][0]; } }}bool is_root(int u) { return ch[fa[u]][0] != u &amp;&amp; ch[fa[u]][1] != u; }void update(int u) { f[u] = g[u]; if (ch[u][0]) f[u] = f[ch[u][0]] * f[u]; if (ch[u][1]) f[u] = f[u] * f[ch[u][1]];}int sbuild(int l, int r) { int sum = 0, now = 0; for (int i = l; i &lt;= r; i++) sum += siz[stk[i]] - siz[son[stk[i]]]; for (int i = l; i &lt;= r; i++) { now += siz[stk[i]] - siz[son[stk[i]]]; if ((now &lt;&lt; 1) &gt;= sum) { fa[ch[stk[i]][0] = sbuild(l, i - 1)] = stk[i]; fa[ch[stk[i]][1] = sbuild(i + 1, r)] = stk[i]; return update(stk[i]), stk[i]; } } return 0;}int build(int u) { for (int x = u; x; x = son[x]) for (int i = hed[x], v = to[i]; i; i = nxt[i], v = to[i]) if (v != fat[x] &amp;&amp; v != son[x]) fa[build(v)] = x; top = 0; for (int x = u; x; x = son[x]) stk[++top] = x; return sbuild(1, top);}void update(int u, int dta) { for (int x = u; x; x = fa[x]) if (is_root(x) &amp;&amp; fa[x]) { g[fa[x]][0][0] -= std::max(f[x][0][0], f[x][1][0]); g[fa[x]][0][1] -= std::max(f[x][0][0], f[x][1][0]); g[fa[x]][1][0] -= f[x][0][0]; if (u == x) g[x][1][0] += dta; update(x); g[fa[x]][0][0] += std::max(f[x][0][0], f[x][1][0]); g[fa[x]][0][1] += std::max(f[x][0][0], f[x][1][0]); g[fa[x]][1][0] += f[x][0][0]; } else { if (u == x) g[x][1][0] += dta; update(x); }}void main() { read(n), read(m); for (int i = 1; i &lt;= n; i++) read(a[i]); for (int i = 1; i &lt; n; i++) { read(u), read(v); nxt[tot] = hed[u], to[tot] = v, hed[u] = tot++; nxt[tot] = hed[v], to[tot] = u, hed[v] = tot++; } f[0] = {{{1, 0}, {0, 1}}}; for (int i = 1; i &lt;= n; i++) g[i][1][1] = -inf; dfs(1), dfs2(1), rt = build(1); for (int i = 1; i &lt;= m; i++) { read(u), read(w), dta = w - a[u], a[u] = w; update(u, dta), print(std::max(f[rt][0][0], f[rt][1][0]), '\\n'); }}} signed main() { return ringo::main(), 0; }","link":"/ddp/"},{"title":"20181208 - NOI模拟赛","text":"最近准备学科营，平时考的模拟赛准备总结记录一下。这些题解会被分类到 Contest 目录下，可能只会讲笔者会的部分或笔者觉得有用的部分，思路可能会讲完整也可能不会，代码可能会放也可能不会，但题面和题意肯定是不会有的。大概就是这样（ Forest考虑到每个节点出去只有一个父亲，所以要把修改都集中到自己和自己的父亲上去（而不是遍历自己的孩子）。为了方便维护，我们把原来的 $C_i$ 拆成 $$C_i = E_{a_i} + (B_i - D_i \\times E_i + E_i + \\sum E_{ P_j } [ j 是 i 的孩子])$$ 通过简单的 trick 把括号内的东西（假设叫 $F_i$ ）放到 $i$ 节点上维护，可以使得 1 、 2 操作的复杂度变为 $O(1)$ ，但 3 操作需要遍历所有节点，复杂度是 $O(n)$ 。考虑优化，把每个节点都开个 multiset （或可删堆），用来存自己的每个孩子的 $F_i$ ，当自己的 $E_i$ 改变时利用自己的 multiset 去更新答案，同时当自己的 $F_i$ 改变时更新父亲的 multiset ，并利用父亲的 multiset 更新答案 Bear20 分简单爆枚，40 分简单状压。100 分以对角线进行插头 dp ，还没写过。 Juice考场上用一个乱搞做法 AC 了这题（也依赖于 IOI 赛制）。先枚举答案，对于每个答案进行 check ，方法如下。 先根据答案计算出分出的每个桶的大小 $S$，把给定的每个 $a_i$ 丢进 multiset 里。每次取出一个最小的 $A$，如果 $A &gt; S$ ，那么就把 $A - S$ 丢回去；如果 $A &lt; S$ ，那么就在 set.lower_bound(A) 到 –set.end() 的范围内随机一个迭代器配对。利用合适的随机种子和合适的调参，成功 Accepted。","link":"/contest-20181208/"},{"title":"2018浙大校赛&图森未来杯(4.7) 游记","text":"这其实是一个比赛啊啊啊啊啊！ 反正考得超级辣鸡的！ 这是我第一次参加ACM类的比赛，估计也是我的第一次写游记吧。这次参加浙大校赛的，不光有他们大学生，还有各路中学生；同时，我也在队伍里面发现了小学生的踪影（就差幼儿园的了）。整体的氛围还是比较愉快的，可能是因为三个人一起做题的关系吧，没有OI那么压抑。 这次比赛给了我们一点经验，也让我们看到了很多不足的地方（同时我现场领悟了如何数组模拟链表，thanks to fjk） update 2018.4.10 然后当时我们F题一直没有打出来，直到今天我才发现这不就是一道简单的DP+贪心吗。 那么我们开始吧 上午等待我们到的很早，当时门口几乎没有什么人。还好，我及时地找到了我的队友并一起坐在fjk的车里打pvz2.话说外面还真冷啊！ 开幕式开幕式就是领导讲话+吹牛逼，有些同学在玩游戏，但是我还是认真听的。据称每一年的校赛都有个传统——开幕式时会给一点提示。这次老师告诉我们说： 这次换了个新人出题，新手上路嘛，难度可能掌握的不太好。于是呢我就让他给我看了一下：题目不难，但是也没有很简单的题。最好的方法是一个人从头往后看，一个人从后往前看，还有一个人从中间看。 事实证明这话非常有用，嗯对，你马上就知道了。。。 上机练习只听到广播里一直响着不要碰电脑，于是我们就半个多小时没有碰电脑——直到看到绝大部分人都开始打上午的这套练习题为止。A题C题好水啊，B题貌似就是一个有两个条件的SPFA（雾）？D题是什么鬼，来考高中数理化啊。貌似因为早上的只是试机，好多人都提前走了，也没看到有人去做B题。话说找提交代码的地方用了十多分钟，不过还好上午就发现了。 中午吃中饭浙大的校园就是大，食堂也大，比我们学校的食堂不知道高端到哪里去。 买文具吃完中饭我们去旁边的超市逛逛。 其实本来只是fjk和yyf想买瓶水的，结果我带头买了一堆印着浙大校徽的笔记本（坑钱）我还买了两只笔。。。 下午终于要开始比赛了233 开考前我们提早一刻钟到了，试卷摆在桌子上，然后我问监考老师：我：试卷可以看吗监考老师：我也不知道诶，我帮你去问一下……监考老师：他们说不可以的，现在不可以拆试卷我：可是这信封本来就是打开的监考老师：那是他们包装的不专业（一脸无奈） 开考貌似提前了三分钟？后来才知道是钟不准 做题 瞎搞J - PPAP我们按照早上说的那样，分开来看题。很开，fjk就发现最后一题很简单。然后我们就把他切了。 A - Pretty Matrix接着我们看别的题目去了，当时不知道是谁说了一声第一题好难啊，然后我们就都没有去看第一题。直到…我们把每道题都看完了以后刷新下rank榜才发现第一题那么水。 于是认真地看了看，A掉了 G - Traffic Light当时fjk想出了这道题的这道题的优化方法：某些点一定是走奇数才能到的，某些点一定是走偶数步才能到的。于是我们就可以把原来动态的图变成静态的，我们也决定先打这一题。 然而，明明想到正解的我们却去打了个DFS打DFS也就算了，还是个WA的DFS。后来好不容易对拍出来又是TLE，然后写了个记忆化的DFS还是TLE。最后fjk一发BFS就A了。 考后，他们说不用那样优化也能A。心里那叫一个凄凉。 C - Mergeable Stack在G题不断WA/TLE的同时，我们也开始做C题。 我第一眼以为是数据结构题，觉着以我们这种垃圾的水平应该是做不出来的于是很快就放弃了。后来fjk一看说这不就是道模拟题吗，数组模拟链表就好了。我一看，还真是，于是就愉快地打了个代码，WA了。 后来才发现，有那么个很小的情况转移时没有将被移走的栈删除，然后就呵呵了。其实也没有那么难。 F - Schrödinger’s Knapsack一道神奇的背包题，我们最后一个小时都押宝在这道题上了。一开始我们想了个贪心，O(n log n)的，总是WA。 后来想了想这题数据给的很明显就是让我们用O(n ^ 2)啊，然而我却以为是n方的贪心。 最后一刻钟yyf才想出来DP，十分钟敲完却样例都过不去。于是只能遗憾收场。 事后证明因为当时考虑不周全没仔细看题，当时多写了个- 1。回来一测，去掉就A了。而且跑的还贼快，要知道我们隔壁队都是卡时限才过了的。 总结这次的成绩不怎么理想，至少F题本来应该打出来，其他题不应该错那么多次。不然排名进前30应该是没有问题的。主要还是我的原因吧，全场脑子比较混乱，根本没有能力把我们队管理好，然而还是逞强想去当队长。 英文题面也导致我们对题目难度的评估失误：他们认为很简单思考了很久的B题和E题结果是最难的两个题（浪费了他们两个近两个小时的时间吧） 也只能说：下次加油吧","link":"/diary-2018浙大校赛游记/"},{"title":"20181210 - NOI模拟赛","text":"T3 难度并不大，但是由于时间分配问题 + 出题人数据有锅必须输出行末空格否则 WA 导致本来会做的 T3 没有 AC 。 迷路对于每一个点，建出最短路树，对于每一条非树边，如果他的两个节点在根节点的不同子树内，那么可以对答案产生贡献。 宝藏类欧优化的数学题，不会。 蛋糕THUPC 原题的强化版，由 $4$ 维变成 $n$ 维。每一维变成一个多项式分治 NTT 即可。","link":"/contest-20181210/"},{"title":"100 篇文章纪念","text":"memset0 的博文终于有 100 篇啦，要继续坚持下去哦… （然后又偷偷从老博客里搬了几篇回来…）","link":"/diary-100-posts/"},{"title":"2018 感谢有你","text":"2018，感谢有你。 第一次写总结。由于 memset0 的语文一直处于垫底水平 + 停课半年没写过东西，请原谅一下我糟糕的表述，谢谢 qwq. 文化课1 ~ 6 月在搞文化课。文化课的日子也不是很累吧，每天能和同学聊天什么的，作业做完也可以干一些自己喜欢的事情（比如整理整理笔记、纠错什么的）。 每天都能看到她，晚自习能跟她讨论题目的真的超级开心 qwq… 信奥7 ~ 12 月滚去搞信奥。几乎每天一次模拟赛充分享受了垫底的日子。至今仍记得当初连个树上求 LCA 的暴力都不会写，到慢慢学了倍增，到学了树剖 &amp; LCT ，到学了仙人掌、动态 DP 啥的 qwq 。可以说是在 hy（Isonan）、mwh（memset1 / _QAQ）、sk（Sooke）、wxw（LJC00118）的一步步碾压中逐渐成长吧。 集训的时候也看到某些“神仙”利用各种“奇技淫巧” AK ，曾也学过那么一次。后来在学长的指导下也醒悟了这样做真的没什么意思（看到了 supy 叶老师曾经的博文 + xxx学长：我们去年也是这样的）。现在回头看，当初抄袭最多的人，要么初赛没过，要么一等都没，也算是因果报应吧。 关于刷题一般做题都上洛谷、Libre OJ、BZOJ 什么的 qwq 。校内 OJ 一般用来订正题目。有一段时间和同学每天晚上跑到 FLOJ 看首页的视频。。。 洛谷的刷题量也从 100 到了 800+ ，BZOJ 也从没有到了 200+ 。虽然和正在看这篇文章的您来说没法比，但也是对我努力刷题半年的一个反馈了 qwq。 关于工程从去年（2017）年底开始就搞过博客，今年上半年尝试在买了个服务器，但最终还是换回了 Hexo 。期间也魔改了很多主题略微了解了一点 CSS qwq。 还花了写时间自学了 Python ，写过一个洛谷通过题目的难度爬虫，还有一个洛谷冬日画板的脚本。虽然都是很简单的东西，但还是收获了（对我来说）很多的 Star ，也认识了很多的朋友，学了很多新的东西。谢谢你们 qwq！ 关于（线下）朋友现在和 Isonan 关系最好，其他不方便透露 qwq。 其实心底一直有一个喜欢的人（逃），只不过现在信奥集训见不到她了（哭）. 有些半夜刷题的时候也难免想起她 qwq。 新年目标能和她一起考进杭二。 PKUWC 2019 争取签掉 qwq（争取不翻车）。 NOIP 2019 争取能考到 WC 2020 的分数线。 立 Flag 再不颓废 qwq… 感谢感谢我的家长和老师。 感谢她对我的支持与鼓励。 感谢同机房同学的陪伴（@Sooke @LJC00118 @Isnoan @xay @_QAQ @Dilute @假装老船长 @Shallowy 等等） 感谢网上认识的大佬的指导 &amp; 陪伴（@Menci @小可爱三岁七 @OwenOwl @ranwen @GNAQ @Himself65 @Anguei 等等） p.s. 洛谷画板上 @OwenOwl 的操作实在太秀了，无尽膜拜…","link":"/diary-2018感谢有你/"},{"title":"BZOJ5017 - [SNOI2017] 炸弹","text":"zhouyuheng2003 学长一天打完 CF 后给我做的一道他说是简单题的题，然而炒鸡难！！！ 考虑暴力，每个炸弹向能引爆炸弹的连边，总数是 $n^2$ 级别的。之后跑 tarjan 缩点，并在 DAG 上统计答案。统计是，考虑合并来的点所对应的情况可能会有重点，因此需要开桶去重。这样的时空复杂度都是 $O(n^2)$ 的。 考虑优化，通过观察可以发现，能引爆的炸弹一定是连续的一整段区间。可以用线段树优化建边，统计答案时不需要开桶统计，而是统计能够炸掉的最左端的点和最右端的点。时间复杂度 $O(n \\log n)$ ，空间复杂度 $O(n \\log n)$。 同时 当然这并不是最优的，zhouyuheng2003 学长的博客中给出了一种时空复杂度均为 $O(n)$ 的做法。见 https://blog.csdn.net/zhouyuheng2003/article/details/83278984 。 代码莫名 RE 调了好久，因此码风有点丑不要介意。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long long#define rep(i,l,r) for (int i = l; i &lt;= r; i++)#define getc(x) getchar(x)#define putc(x) putchar(x)template &lt;typename T&gt; inline void read(T &amp;x) { x = 0; register char ch; register bool fl = 0; while (ch = getc(), ch &lt; 48 || 57 &lt; ch) fl ^= ch == '-'; x = (ch &amp; 15); while (ch = getc(), 47 &lt; ch &amp;&amp; ch &lt; 58) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch &amp; 15); if (fl) x = -x;}template &lt;typename T&gt; inline void readc(T &amp;x) { while (x = getc(), !islower(x) &amp;&amp; !isupper(x));}template &lt;typename T&gt; inline void print(T x, char c = ' ') { static int buf[40]; if (x == 0) { putc('0'); putc(c); return; } if (x &lt; 0) putc('-'), x = -x; for (buf[0] = 0; x; x /= 10) buf[++buf[0]] = x % 10 + 48; while (buf[0]) putc((char) buf[buf[0]--]); putc(c);}#define int long longconst int maxn = 500010;int n, m, u, v, w, x, l, r, tn, ans, cnt, pos;ll b[maxn * 3]; int q[maxn];int col[maxn], ind[maxn], ls[maxn], rs[maxn];int top, dfn[maxn], low[maxn], stk[maxn], ins[maxn];int tot = 2, hed[maxn], nxt[maxn &lt;&lt; 1], to[maxn &lt;&lt; 1];struct node { ll x, l, r;} a[maxn];inline bool operator &lt; (const node &amp;a, const node &amp;b) { return a.x &lt; b.x;}struct edge { int u, v;};std::vector &lt; edge &gt; e;void add_edge1(int u, int v) { nxt[tot] = hed[u], to[tot] = v, hed[u] = tot++; e.push_back(edge{u, v});}void add_edge2(int u, int v) { nxt[tot] = hed[u], to[tot] = v, hed[u] = tot++; ind[v]++;}void tarjan(int u) { dfn[u] = low[u] = ++pos; stk[++top] = u, ins[u] = 1; for (int i = hed[u], v = to[i]; i; i = nxt[i], v = to[i]) { if (!dfn[v]) { tarjan(v); low[u] = std::min(low[u], low[v]); } else if (ins[v]) { low[u] = std::min(low[u], dfn[v]); } } if (dfn[u] == low[u]) { ++cnt; ls[cnt] = n + 1; while (top) { int v = stk[top--]; col[v] = cnt; ins[v] = 0; ls[cnt] = std::min(ls[cnt], (int)a[v].l); rs[cnt] = std::max(rs[cnt], (int)a[v].r); if (u == v) break; } }}signed main() { read(n); for (int i = 1; i &lt;= n; i++) { read(x), read(r); a[i].x = x, a[i].r = r; b[++tn] = x; } std::sort(a + 1, a + n + 1); std::sort(b + 1, b + tn + 1); tn = std::unique(b + 1, b + tn + 1) - b - 1; for (int i = 1; i &lt;= n; i++) { a[i].l = std::lower_bound(b + 1, b + tn + 1, a[i].x - a[i].r) - b; a[i].r = std::upper_bound(b + 1, b + tn + 1, a[i].x + a[i].r) - b - 1; a[i].x = std::lower_bound(b + 1, b + tn + 1, a[i].x) - b; } for (int i = 1; i &lt;= n; i++) { while (top &amp;&amp; a[stk[top]].r &lt; a[i].x) top--; if (top &amp;&amp; a[stk[top]].r &gt;= a[i].x) add_edge1(stk[top], i); while (top &amp;&amp; a[stk[top]].r &lt;= a[i].r) top--; stk[++top] = i; } top = 0; for (int i = n; i &gt;= 1; i--) { while (top &amp;&amp; a[stk[top]].l &gt; a[i].x) top--; if (top &amp;&amp; a[stk[top]].l &lt;= a[i].x) add_edge1(stk[top], i); while (top &amp;&amp; a[stk[top]].l &gt;= a[i].l) top--; stk[++top] = i; } for (int i = 1; i &lt;= n; i++) if (!dfn[i]) tarjan(i); tot = 2, memset(hed, 0, sizeof(hed)); for (std::vector &lt; edge &gt; ::iterator it = e.begin(); it != e.end(); it++) { u = it-&gt;v, v = it-&gt;u, u = col[u], v = col[v]; if (u ^ v) { add_edge2(u, v); } } l = 1, r = 0; for (int i = 1; i &lt;= n; i++) if (!ind[i]) { q[++r] = i; } while (l &lt;= r) { u = q[l++]; for (int i = hed[u], v = to[i]; i; i = nxt[i], v = to[i]) { ls[v] = std::min(ls[u], ls[v]); rs[v] = std::max(rs[u], rs[v]); if (!--ind[v]) q[++r] = v; } } for (int i = 1; i &lt;= n; i++) ans = (ans + 1ll * i * (rs[col[i]] - ls[col[i]] + 1)) % 1000000007; print(ans, '\\n'); return 0;}","link":"/bzoj5017/"},{"title":"二项式反演学习笔记","text":"二项式反演： $$\\begin{aligned}f_n=\\sum_{i=0}^{n}(-1)^i {n \\choose i} g_i&amp;\\Leftrightarrowg_n=\\sum_{i=0}^{n}(-1)^i {n \\choose i} f_i\\\\f_n=\\sum_{i=0}^{n}{n \\choose i} g_i&amp;\\Leftrightarrowg_n=\\sum_{i=0}^{n}(-1)^{n-i} {n \\choose i} f_i \\end{aligned}$$ 简单应用假设 $f(i)$ 表示大于等于 $i$ 的数对答案的贡献，求恰好为 $k$ 时对答案的贡献。 证明在上一篇题解，结论： $$\\sum\\limits_{i=k}^n (-1)^{i-k} {i \\choose k} f_i$$","link":"/er-xiang-shi-fan-yan/"},{"title":"多项式求逆学习笔记","text":"其实这玩意儿之前学过，不过感觉挺有趣的就再拿出来写篇笔记。 $$\\begin{align}A B_n &amp;\\equiv 1 \\pmod {x^n} \\\\A B_{\\frac n2} &amp;\\equiv 1 \\pmod {x^{\\frac n2}} \\\\\\\\B_n - B_{\\frac n2} &amp;\\equiv 0 \\pmod {x^{\\frac n2}} \\\\B_n^2 - B_n B_{\\frac n2} + B_{\\frac n2}^2 &amp;\\equiv 0 \\pmod {x^n} \\\\A(B_n^2 - 2B_n B_{\\frac n2} + B_{\\frac n2}^2) &amp;\\equiv 0 \\pmod {x^n} \\\\B_n &amp;\\equiv 2B_{\\frac n2} - AB_{\\frac n2}^2 \\pmod {x^n}\\end{align}$$ 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// =================================// author: memset0// date: 2019.01.26 14:26:03// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;#define ll long longnamespace ringo {template &lt;class T&gt; inline void read(T &amp;x) { x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;}template &lt;class T&gt; inline void print(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);}template &lt;class T&gt; inline void print(T x, char c) { print(x), putchar(c); }const int N = 4e5 + 10, mod = 998244353;int n, k, lim, inv_lim;int a[N], b[N], c[N], f[N], g[N], w[N], rev[N];int inv(int x) { return !x || x == 1 ? 1 : (ll)(mod - mod / x) * inv(mod % x) % mod; }inline int fpow(int a, int b) { int s = 1; for (; b; b &gt;&gt;= 1, a = (ll)a * a % mod) if (b &amp; 1) s = (ll)s * a % mod; return s; }void ntt(int *a) { for (int i = 0; i &lt; lim; i++) if (i &lt; rev[i]) std::swap(a[i], a[rev[i]]); for (int len = 1; len &lt; lim; len &lt;&lt;= 1) for (int i = 0; i &lt; lim; i += (len &lt;&lt; 1)) for (int j = 0; j &lt; len; j++) { int x = a[i + j], y = (ll)w[j + len] * a[i + j + len] % mod; a[i + j] = (x + y) % mod, a[i + j + len] = (x - y + mod) % mod; }}void main() { read(n); for (int i = 0; i &lt; n; i++) read(f[i]); g[0] = inv(f[0]); for (int len = 2, k = 2; (len &gt;&gt; 1) &lt;= n; len &lt;&lt;= 1, ++k) { lim = len &lt;&lt; 1, inv_lim = inv(lim); for (int i = 0; i &lt; len; i++) a[i] = f[i], b[i] = g[i]; for (int i = 0; i &lt; lim; i++) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (k - 1)); for (int len = 1, wn; len &lt; lim; len &lt;&lt;= 1) { wn = fpow(3, (mod - 1) / (len &lt;&lt; 1)), w[len] = 1; for (int i = 1; i &lt; len; i++) w[i + len] = (ll)w[i + len - 1] * wn % mod; } ntt(a), ntt(b); for (int i = 0; i &lt; lim; i++) a[i] = (ll)a[i] * b[i] % mod * b[i] % mod; std::reverse(a + 1, a + lim), ntt(a); for (int i = 0; i &lt; lim; i++) a[i] = (ll)a[i] * inv_lim % mod; for (int i = 0; i &lt; len; i++) g[i] = ((ll)(g[i] &lt;&lt; 1) - a[i] + mod) % mod; } for (int i = 0; i &lt; n; i++) print(g[i], \" \\n\"[i == n - 1]);}} signed main() { return ringo::main(), 0; }","link":"/duo-xiang-shi-qiu-ni/"},{"title":"NOIP2018 爆零记","text":"Day -1 注意这是 -1 天 上午照常模拟赛，考 NOIP 信心赛。 虽然是信心赛，但是题目好难。T1 洛谷原题，黑题难度 QAQ 。后两题稍微简单一点，但是如果开始刚了 T1 估计就来不及了。 我先开了 T2 ，推出了容斥，期望 $O(t \\log n)$ 的 70 分。然后去开 T3 ，写了个 $O(n \\times m \\log n)$ 加卡常，期望 80 。最后开 T1 ，一遍写对了一个动态开点线段树，特判特殊情况拿到 50 分部分分。 考试成绩出来，诶 T3 怎么 A 了 QAQ 。T2 没有输出 STO yyb ORZ （无解情况）少了 15 分， T1 还是预测得分 50 分。算是涨了不少信心吧。 下午继续写板子，任务列表也清的差不多了。还有一些很难的算法感觉也不会用到懒得写了。 晚上老师讲竞赛时间安排和一些注意事项，同是说明天是 “ Open Day ” ，我们可以光明正大的地颓废放松 233 . 讲完之后感觉压力突然加大，本来以为很遥远的 NOIP 真的近在眼前了。真的，真的，好紧张。找学长哭诉。 lyc 哥哥特别好，特别温暖，给了我许多安慰 qwq。 Day 0上午开始机房集体颓废，打 jokebird.com 爆踩全服。之后开始打球球大作战。也有人 5 人组队 LOL （第一局被对面五杀，第二局吊打对面 233） 下午继续颓废，看了点数论。 在赛百味吃完饭的时候遇见了 zx2003 学长，他给我们讲了一些他的故事，也给了我很大的鼓励。 晚上颓了一会会儿，然后手推 EXGCD 和 EXCRT ，虽说感觉不会考，主要还是熟悉一下推式子的感觉 QAQ 。 接着去楼上机房蹭 RP ，好紧张，又哭了 QAQ 。但是学长的安慰真的很有用（不然可能窝晚上心态就蹦了）。 睡觉的时候还是有点紧张，半夜睡不着。 Day 1但是早上起来精神状态还是很好的。一路赶去学军紫金港路也很顺畅。 早点到校门口集合领准考证，我们有同学的准考证在校园里还没领但是要有准考证才能进场 233 。还好老师送出来了。我们初中几个还拍了合影。 进考场前最后膜拜了一次大佬。坐我左边的是一个超好的（不认识的）高三学长。当时我特别紧张，他安慰了我也给了我鼓励，也让我平静了一下心态。 开题，解压密码 Fei2Xue@Lian$Tian! 。学军体育馆可真冷。 T1 上手一个 $O(n ^ 2)$ 贪心过了大样例，然后用 ST 表优化成 $O(n \\log n)$ 开始拍。 T2 一开始以为是 exgcd ，但又感觉不可能那么难。看了眼 T3 没思路，滚回来手玩了一下样例想到了个背包。一发过了大样例感觉很稳。 T3 先写了部分分，和状压暴力对拍。差不多写满 55 分部分分，正解的思路也有了。此时我可以写二叉树的部分分到 80 ，也可以直接写正解。经过了一番焦灼，还是写了部分分，毕竟写正解也有可能调不出来。 考完和同学 yy T3 ，发现了一个思维漏洞，不过很容易拍出来，而且我也立马想到了补救措施。不过如果这是考场就不一定了。所以感觉当初自己稳一点写了部分分也是挺正确的。 估分 $280 = 100 + 100 + 80$ ，考完听说 Sooke 、mocania 、 LJC00118 、 Isonan 都 AK 了。唉，毕竟技不如人，甘拜下风。 下午继续颓废，帮学长安 Flash Player 但是失败了，同时跟同学继续嘴巴 T3 。 晚上颓废 + 写游记，也不是很紧张了。 明天加油：尽人事，听天命。 Day 2无论如何预感今天的题目会很难。跟同学开玩笑说今天写满暴力就好了，结果还真 tmd 暴力滚粗了。 解压密码和昨天连起来：“飞雪连天射白鹿，笑书神侠倚碧鸳。” CCF 的解压密码倒是一年比一年有创意了233。就是能不能不要出原题QAQ。 开 T1 ，一开始以为是一张图，没想到是一个树和基环树。等等，这一题当两题的画风，让我想到了栗栗的书架啊。先随手写了个树的情况，过了大样例，开始看 T2 。 T2 一眼以为是状压，一脸懵逼。还成功出现了“关于 T2 的题目解释请看 T1 的情况”（那放洛谷上怎么办 233）。本想枚举个数然后直接判断，结果第二个样例输出 144 瞬间懵逼。写了发状压枚举路径判断过了两个小样例。开始跑 $5 \\times 5$ 的但始终过不去（为什么别人的状压可以跑 $7 \\times 7$ QAQ）。发现了每次 $\\times 3$ 的规律。 没办法，开 T3 ，44 分的 $O(n m)$ 暴力很好写，一遍过了大样例。开始想正解却没思路。目前已经有 $60 + 50 + 44 = 154$ 分了，还有两个小时多，先上个厕所冷静一下。 回来想继续优化 T2 ，但脑子里一直把枚举矩阵的 $O(2^{nm})$ 复杂度搞成了 $O(2^{n+m})$ 。结果当然是就算苦苦优化还是过不去大样例，白白浪费了半个小时。 接下去去看 T1 $n = m$ 的情况，由于 $m = n - 1$ 的情况可以 $O(n)$ 完成，我把 $n = 5000$ 的数据范围当成了 $n = 100000$ 最后强行想出来了一个 $O(n)$ 解法但已经又过了半个小时。还有一个小时感觉写不完这个及其麻烦的做法，赶紧苟了个成环的部分分。 只能看 T3 部分分。一条链上的情况考场里一脸懵逼毫无思路，考完出来却豁然开朗（mmp）。其实把 dp 的转移变成一个个矩阵放到线段树上区间查询即可。然而考场上我脑子里一片空白，什么也想不到。 回去检查 T2 ， T2 的大样例好毒啊，不仅给的数据范围小，而且都是 $n = m$ 的，感觉有坑。检查了老半天暴力还有不到半个小时。发现 $n = 1$ 的情况不是每次乘以 $3$ 而是 $2$ 。赶快改过来（差点就没分了），捡回一条狗命。 最后时间照常检查文件，交卷。考完出来要了隔壁同学的 QQ 号，也算是一种缘分吧。 Sooke ， Isonan 照样稳的一比 ， $200+$ 。感觉考场 debuff 太严重了，真的脑子里一片空白。平时模拟赛可以拖一段时间交卷，大胆地去尝试正解，然而考试的时候不仅没拖延的可能，还要单独花时间检查文件等等，一下就丧失了去尝试正解的勇气。 最后期望得分 $189 = 80 + 65 + 44$ Day 3出选手代码了，去洛谷上交了一发竟然 $ 474 = 100 + 100 + 80 + 80 + 70 + 44 $ ，激动的要死。 当然也有同学 D2T1 的 $O(n log n)$ 做法挂了，但还是比我高。 Day ?CCF 官方成绩出了，只有 $ 454 = 100 + 100 + 65 + 80 + 65 + 44 $ ，原来 D1T3 的分支不超过三按照我的那种方法有可能在根节点三叉。 看来 WC 无望了，只能希望可以上 PKUWC 的初中线吧。","link":"/diary-NOIP2018游记/"},{"title":"C++ 中的 __gcd() 函数探源","text":"最近在做一道需要用到 gcd 的题，正当我急于回忆 gcd 怎么写时，忽然听说有个叫__gcd()的内置函数。 知乎 上说这是个built-in函数（也许可以简单地理解为内置函数）。 但我对它的时间复杂度一直很担忧，想看看它到底是怎么实现的，便在C++内置库bits/stl_algo.h的 1512 - 1527 行找到可能的实现： 12345678910111213141516 /** * This is a helper function for the rotate algorithm specialized on RAIs. * It returns the greatest common divisor of two integer values. */ template&lt;typename _EuclideanRingElement&gt; _EuclideanRingElement __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n) { while (__n != 0){ _EuclideanRingElement __t = __m % __n; __m = __n; __n = __t;} return __m; } bits/stl_algo.h是C++的一个内置库，你引用algorithm库时就会引入这个库","link":"/geek-c++中gcd函数/"},{"title":"非旋 Treap 模板（普通平衡树）","text":"前言和 Splay 一样，非旋 Treap （又名 fhq-treap）也是平衡树的一种。由于其不需要进行旋转操作，故可利用其进行可持久化。 写一颗非旋 Treap，我们只需要合并、分离操作，其他的只要有颗脑子就会了啦！ 定义我们定义类FhqTreap为非旋 Treap 主体，结构体node为其节点。 123456789101112131415161718class FhqTheap { private: struct node { int val, rnd; // val =&gt; 该点存储的值，rnd =&gt; 该点键值，随机产生 int siz, ch[2]; // siz =&gt; 该点包括其子树的节点大小，ch[2] =&gt; 指向左/右儿子 } e[maxn]; int tot, root; // tot =&gt; 节点总数，root =&gt; 根节点 int x, y, z; // 操作过程中的临时变量 // Your Code Goes Here... public: // Your Code Goes Here... } s; 辅助操作update()更新当前节点的siz； newnode()用于新建节点。 1234567891011void update(int x) { e[x].siz = e[e[x].ch[0]].siz + e[e[x].ch[1]].siz + 1;}int newnode(int val) { tot++; e[tot].siz = 1; e[tot].ch[0] = e[tot].ch[1] = 0; e[tot].val = val, e[tot].rnd = rand(); return tot;} 合并将树 x 与树 y 合并，默认 x &lt; y。 如果其中一颗是空树，返回另一颗； 如果树 x 的根节点的rnd小于树 y 的根节点，把 x 的右子树与 y 合并后成为 x 的右子树； 如果树 x 的根节点的rnd大于树 y 的根节点，把 y 的左子树与 x 合并后成为 y 的左子树； 等于的话随意。 123456789101112int merge(int x, int y) { if (!x || !y) return x + y; if (e[x].rnd &lt; e[y].rnd) { e[x].ch[1] = merge(e[x].ch[1], y); update(x); return x; } else { e[y].ch[0] = merge(x, e[y].ch[0]); update(y); return y; }} 分离把以某一节点为根的子树以 k 为值分为两部分。 12345678void split(int u, int k, int &amp;x, int &amp;y) { if (!u) return (void)(x = y = 0); if (e[u].val &lt;= k) x = u, split(e[x].ch[1], k, e[x].ch[1], y); else y = u, split(e[y].ch[0], k, x, e[y].ch[0]); update(u);} 查找第 k 大利用其平衡树的性质，递归写法。 12345int kth(int u, int k) { if (k &lt;= e[e[u].ch[0]].siz) return kth(e[u].ch[0], k); if (k == e[e[u].ch[0]].siz + 1) return u; return kth(e[u].ch[1], k - e[e[u].ch[0]].siz - 1);} 其余操作十分简单，略。 123456789101112131415161718192021222324252627282930313233343536void insert(int val) { split(root, val, x, y); root = merge(merge(x, newnode(val)), y);}void erase(int val) { split(root, val, x, z); split(x, val - 1, x, y); y = merge(e[y].ch[0], e[y].ch[1]); root = merge(merge(x, y), z);}int rank(int val) { split(root, val - 1, x, y); int ret = e[x].siz + 1; merge(x, y); return ret;}int atrank(int k) { return e[kth(root, k)].val;}int lower_bound(int val) { split(root, val - 1, x, y); int ret = e[kth(x, e[x].siz)].val; merge(x, y); return ret;}int upper_bound(int val) { split(root, val, x, y); int ret = e[kth(y, 1)].val; merge(x, y); return ret;} 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define y1 this_is_not_y1#define y2 this_is_not_y2#define ll long longusing namespace std;int read() { int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;}const int maxn = 100010;int n, opt;class FhqTheap { private: struct node { int val, rnd; int siz, ch[2]; } e[maxn]; int tot, root, x, y, z; void update(int x) { e[x].siz = e[e[x].ch[0]].siz + e[e[x].ch[1]].siz + 1; } int newnode(int val) { tot++; e[tot].siz = 1; e[tot].ch[0] = e[tot].ch[1] = 0; e[tot].val = val, e[tot].rnd = rand(); return tot; } int merge(int x, int y) { if (!x || !y) return x + y; if (e[x].rnd &lt; e[y].rnd) { e[x].ch[1] = merge(e[x].ch[1], y); update(x); return x; } else { e[y].ch[0] = merge(x, e[y].ch[0]); update(y); return y; } } void split(int u, int k, int &amp;x, int &amp;y) { if (!u) return (void)(x = y = 0); if (e[u].val &lt;= k) x = u, split(e[x].ch[1], k, e[x].ch[1], y); else y = u, split(e[y].ch[0], k, x, e[y].ch[0]); update(u); } int kth(int u, int k) { if (k &lt;= e[e[u].ch[0]].siz) return kth(e[u].ch[0], k); if (k == e[e[u].ch[0]].siz + 1) return u; return kth(e[u].ch[1], k - e[e[u].ch[0]].siz - 1); } public: void insert(int val) { split(root, val, x, y); root = merge(merge(x, newnode(val)), y); } void erase(int val) { split(root, val, x, z); split(x, val - 1, x, y); y = merge(e[y].ch[0], e[y].ch[1]); root = merge(merge(x, y), z); } int rank(int val) { split(root, val - 1, x, y); int ret = e[x].siz + 1; merge(x, y); return ret; } int atrank(int k) { return e[kth(root, k)].val; } int lower_bound(int val) { split(root, val - 1, x, y); int ret = e[kth(x, e[x].siz)].val; merge(x, y); return ret; } int upper_bound(int val) { split(root, val, x, y); int ret = e[kth(y, 1)].val; merge(x, y); return ret; } } s;int main() { n = read(); while (n--) { opt = read(); switch(opt) { case 1: s.insert(read()); break; case 2: s.erase(read()); break; case 3: printf(\"%d\\n\", s.rank(read())); break; case 4: printf(\"%d\\n\", s.atrank(read())); break; case 5: printf(\"%d\\n\", s.lower_bound(read())); break; case 6: printf(\"%d\\n\", s.upper_bound(read())); break; } } return 0;}","link":"/fhq-treap/"},{"title":"Dev C++ 更改主题","text":"Dev C++ 是目前OIer使用最多的IDE，然而原始界面却丑的一逼。所以让我们来美化它233。 Before usingDev C++ 的主题默认存储在C:/Users/&lt;your name&gt;/AppData/Roaming/Dev-Cpp目录下，在该目录新建&lt;文件名&gt;.syntax添加配色。 在 Dev C++ 的菜单栏中选择工具[T]&gt;编辑器属性&gt;语法&gt;预设应用配色（可在选项中找到你之前新建的配色）；同时也可直接在 Dev C++ 中方便的调色（点击右侧自动跳转到对应内容）并保存（如果文件名与已存在的相同则默认替换）。 修改完后，务必在工具[T]&gt;编辑器属性&gt;基本中更改高亮显示当前行的颜色，以符合背景。 另外，推荐在使用暗色主题时关闭 Dev C++ 自带的各种工具栏！ 下面推荐两款暗色主题 qwq： Monokai.syntax经典的暗色配色，来自 Github 1234567891011121314151617181920[Editor.Custom]Assembler=$0099FFFF, clNone, 0, 0, 0Character=$0099FFFF, clNone, 0, 0, 0Comment=$00787878, clNone, 0, 1, 0Float=$0099FFFF, clNone, 0, 0, 0Hexadecimal=$0099FFFF, clNone, 0, 0, 0Identifier=clWhite, clNone, 0, 0, 0Illegal Char=clAqua, clNone, 0, 0, 0Number=$00FF55AA, clNone, 0, 0, 0Octal=$0099FFFF, clNone, 0, 0, 0Preprocessor=$007F2AFF, clNone, 0, 0, 0Reserved Word=$00FFD455, clNone, 0, 0, 0Space=clWindowText, $001E1E1E, 0, 0, 0String=$0099FFFF, clNone, 0, 0, 0Symbol=$007F2AFF, clNone, 0, 0, 0Selected text=16777215, 5921370Gutter=7895160, 1973790Break points=16777215, 13209Error Line=1973790, 10092543Active Breakpoints=16777215, 10040115 memset0.syntax（20180916更新）我个人修改出来的配色，高亮显示当前行颜色：Red: 46; Green: 52; Blue: 54; 123456789101112131415161718192021[Editor.Custom]Assembler=clPurple, $0036342E, 0, 0, 0Character=$00A062FF, $001D1D1D, 0, 0, 0Comment=$00C8C8C8, $001D1D1D, 0, 1, 0Float=$00A062FF, $001D1D1D, 0, 0, 0Hexadecimal=$0099FFFF, clNone, 0, 0, 0Identifier=$00FAFAFA, $001D1D1D, 0, 0, 0Illegal Char=clGray, $001D1D1D, 0, 0, 0Number=$00A062FF, $001D1D1D, 0, 0, 0Octal=$0099FFFF, clNone, 0, 0, 0Preprocessor=$003CF03C, $001D1D1D, 0, 0, 0Reserved Word=$00FF8F06, $001D1D1D, 0, 0, 0Space=clWindowText, $001D1D1D, 0, 0, 0String=$00FF99FF, $001D1D1D, 0, 0, 0Symbol=$0000DDDD, $001D1D1D, 0, 0, 0Selected text=1907997, 14604246Gutter=16777215, 1907997Breakpoints=16777215, 219Error line=1973790, 124158Active breakpoints=16777215, 11877436Folding lines=536870911, 536870911","link":"/geek-devc更改主题/"},{"title":"洛谷也能 Material 化？","text":"大佬 abc2237512422 的洛谷美化脚本推荐： 使用方式： 搜索安装 Stylus （或 Stylish ）的浏览器插件。 打开 https://userstyles.org/styles/157651/material-luogu-material 并安装。 还可在上面的网页进行个性化设置打造自己最喜欢的洛谷样式 qwq.","link":"/geek-luogu-material/"},{"title":"LNMP 一键安装包补充安装 fileinfo 拓展","text":"理论上来说这个拓展是可以被很方便地开启的，但是到了我的VPS这里不知为何各种鬼畜，只能自己找了个办法装一装。请忽略文章中的详略不当。 进入lnmp源码包目录，我的是 /root/lnmp1.51cd /root/lnmp1.5 进入源码目录，我们将手动编译安装1cd src 看目录下的文件（输入命令 ls ），如果有解压出的 php-7.1.18 文件夹（随后的版本号根据你安装的php版本而定，可以输入 php -v 查看或者输入 ls 看到底有哪个压缩包），你就不需要解压，当然一般来说是没有的。1tar -jxvf php-7.1.18.tar.bz2 解压过程可能比较漫长，但这并没有影响。之后进入解压出的文件夹，再进入fileinfo拓展的目录。12cd php-7.1.18cd ext/fileinfo 运行 phpize 命令，注意一定要在fileinfo目录执行1/usr/local/php/bin/phpize 如果成功，会有如下信息出现 Configuring for:PHP Api Version: 20160303Zend Module Api No: 20160303Zend Extension Api No: 320160303 接着配置php-config1./configure --with-php-config=/usr/local/php/bin/php-config 编译源码，安装fileinfo1make &amp;&amp; make install 如果成功，会有如下信息出现 Build complete.Don’t forget to run ‘make test’. Installing shared extensions: /usr/local/php/lib/php/extensions/no-debug-non-zts-20160303/ 接着修改 php.ini 文件，一般是 /usr/local/php/etc/php.ini 。也可以通过 php --ini 命令查看。1vim /usr/local/php/etc/php.ini 在最后一行加上1extension = fileinfo.so; 最后重启php-fpm即可。1lnmp php-fpm restart","link":"/geek-lnmp-install-fileinfo/"},{"title":"Mac 下 Sublime Text 3 配置运行 G++","text":"配置编译系统新建编译系统并粘贴入以下命令，保存为 G++.sublime-build 或其他你喜欢的名称。 123456789101112131415161718192021{ &quot;shell_cmd&quot;: &quot;g++ \\&quot;${file}\\&quot; -o \\&quot;${file_path}/${file_base_name}\\&quot; -Wall&quot;, &quot;file_regex&quot;: &quot;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$&quot;, &quot;working_dir&quot;: &quot;${file_path}&quot;, &quot;selector&quot;: &quot;source.c, source.c++&quot;, &quot;variants&quot;: [ { &quot;name&quot;: &quot;compile&quot;, &quot;shell_cmd&quot;: &quot;g++ \\&quot;${file}\\&quot; -o \\&quot;/tmp/${file_base_name}\\&quot; -Wall -O2 &amp;&amp; echo &apos;Compile finished.&apos;&quot; }, { &quot;name&quot;: &quot;run&quot;, &quot;shell_cmd&quot;: &quot;&apos;/tmp/${file_base_name}&apos; &amp;&amp; echo &apos;=============\\nRun finished.&apos;&quot; }, { &quot;name&quot;: &quot;compile &amp; run&quot;, &quot;shell_cmd&quot;: &quot;g++ \\&quot;${file}\\&quot; -o \\&quot;/tmp/${file_base_name}\\&quot; -Wall -O2 &amp;&amp; /tmp/${file_base_name} &amp;&amp; echo &apos;=============\\nComplie &amp; run finished.&apos;&quot; } ]} 配置编译运行快捷键把以下代码粘贴到你的快捷键配置文件中，表示 F9 编译， F10 运行， F11 编译并运行。 123456789101112131415161718{ &quot;keys&quot;: [&quot;f9&quot;], &quot;command&quot;: &quot;build&quot;, &quot;args&quot;: { &quot;variant&quot;: &quot;compile&quot; }}, { &quot;keys&quot;: [&quot;f10&quot;], &quot;command&quot;: &quot;build&quot;, &quot;args&quot;: { &quot;variant&quot;: &quot;run&quot; }}, { &quot;keys&quot;: [&quot;f11&quot;], &quot;command&quot;: &quot;build&quot;, &quot;args&quot;: { &quot;variant&quot;: &quot;compile &amp; run&quot; }} 其他注意事项Mac OS 下默认用 Clang 编译 G++ 代码。因此不支持使用万能头文件（bits/stdc++.h），解决方案： 手动复制 bits/stdc++.h 文件到对应目录中 手动安装 g++4.9 并把上面编译命令中的 g++ 替换为 g++-4.9","link":"/geek-mac下sb3运行g++/"},{"title":"C++ 函数传递二维数组","text":"QAQ 写树套树的时候忽然用到。。。 我们可以这样引用一维数组： 1234567891011121314151617181920int a[10];void function1(int *array) { /* some code */}void function2(int array[]) { /* some code */}void function3(int *array) { /* some code */}int main() { function1(a); function2(a); function3(a); return 0;} 但是二维数组就有所不同，对于第二维和更高维的部分，必须给出大小，像下面一样。 123456789101112131415int a[10][20];void function1(int array[10][20]) { /* some code */}void function2(int array[][20]) { /* some code */}int main() { function1(a); function2(a); return 0;}","link":"/geek-函数传递二维数组/"},{"title":"分治 NTT 学习笔记","text":"memset0 又来水博客了… 第一种做法是正常的分治 NTT ，想必大家都会，就不废话了；第二种做法是多项式求逆，想必大家也会，就摆几个式子了。 令 $F = \\sum\\limits_{x=0}^{\\infty} x^i f_i$ ， $G = \\sum\\limits_{x=0}^{\\infty} x^i g_i$ ，则易得 $F * G = F - 1$ ，故 $F = (1 - G)^{-1}$ ，多项式求逆即可。 代码1：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// =================================// author: memset0// date: 2019.01.19 09:43:04// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;#define ll long longnamespace ringo {template &lt;class T&gt; inline void read(T &amp;x) { x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;}template &lt;class T&gt; inline void print(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);}template &lt;class T&gt; inline void print(T x, char c) { print(x), putchar(c); }const int N = 4e5 + 10, mod = 998244353;int n, m;int f[N], g[N], a[N], b[N], c[N], w[N], rev[N];int inv(int x) { return !x || x == 1 ? 1 : (ll)(mod - mod / x) * inv(mod % x) % mod; }inline int fpow(int a, int b) { int s = 1; for (; b; b &gt;&gt;= 1, a = (ll)a * a % mod) if (b &amp; 1) s = (ll)s * a % mod; return s;}void ntt(int *a, int lim) { for (int i = 0; i &lt; lim; i++) if (i &lt; rev[i]) std::swap(a[i], a[rev[i]]); for (int len = 1; len &lt; lim; len &lt;&lt;= 1) for (int i = 0; i &lt; lim; i += (len &lt;&lt; 1)) for (int j = 0; j &lt; len; j++) { int x = a[i + j], y = (ll)w[len + j] * a[i + j + len] % mod; a[i + j] = (x + y) % mod, a[i + j + len] = (x - y + mod) % mod; }}void mul(int *a, int *b, int *c, int n, int m) { int lim = 1, k = 0, inv_lim; while (lim &lt;= (n + m)) lim &lt;&lt;= 1, ++k; for (int i = 0; i &lt; lim; i++) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (k - 1)); for (int i = n; i &lt; lim; i++) a[i] = 0; for (int i = m; i &lt; lim; i++) b[i] = 0; ntt(a, lim), ntt(b, lim); for (int i = 0; i &lt; lim; i++) a[i] = (ll)a[i] * b[i] % mod; std::reverse(a + 1, a + lim), ntt(a, lim), inv_lim = inv(lim); for (int i = 0; i &lt; n + m - 1; i++) c[i] = (ll)a[i] * inv_lim % mod;}void solve(int l, int r) { if (l == r) return (void)(f[l] += l == 0); int mid = (l + r) &gt;&gt; 1; solve(l, mid); for (int i = 0; i &lt;= mid - l; i++) a[i] = f[i + l]; for (int i = 0; i &lt; r - l + 1; i++) b[i] = g[i]; mul(a, b, c, mid - l + 1, r - l + 1); solve(mid + 1, r);}void main() { read(n); for (int len = 1, wn; (len &lt;&lt; 1) &lt; N; len &lt;&lt;= 1) { wn = fpow(3, (mod - 1) / (len &lt;&lt; 1)), w[len] = 1; for (int i = 1; i &lt; len; i++) w[len + i] = (ll)wn * w[len + i - 1] % mod; } for (int i = 1; i &lt; n; i++) read(g[i]); solve(0, n - 1); for (int i = 0; i &lt; n; i++) print(f[i], \" \\n\"[i == n - 1]);}} signed main() { return ringo::main(), 0; } 代码2：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// =================================// author: memset0// date: 2019.01.27 17:03:22// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;#define ll long longnamespace ringo {template &lt;class T&gt; inline void read(T &amp;x) { x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;}template &lt;class T&gt; inline void print(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);}template &lt;class T&gt; inline void print(T x, char c) { print(x), putchar(c); }const int N = 4e5 + 10, mod = 998244353;int n, lim;int f[N], g[N], a[N], b[N], w[N], rev[N];int inv(int x) { return !x || x == 1 ? 1 : (ll)(mod - mod / x) * inv(mod % x) % mod; }inline int fpow(int a, int b) { int s = 1; for (; b; b &gt;&gt;= 1, a = (ll)a * a % mod) if (b &amp; 1) s = (ll)s * a % mod; return s; }void ntt(int *a) { for (int i = 0; i &lt; lim; i++) if (i &lt; rev[i]) std::swap(a[i], a[rev[i]]); for (int len = 1; len &lt; lim; len &lt;&lt;= 1) for (int i = 0; i &lt; lim; i += (len &lt;&lt; 1)) for (int j = 0; j &lt; len; j++) { int x = a[i + j], y = (ll)w[j + len] * a[i + j + len] % mod; a[i + j] = (x + y) % mod, a[i + j + len] = (x - y + mod) % mod; }}void polyInv(int *f, int *g) { g[0] = inv(f[0]); for (int len = 2, k = 2, inv_lim; (len &gt;&gt; 1) &lt; n; len &lt;&lt;= 1, ++k) { lim = len &lt;&lt; 1, inv_lim = inv(lim); for (int i = 0; i &lt; lim; i++) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (k - 1)); for (int len = 1, wn; len &lt; lim; len &lt;&lt;= 1) { wn = fpow(3, (mod - 1) / (len &lt;&lt; 1)), w[len] = 1; for (int i = 1; i &lt; len; i++) w[i + len] = (ll)w[i + len - 1] * wn % mod; } for (int i = 0; i &lt; len; i++) a[i] = f[i], b[i] = g[i]; ntt(a), ntt(b); for (int i = 0; i &lt; lim; i++) a[i] = (ll)a[i] * b[i] % mod * b[i] % mod; std::reverse(a + 1, a + lim), ntt(a); for (int i = 0; i &lt; len; i++) g[i] = ((g[i] &lt;&lt; 1) - (ll)inv_lim * a[i] % mod + mod) % mod; }}void main() { read(n), g[0] = 1; for (int i = 1, x; i &lt; n; i++) read(x), g[i] = x ? mod - x : 0; polyInv(g, f); for (int i = 0; i &lt; n; i++) print(f[i], \" \\n\"[i == n - 1]);}} signed main() { return ringo::main(), 0; }","link":"/fen-zhi-ntt/"},{"title":"Git 生成 SSH 公钥","text":"由于最近经常折腾虚拟机和新电脑， git 也经常要重新安装 / 配置，因此记录一下 git 添加 SSH 公钥的方式。 步骤进入目录， 1cd ~/.ssh 如果提示目录不存在那么创建一个新目录 12mkdir ~/.sshcd ~/.ssh 输入以下命令生成密钥，会有三个选项调整，直接按回车键使用默认配置即可， 1ssh-keygen （很快的）生成密钥后，输入以下命令提取公钥： 1cat ~/.ssh/id_rsa.pub 前往 Github 把公钥添加进去即可 qwq 。 参考网址https://git-scm.com/book/zh/v1/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-%E7%94%9F%E6%88%90-SSH-%E5%85%AC%E9%92%A5 p.s. MacBook Pro 真好用（逃","link":"/geek-git生成ssh公钥/"},{"title":"十行求解 $O(n \\log n)$ 求最长上升子序列","text":"12345678910#include &lt;bits/stdc++.h&gt;int n, x, f[100001];int main() { memset(f, 63, sizeof(f)); scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;x), *std::lower_bound(f + 1, f + n + 1, x) = x; printf(\"%d\\n\", std::lower_bound(f + 1, f + n + 1, f[0]) - f - 1); return 0;}","link":"/lis/"},{"title":"Python 模拟登陆 Hust OJ","text":"前言最近闲着无聊准备写写Python爬虫，爬一下我们学校的oj用来横向比对做题量。但由于我校OJ对没有登录的账号有浏览限制，因此想要获取数据，就必须要登录账号。以前我一直手动生成Cookie，然后到浏览器里用该Cookie登录，这样的话没过一会儿又要重来比较麻烦。于是我就学习了一下用Python来POST数据的方式实现登录功能。 说明 感谢hiuseues大佬对我的指导！ 此处以我校OJ为例 请不要使用此测试账号（账号来自某外校团队）来浏览我校题目或交题，否则我将把密码改掉 我习惯于使用Python2写爬虫，主要因为我校电脑和我的VPS预装的都是这个版本。可能会和hiuseues大佬产生代沟，不要在意。当然，这个脚本的核心部分在Python3中完全可以运行，希望这样的话代沟可以小一点。 分析登录页面我们进入loginpage.php，可以看到一个登陆的界面。 使用“审查元素”功能查看一下这个登录框的源代码。 其中的核心代码如下（其他内容并没有什么卵用）： 12345&lt;form action=\"login.php\" method=\"post\" role=\"form\"&gt; &lt;input name=\"user_id\"&gt; &lt;input name=\"password\"&gt; &lt;button&gt;登录&lt;/button&gt;&lt;/form&gt; 即使你把代码删到只剩这么点，你照样可以登录：只不过界面难看点罢了。 分析数据那么我们来讲讲这段“最简代码”讲了什么： 最外层的form中定义了需要post到的页面 &lt;=&gt; action=&quot;login.php&quot; 同时也定义了数据的传输方式 &lt;=&gt; method=&quot;post&quot; 两个input提供了两个输入框，也是需要post到对应页面的数据 &lt;=&gt; &lt;input name=&quot;user_id&quot;&gt;、&lt;input name=&quot;password&quot;&gt; 最后你会发现还有一个button，你点一下数据就会被发送过去啦！ 该系统使用了明文密码传输的方式，因此比较容易分析。现在为了安全，越来越多的网站都在避免明文密码传输，但原理基本都是有互通之处的。不过在中国这个网络大环境下，完全有可能上级一个领导电话过来向你要xxx用户的密码，你程序员要是不存明文密码那行啊（ε=(´ο｀*)))唉） 那么你需要做的，就是给”/login.php”这个页面发送两个分别叫user_id和password的数据即可！ 如何post数据此处我们使用urllib和urllib2来操作，前者用于编码post的数据，后者用于发送请求。这两个库的名称和用法在python3略有改变，请参照下面的代码（下面的代码采用try的方式确保了在py2和py3中的兼容性，我以后的代码可能只会在py2中生效，但是你完全可以用同样的修改方式让它在py3中运行）。当然，你也可以使用requests等第三方库。值得一提的是，requests库在处理post文件的操作时非常方便。 我们用urllib库中的urlencode()方法来编码我们需要post的数据，在py2中的代码如下 1data = urllib.urlencode({\"user_id\": username, \"password\": password}) 接着你需要使用urllib2库中的urlopen()方法来打开网页，同时post数据（data） 1urllib2.urlopen(\"http://www.h2zbmh.com:8080/html/JudgeOnline/index.php\", data) 构建opener也许你在想，这就没了？结果你在尝试打开下一个页面时会发现，我还是没法获取那些需要登陆的页面啊！ 那么你可能需要一个opener来维持你打开页面的状态。接着使用opener.open(url)来代替urllib2.urlopen(url)并保留登陆状态。 在构建opener的同时，我们也会把当前自身的cookie保存到文件中，方便进一步的调试。 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445# encoding=utf8try: # python2的引入 import urllib import urllib2 import cookielibexcept ImportError: # python3的引入 import urllib.parse as urllib import urllib.request as urllib2 import http.cookiejar as cookielib # 利用try实现同时兼容py2和py3的效果username = 'LJB001590'password = '123' # 测试账号，账号密码来自某团队rooturl = 'http://www.h2zbmh.com:8080/html/JudgeOnline/'def geturl(url): return rooturl + url;def Build(): global opener # 引入全局变量 filename = 'cookie.txt' # 保存cookie的文件 cookie = cookielib.MozillaCookieJar(filename) # 创建一个实例 handler = urllib2.HTTPCookieProcessor(cookie) # 创建urllib2的cookie处理器 opener = urllib2.build_opener(handler) # 通过之前的cookie处理器构造opener opener.open(geturl('index.php')) # “随机”打开一个页面来获得cookie cookie.save(ignore_discard=True, ignore_expires=True) # 保存cookie到文件def Login(): global username, password, rooturl, opener # 引入全局变量 url = geturl('login.php') # 对应的网址 data = urllib.urlencode({\"user_id\": username, \"password\": password, }) # 需要post的数据 try: response = opener.open(url, data=data) # post数据 即 发送登录请求 except TypeError: response = opener.open(url, data=data.encode('utf-8')) # python3中的解决方式Build()Login()open(\"ans.html\", \"wb+\").write(opener.open(geturl('problemset.php')).read()) # 利用构建好的opener打开网页并输出到ans.html文件中（如果不显示“请登陆后继续操作！”说明成功）# 再次感谢hiuseues大佬","link":"/geek-python登录hostoj/"},{"title":"Dev C++ 资瓷 Hi DPI 方法","text":"前提条件，新版 Windows 10 （在有高分屏的机子上装 Win 10 不苛刻吧）。 首先定位到你的 devcpp.exe 文件，一般都在默认的安装目录下，右键他点击属性。 点击 更改高 DPI 设置 点击 替代高 DPI 缩放行为 ，并选择 系统（增强）。 重启 Dev C++ 即可看到效果。 已知问题： 与 Mactype 不兼容。","link":"/geek-devc高分屏/"},{"title":"HDU4336 - Card Collector","text":"考虑 Min-Max 容斥。用 $\\min(S)$ 表示 $S$ 中出现至少一个元素的期望时间，用 $\\max(S)$ 表示 $S$ 中每一个元素都出现的期望时间。 则： $$\\begin{aligned}\\min(S) &amp;= \\frac{1}{\\sum\\limits_{i \\in S} p_i} \\\\\\max(S) &amp;= \\sum\\limits_{S’ \\subseteq S} \\min(S’) (-1)^{|S’| - 1}\\end{aligned}$$ 答案显然是让我们求 $\\max(\\texttt{全集})$ ，故状压一下即可。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041// =================================// author: memset0// date: 2019.01.14 07:43:43// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;#define ll long longnamespace ringo {template &lt;class T&gt; inline void read(T &amp;x) { x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;}template &lt;class T&gt; inline void print(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);}template &lt;class T&gt; inline void print(T x, char c) { print(x), putchar(c); }const int N = 25;int n;double ans, sum, p[N];void main() { while (~scanf(\"%d\", &amp;n)) { ans = 0; for (int i = 1; i &lt;= n; i++) scanf(\"%lf\", &amp;p[i]); for (int x = 1; x &lt; (1 &lt;&lt; n); x++) { sum = 0; for (int i = 1; i &lt;= n; i++) if (x &amp; (1 &lt;&lt; (i - 1))) sum += p[i]; ans += (__builtin_popcount(x) &amp; 1 ? 1 : -1) / sum; } printf(\"%.6lf\\n\", ans); }}} signed main() { return ringo::main(), 0; }","link":"/hdu4336/"},{"title":"LJOJ1244 - 埃及分数","text":"您可以去 Vijos 上搜索此题，不过温馨提示， Vijos 的数据是错的，详情可以参考那题的讨论。 这是一道IDA*经典题，集成了启发式搜索和迭代加深的特点进行剪枝。 迭代加深本题中，我们限定DFS搜索的层数，如果超过这个层数，就进行剪枝。 启发式搜索我们设立一个估价函数，考虑最优情况下的步数。本题中我们按照分母从小到大的顺序来DFS埃及分母，所以之后遇到的值就必定大于当前取到的值。我们可以通过这个特性来写估价函数，即(a / b) / (1 / u)（其中a / b表示当前的值，u表示剩下能够取到的最小分母）做其他题目时一定要注意估价函数所估计的值之多劣于实际情况，而不能比实际情况更优。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll; // 用 typedef 据说比 define 快ll a, b;int limit;vector &lt; ll &gt; now, ans; // 存储当前选择的数和答案void red(ll a, ll b) { // 对分数 a / b 约分 ll gcd = __gcd(a, b); a /= gcd, b /= gcd;}int last(ll a, ll b, ll u) { // 估价函数 return a * u / b;}bool better() { // 判断当前情况是否比答案更优 if (ans.empty()) return true; for (vector &lt; ll &gt; ::reverse_iterator i = ans.rbegin(), j = now.rbegin(); i != ans.rend(), j != now.rend(); i++, j++) if (*i &gt; *j) return true; else if (*i &lt; *j) return false; return false;}void DFS(ll a, ll b, int step) { // IDA* 核心代码 red(a, b); if (step == limit) { //如果已经达到了迭代步数限制 if (a == 1) return; //判断剩余部分是否是埃及分数 now.push_back(b); if (better()) ans = now; now.pop_back(); } ll start = b / a + 1; // 数学方法可以证明至少为这个值 if (!now.empty()) start = max(start, *--now.end() + 1); // 剩余开始枚举的至少从当前决策的最大值 + 1，开始 for (ll i = start; true; i++) { if (step + last(a, b, i) &gt; limit) return; now.push_back(i); DFS(a * i - b, b * i, step + 1); // 进行下一步 now.pop_back(); }}int main() { scanf(\"%lld%lld\", &amp;a, &amp;b); for (limit = 0; true; limit++) { // 实际取到的个数是 limit + 1 DFS(a, b, 0); if (!ans.empty()) { for (vector &lt; ll &gt; ::iterator it = ans.begin(); it != ans.end(); it++) printf(\"%lld \", *it); break; } } return 0;}","link":"/ljoj1244/"},{"title":"LOJ6131 -「2017 山东三轮集训 Day1」Fiend","text":"考虑到原问题等价于以下行列式的值： $$第 i 行的 l_i 到 r_i 的值为 1 ，其他为 0 。$$ 我们采用高斯消元，复杂度 $O(n ^ 3)$ ，可以获得 70 pts. 考虑优化，由于 $1$ 的位置是连续的区间，采用左偏树维护每个左端点的右端点最小值即可。 注意行列式中交换两列，行列式的值取相反数；如果不能消成单位矩阵，则行列式的值为 $0$ 。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// =================================// author: memset0// date: 2019.01.12 13:44:20// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;#define ll long longnamespace ringo {template &lt;class T&gt; inline void read(T &amp;x) { x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;}template &lt;class T&gt; inline void print(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);}template &lt;class T&gt; inline void print(T x, char c) { print(x), putchar(c); }const int N = 1e5 + 10;int T, n, m, ans, cnt;int rt[N], l[N], r[N], id[N], val[N], ch[N][2], dis[N], pos[N];inline int new_node(int w, int i) { val[i] = w, dis[i] = 1; return id[i] = i; }inline int merge(int x, int y) { if (!x || !y) return x | y; if (val[x] &gt; val[y] || (val[x] == val[y] &amp;&amp; id[x] &gt; id[y])) std::swap(x, y); ch[x][1] = merge(ch[x][1], y); if (dis[ch[x][0]] &lt; dis[ch[x][1]]) std::swap(ch[x][0], ch[x][1]); dis[x] = dis[ch[x][0]] + 1; return x;}void main() { for (read(T); T--; ) { read(n), cnt = 0; for (int i = 1; i &lt;= n; i++) rt[i] = ch[i][0] = ch[i][1] = 0, pos[i] = i; for (int i = 1; i &lt;= n; i++) { read(l[i]), read(r[i]); rt[l[i]] = merge(rt[l[i]], new_node(r[i], i)); } ans = 1; for (int i = 1, nxt, x, y; i &lt;= n; i++) { while (rt[i] &amp;&amp; val[rt[i]] &lt; i) rt[i] = merge(ch[rt[i]][0], ch[rt[i]][1]); if (rt[i]) { // std::cout &lt;&lt; rt[i] &lt;&lt; \" \" &lt;&lt; val[rt[i]] &lt;&lt; \" \" &lt;&lt; id[rt[i]] &lt;&lt; std::endl; if (id[rt[i]] != i) { // printf(\"%d %d : %d %d\\n\", rt[i], pos[i], id[rt[i]], id[pos[i]]); x = rt[i], y = pos[i]; std::swap(id[x], id[y]); std::swap(pos[id[x]], pos[id[y]]); ans *= -1; } nxt = val[rt[i]]; rt[i] = merge(ch[rt[i]][0], ch[rt[i]][1]); if (nxt + 1 &lt;= n) { // printf(\"%d =&gt; %d\\n\", i, nxt + 1); rt[nxt + 1] = merge(rt[i], rt[nxt + 1]); } } else { ans = 0; break; } } // std::cout &lt;&lt; ans &lt;&lt; std::endl; putchar(\"FDY\"[ans + 1]), putchar('\\n'); }}} signed main() { return ringo::main(), 0; }","link":"/loj6131/"},{"title":"LOJ6029 - 「雅礼集训 2017 Day1」市场","text":"给定一个序列，要求兹滋： 区间加数、区间除以数、区间求和、区间求最小值。 其他都很简单，关键在于怎么解决区间除法。 一开始很容易想到之前的 “花神游历各国” ，但是这题并不能这样做（有区间加数），感觉线段树不可做想分块然而分块照样没法解决除法的问题。 正解则是将除法转换为减法，如果当前区间的最大值和最小值与除以除数的数的差值相同，那么把除数变成减数。 复杂度为 $O(n \\log^2 n)$ 据称可以用势能分析，但是本蒟蒻太菜了不会，因此略过 QAQ。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longint read() { int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;}const int maxn = 100010;int n, m, l, r, x, opt;int a[maxn];struct seg_node { int l, r, mid; ll sum, min, max, tag;} p[maxn &lt;&lt; 2];inline ll divide(ll a, ll b) { if (a &gt;= 0) return a / b; return (a - b + 1) / b;}inline void update(int u) { p[u].sum = p[u &lt;&lt; 1].sum + p[u &lt;&lt; 1 | 1].sum; p[u].max = std::max(p[u &lt;&lt; 1].max, p[u &lt;&lt; 1 | 1].max); p[u].min = std::min(p[u &lt;&lt; 1].min, p[u &lt;&lt; 1 | 1].min);}inline void pushup(int u, ll x) { p[u].tag += x, p[u].min += x, p[u].max += x; p[u].sum += x * (p[u].r - p[u].l + 1);}inline void pushdown(int u) { if (p[u].tag) { if (p[u].l ^ p[u].r) { pushup(u &lt;&lt; 1, p[u].tag); pushup(u &lt;&lt; 1 | 1, p[u].tag); } p[u].tag = 0; }}void build(int u, int l, int r) { p[u].l = l, p[u].r = r, p[u].mid = (l + r) &gt;&gt; 1; if (l == r) { p[u].sum = p[u].min = p[u].max = a[l]; return; } build(u &lt;&lt; 1, l, p[u].mid); build(u &lt;&lt; 1 | 1, p[u].mid + 1, r); update(u);}void modify_sum(int u, int l, int r, ll x) { pushdown(u); if (p[u].l == l &amp;&amp; p[u].r == r) { pushup(u, x); return; } if (r &lt;= p[u].mid) modify_sum(u &lt;&lt; 1, l, r, x); else if (l &gt; p[u].mid) modify_sum(u &lt;&lt; 1 | 1, l, r, x); else modify_sum(u &lt;&lt; 1, l, p[u].mid, x), modify_sum(u &lt;&lt; 1 | 1, p[u].mid + 1, r, x); update(u);}void modify_div(int u, int l, int r, ll x) { pushdown(u); if ((!p[u].min || !~p[u].min) &amp;&amp; (!p[u].max || !~p[u].max)) return; if (p[u].l == l &amp;&amp; p[u].r == r) { int new_min = divide(p[u].min, x), new_max = divide(p[u].max, x); if (p[u].min - new_min == p[u].max - new_max) { pushup(u, new_min - p[u].min); return; } } if (r &lt;= p[u].mid) modify_div(u &lt;&lt; 1, l, r, x); else if (l &gt; p[u].mid) modify_div(u &lt;&lt; 1 | 1, l, r, x); else modify_div(u &lt;&lt; 1, l, p[u].mid, x), modify_div(u &lt;&lt; 1 | 1, p[u].mid + 1, r, x); update(u);}ll query_sum(int u, int l, int r) { pushdown(u); if (p[u].l == l &amp;&amp; p[u].r == r) return p[u].sum; if (r &lt;= p[u].mid) return query_sum(u &lt;&lt; 1, l, r); else if (l &gt; p[u].mid) return query_sum(u &lt;&lt; 1 | 1, l, r); else return query_sum(u &lt;&lt; 1, l, p[u].mid) + query_sum(u &lt;&lt; 1 | 1, p[u].mid + 1, r);}ll query_min(int u, int l, int r) { pushdown(u); if (p[u].l == l &amp;&amp; p[u].r == r) return p[u].min; if (r &lt;= p[u].mid) return query_min(u &lt;&lt; 1, l, r); else if (l &gt; p[u].mid) return query_min(u &lt;&lt; 1 | 1, l, r); else return std::min(query_min(u &lt;&lt; 1, l, p[u].mid), query_min(u &lt;&lt; 1 | 1, p[u].mid + 1, r));}int main() { n = read(), m = read(); for (int i = 1; i &lt;= n; i++) a[i] = read(); build(1, 1, n); for (int i = 1; i &lt;= m; i++) { opt = read(); if (opt == 1) { l = read() + 1, r = read() + 1, x = read(); modify_sum(1, l, r, x); } else if (opt == 2) { l = read() + 1, r = read() + 1, x = read(); modify_div(1, l, r, x); } else if (opt == 3) { l = read() + 1, r = read() + 1; printf(\"%lld\\n\", query_min(1, l, r)); } else { l = read() + 1, r = read() + 1; printf(\"%lld\\n\", query_sum(1, l, r)); } } return 0;}","link":"/loj6029/"},{"title":"LOJ2541 - 「PKUWC2018」猎人杀","text":"设 $P(S)$ 为钦点 $S$ 中所有元素都在 1 之后挂掉的概率，显然： $$P(s) = \\frac{a_1}{sum(S) + a_1}$$ 于是我们可以发现最后答案为： $$ans = \\sum\\limits_{S \\in [2, n]} P(S) (-1)^{|S|}$$ 于是分治 + NTT 即可。 至此除斗地主外的所有 PKUWC 2018 题目已经订正完毕，祝也去参加 PKUWC 的读者和自己 RP = $+\\infty$ qwq！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182// =================================// author: memset0// date: 2019.01.16 18:25:25// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;#define ll long longnamespace ringo {template &lt;class T&gt; inline void read(T &amp;x) { x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;}template &lt;class T&gt; inline void print(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);}template &lt;class T&gt; inline void print(T x, char c) { print(x), putchar(c); }const int N = 8e5 + 10, mod = 998244353;typedef std::vector &lt;int&gt; vector;int n, ans, a[N];int _f[N], _g[N], _r[N], _w[N];int inv(int x) { if (!x || x == 1) return 1; return (ll)(mod - mod / x) * inv(mod % x) % mod;}int fpow(int a, int b) { int s = 1; for (; b; b &gt;&gt;= 1, a = (ll)a * a % mod) if (b &amp; 1) s = (ll)s * a % mod; return s;}inline void ntt(int *a, int lim) { for (int i = 0; i &lt; lim; i++) if (i &lt; _r[i]) std::swap(a[i], a[_r[i]]); for (int len = 1; len &lt; lim; len &lt;&lt;= 1) for (int i = 0; i &lt; lim; i += (len &lt;&lt; 1)) for (int j = 0; j &lt; len; j++) { int x = a[i + j], y = (ll)a[i + j + len] * _w[len + j] % mod; a[i + j] = (x + y) % mod, a[i + j + len] = (x - y + mod) % mod; }}inline vector operator * (const vector &amp;f, const vector &amp;g) { int lim = 1, k = 0, fs = f.size(), gs = g.size(); while (lim &lt;= (fs + gs - 1)) lim &lt;&lt;= 1, ++k; for (int i = 0; i &lt; lim; i++) { _r[i] = (_r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (k - 1)); _f[i] = i &lt; fs ? f[i] : 0, _g[i] = i &lt; gs ? g[i] : 0; } ntt(_f, lim), ntt(_g, lim); for (int i = 0; i &lt; lim; i++) _f[i] = (ll)_f[i] * _g[i] % mod; std::reverse(_f + 1, _f + lim), ntt(_f, lim), lim = inv(lim); vector r(fs + gs - 1); for (int i = 0; i &lt; r.size(); i++) r[i] = (ll)_f[i] * lim % mod; return r;}vector solve(int l, int r) { if (l == r) { vector r(a[l] + 1); r[0] = 1, r[a[l]] = mod - 1; return r; } int mid = (l + r) &gt;&gt; 1; vector L = solve(l, mid), R = solve(mid + 1, r); return L * R;}void main() { for (int len = 1, wn; (len &lt;&lt; 1) &lt; N; len &lt;&lt;= 1) { _w[len] = 1, wn = fpow(3, (mod - 1) / (len &lt;&lt; 1)); for (int i = 1; i &lt; len; i++) _w[i + len] = (ll)_w[i + len - 1] * wn % mod; } read(n); for (int i = 1; i &lt;= n; i++) read(a[i]); vector vet = solve(2, n); for (int i = 0; i &lt; vet.size(); i++) { ans = (ans + (ll)a[1] * inv(i + a[1]) % mod * vet[i]) % mod; print(ans, '\\n'); }} signed main() { return ringo::main(), 0; }","link":"/loj2541/"},{"title":"LOJ2542 - 「PKUWC2018」随机游走","text":"考虑 Min-Max 容斥，$\\min(S)$ 表示至少一个从 $s$ 走到至少一个属于集合 $S$ 的点的期望时间。 用 $f(i, S)$ 表示集合 $S$ 下 $i$ 到任意 $u \\in S$ 的期望时间，则 $\\min(S) = f(s, S)$。 $$f(i, S) =\\begin{cases}0 &amp;(i \\in S) \\\\\\frac{\\sum_{i \\to j} f(j, S)}{d_i} + 1 &amp;(i \\notin S)\\end{cases}$$ 可通过高斯消元求出，但复杂度过大不能接受。考虑把原式化为 $f(i) = k_i \\times f(father_i) + b_i$ 的形式，推导过程略。对于每个查询状压处理 $\\max(S)$ 不现实，需要处理出子集卷积即可 AC 。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// =================================// author: memset0// date: 2019.01.14 10:09:31// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;#define ll long longnamespace ringo {template &lt;class T&gt; inline void read(T &amp;x) { x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;}template &lt;class T&gt; inline void print(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);}template &lt;class T&gt; inline void print(T x, char c) { print(x), putchar(c); }const int N = 20, mod = 998244353;int n, m, t, s, S, lim, f[N], k[N], b[N], a[1 &lt;&lt; 18];std::vector &lt;int&gt; G[N];inline int sum(int a, int b) { return (a + b) % mod; }inline int dec(int a, int b) { return (a - b + mod) % mod; }int inv(int x) { return !x || x == 1 ? 1 : (ll)(mod - mod / x) * inv(mod % x) % mod; }void dfs(int u, int father = 0) { for (auto v : G[u]) if (v != father) dfs(v, u); if ((1 &lt;&lt; (u - 1)) &amp; S) { k[u] = b[u] = 0; return; } int Sk = 0, Sb = 0, d = G[u].size(); for (auto v : G[u]) if (v != father) (Sk += k[v]) %= mod, (Sb += b[v]) %= mod; k[u] = inv(dec(d, Sk)), b[u] = (ll)k[u] * sum(Sb, d) % mod;}void dfs2(int u, int father = 0) { f[u] = ((ll)k[u] * f[father] + b[u]) % mod; for (auto v : G[u]) if (v != father) dfs2(v, u);}int calc(int _S) { S = _S, dfs(s), dfs2(s); return f[s];}void fwt(int *a) { for (int len = 1; len &lt; lim; len &lt;&lt;= 1) for (int i = 0; i &lt; lim; i += (len &lt;&lt; 1)) for (int j = 0; j &lt; len; j++) (a[i + j + len] += a[i + j]) %= mod;}void main() { read(n), read(m), read(s), lim = 1 &lt;&lt; n; for (int i = 1, u, v; i &lt; n; i++) read(u), read(v), G[u].push_back(v), G[v].push_back(u); for (S = 1; S &lt; lim; S++) a[S] = (ll)calc(S) * (__builtin_popcount(S) &amp; 1 ? 1 : mod - 1) % mod; fwt(a); for (int i = 1; i &lt;= m; i++) { int S = 0; read(t); for (int i = 1, x; i &lt;= t; i++) read(x), S |= 1 &lt;&lt; (x - 1); print(a[S], '\\n'); }}} signed main() { return ringo::main(), 0; }","link":"/loj2542/"},{"title":"LOJ6495 - 「雅礼集训 2018 Day1」树","text":"非常妙的一道状压题。 考虑依次加入每一个点，状态之间的转移和对答案的贡献只与每个深度的节点个数，因此我们可以这样定义状态：把这棵树的节点按深度排序，显然相邻两个的深度最多相差一，如果差等于一，状压出的对应位就是 1 ，否则就是 0 。利用这个即可进行 $O(2^n \\times n ^ 2)$ 的转移。 还有一种 $O(n ^ 3)$ 的天顶星写法，但是我暂时不会，只能等以后补锅。 代码： 由于作者比较懒，写了较好写的 $O(2^n \\times n^3)$ ，最后一个 $n = 24$ 过不去，可打表解决 qwq。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// =================================// author: memset0// date: 2018.12.24 16:00:22// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (register int i = l; i &lt;= r; i++)namespace ringo {typedef long long ll;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;}template &lt;class T&gt; inline void print(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);}template &lt;class T&gt; inline void maxd(T &amp;a, T b) { if (b &gt; a) a = b; }template &lt;class T&gt; inline void mind(T &amp;a, T b) { if (b &lt; a) a = b; }template &lt;class T&gt; inline void print(T x, char c) { print(x), putchar(c); }template &lt;class T&gt; inline T abs(const T &amp;a) { if (a &lt; 0) return -a; return a; }const int N = 30;int n, p, ans, pans, b[N], cnt[N], f[2][1 &lt;&lt; 24];double fans;template &lt;class T&gt;inline void sumd(int &amp;a, const T &amp;b) { a = (a + b) % p;}int fpow(int a, int b) { int s = 1; while (b) { if (b &amp; 1) s = (long long)s * a % p; a = (long long)a * a % p, b &gt;&gt;= 1; } return s;}void main() { read(n), read(p); if (n == 24 &amp;&amp; p == 998244353) { print(6,'\\n'); print(84344574,'\\n'); return; } f[1][1] = 1; for (int i = 1, u; i &lt; n; i++) { memset(f[i &amp; 1 ^ 1], 0, sizeof(f[i &amp; 1 ^ 1])); for (int x = 0, y; x &lt; (1 &lt;&lt; i); x++) if (f[i &amp; 1][x]) { u = 0; for (int j = 1; j &lt;= i; j++) if (x &amp; (1 &lt;&lt; (j - 1))) cnt[++u] = 1, b[j] = u; else ++cnt[u], b[j] = u; for (int j = 1; j &lt;= i; j++) { ++cnt[b[j] + 1], y = 0; for (int k = 1, t = 1; k &lt;= (b[j] == u ? u + 1 : u); k++) y |= 1 &lt;&lt; (t - 1), t += cnt[k]; sumd(f[i &amp; 1 ^ 1][y], f[i &amp; 1][x]); --cnt[b[j] + 1]; } } } for (register int x = 0, cnt; x &lt; (1 &lt;&lt; n); x++) { cnt = 0; for (register int i = 1; i &lt;= n; i++) if (x &amp; (1 &lt;&lt; (i - 1))) ++cnt; sumd(ans, (ll)f[n &amp; 1][x] * cnt); } for (int i = 1; i &lt; n; i++) ans = (long long)ans * fpow(i, p - 2) % p; if (n &gt;= 16) print(6, '\\n'); else if (n &gt;= 10) print(5, '\\n'); else if (n &gt;= 6) print(4, '\\n'); else if (n &gt;= 3) print(3, '\\n'); else print(n, '\\n'); print(ans, '\\n');}} signed main() { return ringo::main(), 0; }","link":"/loj6495/"},{"title":"LOJ6496 - 「雅礼集训 2018 Day1」仙人掌","text":"分治套 NTT 优化仙人掌 DP 题目。往这个方向想其实不是很难推，于是就懒得写题解直接贴代码了 qwq。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136// =================================// author: memset0// date: 2018.12.26 15:53:02// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;#define pb push_back#define rep(i, l, r) for (register int i = l; i &lt;= r; i++)namespace ringo {typedef long long ll;typedef unsigned long long ull;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;}template &lt;class T&gt; inline void print(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);}template &lt;class T&gt; inline void maxd(T &amp;a, T b) { if (b &gt; a) a = b; }template &lt;class T&gt; inline void mind(T &amp;a, T b) { if (b &lt; a) a = b; }template &lt;class T&gt; inline void print(T x, char c) { print(x), putchar(c); }template &lt;class T&gt; inline T abs(const T &amp;a) { if (a &lt; 0) return -a; return a; }const int N = 2e5 + 10, p = 998244353;int n, m, tim, nod, top;int a[N], dfn[N], low[N], stk[N], f[N][3], g[N][2];typedef std::vector &lt;int&gt; vector;vector t[N];#define walk(i, u, v, G) for (int i = G.hed[u], v = G.to[i]; i; i = G.nxt[i], v = G.to[i])struct graph { int tot, hed[N], nxt[N &lt;&lt; 1], to[N &lt;&lt; 1]; graph () { tot = 2; } inline void add(int u, int v) { nxt[tot] = hed[u], to[tot] = v, hed[u] = tot++; }} G, P;int inv(int x) { return !x || x == 1 ? 1 : (ll)(p - p / x) * inv(p % x) % p; }inline int fpow(int a, int b) { int s; for (s = 1; b; b &gt;&gt;= 1, a = (ll)a * a % p) if (b &amp; 1) s = (ll)s * a % p; return s;}int _a[N &lt;&lt; 2], _b[N &lt;&lt; 2], rev[N &lt;&lt; 2];inline void ntt(int *a, int lim, int g) { for (int i = 0; i &lt; lim; i++) if (i &lt; rev[i]) std::swap(a[i], a[rev[i]]); for (int len = 1; len &lt; lim; len &lt;&lt;= 1) for (int i = 0, wn = fpow(g, (p - 1) / (len &lt;&lt; 1)); i &lt; lim; i += (len &lt;&lt; 1)) for (int j = 0, w = 1; j &lt; len; j++, w = (ll)w * wn % p) { int x = a[i + j], y = (ll)w * a[i + j + len] % p; a[i + j] = (x + y) % p, a[i + j + len] = (x - y + p) % p; }}inline vector operator * (const vector &amp;a, const vector &amp;b) { if (!a.size()) return b; if (!b.size()) return a; int lim = 1, k = 0; while (lim &lt;= (int)(a.size() + b.size())) lim &lt;&lt;= 1, ++k; for (int i = 0; i &lt; (int)a.size(); i++) _a[i] = a[i]; for (int i = 0; i &lt; (int)b.size(); i++) _b[i] = b[i]; for (int i = a.size(); i &lt; lim; i++) _a[i] = 0; for (int i = b.size(); i &lt; lim; i++) _b[i] = 0; for (int i = 0; i &lt; lim; i++) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (k - 1)); ntt(_a, lim, 3), ntt(_b, lim, 3); for (int i = 0; i &lt; lim; i++) _a[i] = (ll)_a[i] * _b[i] % p; ntt(_a, lim, 332748118), lim = inv(lim); vector c(a.size() + b.size() - 1); for (int i = 0; i &lt; (int)c.size(); i++) c[i] = (ll)_a[i] * lim % p; return c;}void tarjan(int u, int from) { dfn[u] = low[u] = ++tim, stk[++top] = u; walk(i, u, v, P) if (!dfn[v]) { tarjan(v, i), mind(low[u], low[v]); if (low[v] == dfn[u]) { G.add(u, ++nod); do G.add(nod, stk[top]); while (stk[top--] != v); } else if (low[v] &gt; dfn[u]) G.add(u, v), top--; } else if ((i ^ 1) != from) mind(low[u], dfn[v]);}vector solve(int l, int r) { if (l == r) return t[l]; int mid = (l + r) &gt;&gt; 1; vector _l = solve(l, mid), _r = solve(mid + 1, r); return _l * _r;}void dfs(int u) { walk(i, u, v, G) dfs(v); if (u &lt;= n) { if (!G.hed[u]) { f[u][0] = a[u] &gt;= 0, f[u][1] = a[u] &gt;= 1, f[u][2] = a[u] &gt;= 2; return; } int cnt = 0; walk(i, u, v, G) { t[++cnt].clear(); if (v &lt;= n) t[cnt].pb(f[v][1]), t[cnt].pb(f[v][0]); else t[cnt].pb(f[v][2]), t[cnt].pb(f[v][1]), t[cnt].pb(f[v][0]); } vector now = solve(1, cnt); now.resize(a[u] + 1); for (int i = 1; i &lt; (int)now.size(); i++) now[i] = (now[i] + now[i - 1]) % p; if (a[u] &gt;= 0) f[u][0] = now[a[u]]; if (a[u] &gt;= 1) f[u][1] = now[a[u] - 1]; if (a[u] &gt;= 2) f[u][2] = now[a[u] - 2]; } else { std::vector &lt;int&gt; son; walk(i, u, v, G) son.pb(v); for (int pre = 0; pre &lt; 2; pre++) { g[0][pre] = 1, g[0][pre ^ 1] = 0; for (int i = 0, v; i &lt; (int)son.size(); i++) { v = son[i]; g[i + 1][0] = ((ll)g[i][0] * f[v][1] + (ll)g[i][1] * f[v][2]) % p; g[i + 1][1] = ((ll)g[i][0] * f[v][0] + (ll)g[i][1] * f[v][1]) % p; } if (pre) (f[u][2] += g[son.size()][0]) %= p, (f[u][1] += g[son.size()][1]) %= p; else (f[u][1] += g[son.size()][0]) %= p, (f[u][0] += g[son.size()][1]) %= p; } }}void main() { read(n), read(m); for (int i = 1, u, v; i &lt;= m; i++) read(u), read(v), P.add(u, v), P.add(v, u); for (int i = 1; i &lt;= n; i++) read(a[i]); nod = n, tarjan(1, 0), dfs(1); print(f[1][0], '\\n');}} signed main() { return ringo::main(), 0; }","link":"/loj6496/"},{"title":"LOJ6498 - 「雅礼集训 2018 Day2」农民","text":"按题意可知，考虑每个节点会给左孩子带来一个 $(-\\infty, a_i )$ 的限制，会给右孩子带来一个 $(a_i, +\\infty)$ 的限制。 定义限制 $(-\\infty, a_i)$ 的限制取反为 $(a_i, +\\infty)$ ，反之亦然。 考虑把原树进行树链剖分。每个节点存放自己给重儿子带来的限制，用支持单点修改、区间取反、区间查询的线段树维护区间限制的并集。由于每个节点往上跳只会经过 $\\log n$ 条重链，重链内部直接从线段树上查询，两条重链之间的转移把转折点对重儿子的限制取反即可。总复杂度为 $O(n \\log ^ 2 n)$，可以通过此题。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149// =================================// author: memset0// date: 2018.12.25 08:09:28// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;#define rep(i, l, r) for (register int i = l; i &lt;= r; i++)namespace ringo {typedef long long ll;typedef unsigned long long ull;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;}template &lt;class T&gt; inline void print(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);}template &lt;class T&gt; inline void maxd(T &amp;a, T b) { if (b &gt; a) a = b; }template &lt;class T&gt; inline void mind(T &amp;a, T b) { if (b &lt; a) a = b; }template &lt;class T&gt; inline void print(T x, char c) { print(x), putchar(c); }template &lt;class T&gt; inline T abs(const T &amp;a) { if (a &lt; 0) return -a; return a; }const int N = 1e5 + 10, inf = 2e9;int n, m, x, y, op, min, max;int a[N], ch[N][2];int pos, id[N], fa[N], top[N], wid[N], siz[N], son[N], side[N];struct info { int min, max, _min, _max; inline info reverse() { return (info) { _max, _min, max, min }; }};inline info merge(const info &amp;a, const info &amp;b) { return (info) { std::max(a.min, b.min), std::min(a.max, b.max), std::min(a._min, b._min), std::max(a._max, b._max) };}struct node { int l, r, mid; bool rev, lazy; info x;} p[N &lt;&lt; 2];inline info get_info(int k, bool flag) { if (flag) return (info){a[k], inf, a[k], -inf}; else return (info){-inf, a[k], inf, a[k]};}inline void pushup(int u) { p[u].lazy ^= 1, p[u].rev ^= 1; p[u].x = p[u].x.reverse();}inline void pushdown(int u) { if (p[u].lazy) { if (p[u].l != p[u].r) pushup(u &lt;&lt; 1), pushup(u &lt;&lt; 1 | 1); p[u].lazy = 0; }}void dfs1(int u) { siz[u] = 1; for (int i = 0; i &lt; 2; i++) if (ch[u][i]) { dfs1(ch[u][i]), fa[ch[u][i]] = u, siz[u] += siz[ch[u][i]]; if (siz[ch[u][i]] &gt; siz[son[u]]) son[u] = ch[u][i], side[u] = i; }}void dfs2(int u, int toppoint) { id[u] = ++pos, wid[id[u]] = u, top[u] = toppoint; if (siz[u] == 1) return; dfs2(son[u], toppoint); for (int i = 0; i &lt; 2; i++) if (ch[u][i] &amp;&amp; i != side[u]) dfs2(ch[u][i], ch[u][i]);}void build(int u, int l, int r) { p[u].l = l, p[u].r = r, p[u].mid = (l + r) &gt;&gt; 1; if (l == r) { p[u].x = get_info(wid[l], side[wid[l]]); return; } build(u &lt;&lt; 1, l, p[u].mid); build(u &lt;&lt; 1 | 1, p[u].mid + 1, r); p[u].x = merge(p[u &lt;&lt; 1].x, p[u &lt;&lt; 1 | 1].x);}void modify(int u, int k) { pushdown(u); if (p[u].l == p[u].r) { p[u].x = get_info(wid[k], side[wid[k]] ^ p[u].rev); return; } modify(k &lt;= p[u].mid ? u &lt;&lt; 1 : u &lt;&lt; 1 | 1, k); p[u].x = merge(p[u &lt;&lt; 1].x, p[u &lt;&lt; 1 | 1].x);}void reverse(int u, int l, int r) { pushdown(u); if (p[u].l == l &amp;&amp; p[u].r == r) { pushup(u); return; } if (r &lt;= p[u].mid) reverse(u &lt;&lt; 1, l, r); else if (l &gt; p[u].mid) reverse(u &lt;&lt; 1 | 1, l, r); else reverse(u &lt;&lt; 1, l, p[u].mid), reverse(u &lt;&lt; 1 | 1, p[u].mid + 1, r); p[u].x = merge(p[u &lt;&lt; 1].x, p[u &lt;&lt; 1 | 1].x);}info query(int u, int l, int r) { pushdown(u); if (p[u].l == l &amp;&amp; p[u].r == r) return p[u].x; if (r &lt;= p[u].mid) return query(u &lt;&lt; 1, l, r); else if (l &gt; p[u].mid) return query(u &lt;&lt; 1 | 1, l, r); else return merge(query(u &lt;&lt; 1, l, p[u].mid), query(u &lt;&lt; 1 | 1, p[u].mid + 1, r));}inline bool check(int u, const info &amp;lim) { return lim.min &lt; u &amp;&amp; u &lt; lim.max; }bool query(int u, int w) { info ret = (info){-inf, inf, inf, -inf}; while (u) { if (top[u] != u) { info tmp = query(1, id[top[u]], id[fa[u]]); ret = merge(ret, tmp); } if (fa[top[u]]) { info tmp = query(1, id[fa[top[u]]], id[fa[top[u]]]).reverse(); ret = merge(ret, tmp); } u = fa[top[u]]; } return check(w, ret);}void main() { read(n), read(m); for (int i = 1; i &lt;= n; i++) read(a[i]), read(ch[i][0]), read(ch[i][1]); dfs1(1), dfs2(1, 1), build(1, 1, n); for (int i = 1; i &lt;= m; i++) { read(op), read(x); if (op == 1) { read(y), a[x] = y, modify(1, id[x]); } else if (op == 2) { reverse(1, id[x], id[x] + siz[x] - 1); } else { if (x == 1) puts(\"YES\"); else puts(query(x, a[x]) ? \"YES\" : \"NO\"); } }}} signed main() { return ringo::main(), 0; }","link":"/loj6498/"},{"title":"LOJ6132 - 「2017 山东三轮集训 Day1」Flair","text":"大于 $\\max(c_i c_j)$ 的 $ v = \\gcd(c_i) \\ (i \\in [1, n])$ 的倍数都可以被取到。先做关于 $v$ 的循环卷积，然后背包一下把中间相差的部分补上即可。由于要求对 $10^9+7$ 取模，所以需要 MTT。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121// =================================// author: memset0// date: 2019.01.15 07:32:59// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;#define ll long longnamespace ringo {template &lt;class T&gt; inline void read(T &amp;x) { x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;}template &lt;class T&gt; inline void print(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);}template &lt;class T&gt; inline void print(T x, char c) { print(x), putchar(c); }#define clear(x) memset(x, 0, sizeof(x))const int N = 8e5 + 10, M = 8e4 + 10, mod = 1e9 + 7;const double pi = acos(-1);int T, n, m, p, v, k, lim, ans, limit;int a[N], c[N], s[N], rev[N], lst[M];bool tag[M];inline int fpow(int a, int b) { int s = 1; for (; b; b &gt;&gt;= 1, a = (ll)a * a % mod) if (b &amp; 1) s = (ll)s * a % mod; return s;}inline void print(int *a, int l, int r) { for (int i = l; i &lt; r; i++) print(a[i], ' '); puts(\"\");}struct complex { double x, y; inline complex() {} inline complex(double _x, double _y) { x = _x, y = _y; } inline complex operator + (const complex &amp;other) { return complex(x + other.x, y + other.y); } inline complex operator - (const complex &amp;other) { return complex(x - other.x, y - other.y); } inline complex operator * (const complex &amp;other) { return complex(x * other.x - y * other.y, x * other.y + y * other.x); }} w[25][N];void fft(complex *a) { for (int i = 0; i &lt; lim; i++) if (i &lt; rev[i]) std::swap(a[i], a[rev[i]]); for (int len = 1, cnt = 0; len &lt; lim; len &lt;&lt;= 1, cnt++) for (int i = 0; i &lt; lim; i += (len &lt;&lt; 1)) for (int j = 0; j &lt; len; j++) { complex x = a[i + j], y = a[i + j + len] * w[cnt][j]; a[i + j] = x + y, a[i + j + len] = x - y; }}inline void mul(int *f, int *g) { static complex v1(0.5, 0), v2(0, -0.5), v3(0, 1); static complex a[N], b[N], c[N], d[N]; for (int i = 0; i &lt; lim; i++) { a[i].x = f[i] &amp; 32767, a[i].y = f[i] &gt;&gt; 15; c[i].x = g[i] &amp; 32767, c[i].y = g[i] &gt;&gt; 15; } fft(a), fft(c); for (int i = 0, j; i &lt; lim; i++) { j = (lim - 1) &amp; (lim - i); complex A = complex(a[i].x + a[j].x, a[i].y - a[j].y) * v1; complex B = complex(a[i].x - a[j].x, a[i].y + a[j].y) * v2; complex C = complex(c[i].x + c[j].x, c[i].y - c[j].y) * v1; complex D = complex(c[i].x - c[j].x, c[i].y + c[j].y) * v2; b[j] = A * C + A * D * v3, d[j] = B * C + B * D * v3; } fft(b), fft(d), memset(f, 0, lim &lt;&lt; 2); for (int i = 0; i &lt; lim; i++) { ll _1 = b[i].x / lim + 0.5, _2 = b[i].y / lim + d[i].x / lim + 0.5, _3 = d[i].y / lim + 0.5; f[i % v] = (f[i % v] + ((_3 % mod) &lt;&lt; 30) + ((_2 % mod) &lt;&lt; 15) + _1 % mod) % mod; } }int inv(int x) { if (!x || x == 1) return 1; return (ll)(mod - mod / x) * inv(mod % x) % mod;}void main() { for (read(T); T--; ) { ans = k = 0, lim = 1; read(n), read(m), read(p); for (int i = 1; i &lt;= m; i++) read(c[i]); v = c[1]; for (int i = 2; i &lt;= m; i++) v = std::__gcd(v, c[i]); while (lim &lt;= (v &lt;&lt; 1)) lim &lt;&lt;= 1, ++k; for (int i = 0; i &lt; lim; i++) { a[i] = s[i] = 0; rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (k - 1)); w[k][i] = complex(cos(pi * i / lim), sin(pi * i / lim)); } a[0] = 100 - p, a[1 % v] = p, s[0] = 1; for (int i = k - 1, tmp = lim &gt;&gt; 1; ~i; i--, tmp &gt;&gt;= 1) for (int j = 0; j &lt; tmp; j++) w[i][j] = w[i + 1][j &lt;&lt; 1]; for (int b = n; b; b &gt;&gt;= 1, mul(a, a)) if (b &amp; 1) mul(s, a); for (int i = 1; i &lt; v; i++) ans = (ans + (ll)(v - i) * s[i]) % mod; limit = (10000 / v + 1) * v, memset(tag, 0, sizeof(tag)), tag[0] = 1; for (int i = 1; i &lt;= m; i++) for (int j = 0; j + c[i] &lt;= limit; j++) if (tag[j]) tag[j + c[i]] = 1; for (int i = limit; i &gt;= 0; i--) lst[i] = tag[i] ? 0 : lst[i + 1] + 1; for (int i = 0; i &lt;= limit; i++) lst[i] = lst[i] - (i % v ? v - i % v : 0); for (int i = 0, now, C = 1; i &lt;= limit &amp;&amp; i &lt;= n; i++) { if (i) C = (ll)C * (n - i + 1) % mod * inv(i) % mod; if (lst[i]) { now = (ll)C % mod * fpow(p, i) % mod * fpow(100 - p, n - i) % mod; ans = (ans + (ll)now * lst[i]) % mod; } } print(ans, '\\n'); }}} signed main() { return ringo::main(), 0; }","link":"/loj6132/"},{"title":"LOJ6515 - 「雅礼集训 2018 Day10」贪玩蓝月","text":"考虑离线做法，每个物品存在的时间一定是一段连续的区间。建一棵线段树按时间分治，乱搞一下。 考虑在线做法：有一个部分分是只会在一端进行插入删除操作，那么我们开个栈，插入元素就加进去，删除就弹出。复杂度 $ O ( n m ) $ ；既然我们需要在两端操作，那么我们只要维护两个这样的栈即可，查询时把两边的 dp 数组合并。暴力合并是 $ O ( m ^ 2 ) $ 的，会 TLE ，所以我们把一个数组放在线段树上，枚举另一个数组的每一个数，做一下区间查询即可。同时有个问题即有可能在前端删除从后端插入的元素，这种时候我们暴力重构两个栈，各放一半的元素，就能保证复杂度。最后总时间复杂度 $ O (n \\log n \\times m \\log m) $ ，可以通过此题。 由于笔者在做题时把合并的 $ O (m ^ 2) $ 算成了 $ O ( m ) $ 所以去写了在线做法，还好想出了线段树才捡回一条命 233。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141// =================================// author: memset0// date: 2019.01.03 10:25:41// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;#define ll long longnamespace ringo {template &lt;class T&gt; inline void read(T &amp;x) { x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;}template &lt;class T&gt; inline void print(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);}template &lt;class T&gt; inline void print(T x, char c) { print(x), putchar(c); }const int N = 5e4 + 10, M = 500;int n, mod, w, v, l, r, id, c_1, c_2;ll ans, now[M];std::deque &lt;std::pair &lt;int, int&gt; &gt; deque;std::vector &lt;std::pair &lt;int, int&gt; &gt; l_queue, r_queue;inline void maxd(ll &amp;a, ll b) { if (b &gt; a) a = b; }struct stack { int top; ll dp[N][M]; std::pair &lt;int, int&gt; index[N]; inline stack() { memset(dp[0], -1, sizeof(dp[0])); dp[0][0] = 0; } inline int size() { return top; } inline ll* last() { return dp[top]; } inline std::pair &lt;int, int&gt; pop() { return index[top--]; } void push(int w, int v) { index[++top] = std::make_pair(w, v); auto f = dp[top], g = dp[top - 1]; for (int i = 0; i &lt; mod; i++) f[i] = g[i]; for (int i = 0; i &lt; mod; i++) if (~g[i]) maxd(f[(i + w) % mod], g[i] + v); }} L, R;void merge(ll *f, ll *g, ll *ans) { for (int i = 0; i &lt; mod; i++) ans[i] = std::max(f[i], g[i]); for (int i = 0; i &lt; mod; i++) for (int j = 0; j &lt; mod; j++) if (~f[i] &amp;&amp; ~g[j]) maxd(ans[(i + j) % mod], f[i] + g[j]);}void maintain(int flag) { if (L.size() &amp;&amp; R.size()) return; if (!L.size() &amp;&amp; !R.size()) return; while (L.size()) deque.push_back(L.pop()); while (R.size()) deque.push_front(R.pop()); int limit = deque.size() &gt;&gt; 1; if (flag == 0 &amp;&amp; limit == 0) ++limit; if (flag == 1 &amp;&amp; deque.size() - limit == 0) --limit; while (limit--) l_queue.push_back(deque.front()), deque.pop_front(); while (deque.size()) r_queue.push_back(deque.back()), deque.pop_back(); std::reverse(l_queue.begin(), l_queue.end()); std::reverse(r_queue.begin(), r_queue.end()); for (auto i : l_queue) L.push(i.first, i.second); for (auto i : r_queue) R.push(i.first, i.second); l_queue.clear(), r_queue.clear(), deque.clear();}struct node { int l, r, mid; ll max;} p[M &lt;&lt; 2];void build(int u, int l, int r) { p[u].l = l, p[u].r = r, p[u].mid = (l + r) &gt;&gt; 1; if (l == r) return; build(u &lt;&lt; 1, l, p[u].mid); build(u &lt;&lt; 1 | 1, p[u].mid + 1, r);}void modify(int u, int l, int r, ll *a) { if (p[u].l == p[u].r) { p[u].max = a[l]; return; } modify(u &lt;&lt; 1, l, p[u].mid, a); modify(u &lt;&lt; 1 | 1, p[u].mid + 1, r, a); p[u].max = std::max(p[u &lt;&lt; 1].max, p[u &lt;&lt; 1 | 1].max);}ll query(int u, int l, int r) { if (p[u].l == l &amp;&amp; p[u].r == r) return p[u].max; if (r &lt;= p[u].mid) return query(u &lt;&lt; 1, l, r); if (l &gt; p[u].mid) return query(u &lt;&lt; 1 | 1, l, r); return std::max(query(u &lt;&lt; 1, l, p[u].mid), query(u &lt;&lt; 1 | 1, p[u].mid + 1, r));}ll merge(int l, int r, ll *f, ll *g) { modify(1, 0, mod - 1, g); ll ans = -1, another; for (int i = l; i &lt;= r; i++) ans = std::max(ans, std::max(f[i], g[i])); for (int i = 0, _l, _r; i &lt; mod; i++) if (~f[i]) { _l = (l - i + mod) % mod; _r = (r - i + mod) % mod; another = -1; if (_l &lt;= _r) another = query(1, _l, _r); else another = std::max(query(1, 0, _r), query(1, _l, mod - 1)); if (~another) ans = std::max(ans, another + f[i]); } return ans;}void main() { read(id), read(n), read(mod); build(1, 0, mod - 1); for (int i = 1; i &lt;= n; i++) { while (c_1 = getchar(), !isupper(c_1)); while (c_2 = getchar(), !isupper(c_2)); if (c_1 == 'I' &amp;&amp; c_2 == 'F') { read(w), read(v), w %= mod; L.push(w, v); } else if (c_1 == 'I' &amp;&amp; c_2 == 'G') { read(w), read(v), w %= mod; R.push(w, v); } else if (c_1 == 'D' &amp;&amp; c_2 == 'F') { if (!L.size()) maintain(0); L.pop(); } else if (c_1 == 'D' &amp;&amp; c_2 == 'G') { if (!R.size()) maintain(1); R.pop(); } else { read(l), read(r); print(merge(l, r, L.last(), R.last()), '\\n'); } }}} signed main() { return ringo::main(), 0; }","link":"/loj6515/"},{"title":"洛谷1631 - 序列合并（及这一类题目）","text":"先把 $A$ 的第一个数与 $B$ 的每一个相加放堆去，保留所选的数的下标。 此时堆中有 $(1, 1)$ ~ $(n, 1)$。 循环 $n$ 次： 取最小的并输出，假设下标为 $(i, j)$，这个一定和题意 放入 $(i + 1, j)$ 即可。 没有代码。 有一道相关题目 https://www.luogu.org/recordnew/show/10515004 。","link":"/luogu1631/"},{"title":"LOJ6499 - 「雅礼集训 2018 Day2」颜色","text":"并不会正解，此处讲一个可以过此题（而且跑的飞快）的做法。 考虑直接分块，如果对每个块开个 bitset ，这样合并（如果觉得解释的不是很清楚可以点击阅读全文看完整代码 qwq： 12345678910111213void solve(int l, int r) { if (bln[l] == bln[r]) { for (register int i = l; i &lt;= r; i++) ans.set(a[i]); } else { for (register int i = l; i &lt; fst[bln[l] + 1]; i++) ans.set(a[i]); for (register int i = fst[bln[r]]; i &lt;= r; i++) ans.set(a[i]); for (register int i = bln[l] + 1; i &lt;= bln[r] - 1; i++) ans |= f[i]; }} 如果块大小为 $\\sqrt n$ ，那么实际上的复杂度是 $\\frac {n ^ 2 \\sqrt n}{64} $，复杂度其实和暴力差不多。 Dilute: 我™写了个（假）正解分还和暴力一样。 在不会正解的情况下，显然只能考虑在优化分块上做文章。同学基本都是调整块大小为 $7000$ 左右 + 奇技淫巧的卡常通过，此处讲一个不太一样的做法： 考虑使我们的复杂度变的不正确的部分： 12for (register int i = bln[l] + 1; i &lt;= bln[r] - 1; i++) ans |= f[i]; 由于最多会访问到 $\\sqrt n$ 个块，复杂度就不能保证。考虑处理出一个 $pre[i][j]$ 数组，表示std::bitset &lt;N&gt; f[i] 到 std::bitset &lt;N&gt; f[i + j - 1] 的异或和。由于空间限制只有 8MB ，我们只能开约 $480$ 个 std::bitset &lt;N&gt; ，就分成 80 个块，预处理的 $j$ 从 $1$ 到 $8$ 即可。 我们的 txc 哥哥还给了一个非常优秀的常数优化：如果一个数在整个序列里只出现了一次，那么他只要在区间内，对答案的贡献肯定为 $1$（不会因为出现和自己值相同的数而减少）。前缀和处理即可，理论可以少掉一半的常数，Orz. 代码： 最优解被 T 老师抢了也是很快乐呢 qwq。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// =================================// author: memset0// date: 2018.12.25 12:02:14// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;#pragma GCC target(\"avx\")#pragma GCC optimize(3)#pragma GCC optimize(\"Ofast\")#pragma GCC optimize(\"unroll-loops\")#define rep(i, l, r) for (register int i = l; i &lt;= r; i++)namespace ringo {typedef long long ll;typedef unsigned long long ull;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;}template &lt;class T&gt; inline void print(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);}template &lt;class T&gt; inline void maxd(T &amp;a, T b) { if (b &gt; a) a = b; }template &lt;class T&gt; inline void mind(T &amp;a, T b) { if (b &lt; a) a = b; }template &lt;class T&gt; inline void print(T x, char c) { print(x), putchar(c); }template &lt;class T&gt; inline T abs(const T &amp;a) { if (a &lt; 0) return -a; return a; }const int N = 1e5 + 10, M = 59, L = 8;int n, m, l, r, p, sqn, cnt, p_flag, lastans;int a[N], bln[N], fst[M + 10], id[M + 10][M + 10];std::bitset &lt;N&gt; ans, f[478];void main() { read(n), read(m), read(p_flag), sqn = n / M + 1; for (int i = 1; i &lt;= n; i++) read(a[i]); for (int i = 1; i &lt;= n; i++) { bln[i] = (i - 1) / sqn + 1; if (!fst[bln[i]]) fst[bln[i]] = i; } fst[bln[n] + 1] = n + 1; for (int i = 1; i &lt;= bln[n]; i++) { for (int j = i; j &lt; i + L &amp;&amp; j &lt;= bln[n]; j++) id[i][j] = cnt++; for (int j = fst[i]; j &lt; fst[i + 1]; j++) f[id[i][i]].set(a[j]); } for (int i = 1; i &lt;= bln[n]; i++) for (int j = i + 1; j &lt; i + L &amp;&amp; j &lt;= bln[n]; j++) f[id[i][j]] = f[id[i][j - 1]] | f[id[j][j]]; for (int i = 1; i &lt;= m; i++) { ans.reset(), read(p); for (int j = 1; j &lt;= p; j++) { read(l), read(r); if (p_flag &amp;&amp; i != 1) { l = (l ^ lastans) % n + 1; r = (r ^ lastans) % n + 1; if (l &gt; r) std::swap(l, r); } if (bln[l] == bln[r]) { for (int i = l; i &lt;= r; i++) ans.set(a[i]); } else { for (int i = l; i &lt; fst[bln[l] + 1]; i++) ans.set(a[i]); for (int i = fst[bln[r]]; i &lt;= r; i++) ans.set(a[i]); int bl = bln[l] + 1, br = bln[r] - 1; while (bl + L - 1 &lt;= br) ans |= f[id[bl][bl + L - 1]], bl += L; if (bl &lt;= br) ans |= f[id[bl][br]]; } } print(lastans = ans.count(), '\\n'); }}} signed main() { return ringo::main(), 0; }","link":"/loj6499/"},{"title":"LOJ6514 - 「雅礼集训 2018 Day10」文明","text":"本题有虚树做法，基本思想差不多，但个人感觉还是换根树剖清真一点 233。 定义一组询问的根节点为这组询问的一号节点。 一个点会对答案产生贡献，当且仅当这个点到这组节点的其他节点的距离大于等于这个节点到这组询问的根节点的距离。 假设当前我们做到根节点为 $ root $ ，当前节点为 $ u $ 的情况，找出这条路径的中点为 $ mid $ ，那么肯定不会对答案产生贡献的点即整颗树 $ root $ 为根节点时 $ mid $ 这个节点的整颗子树。就是一个简单的换根树剖，乱搞一下即可。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119// =================================// author: memset0// date: 2019.01.03 12:08:20// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;#define ll long longnamespace ringo {template &lt;class T&gt; inline void read(T &amp;x) { x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;}template &lt;class T&gt; inline void print(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);}template &lt;class T&gt; inline void print(T x, char c) { print(x), putchar(c); }const int N = 5e5 + 10;int n, m, u, v, t, rt, cnt, dis, mid, pos, left, right;int fa[N], id[N], top[N], son[N], siz[N], wid[N], dep[N];int tot = 2, hed[N], nxt[N &lt;&lt; 1], to[N &lt;&lt; 1];inline void add_edge(int u, int v) { nxt[tot] = hed[u], to[tot] = v, hed[u] = tot++; nxt[tot] = hed[v], to[tot] = u, hed[v] = tot++;}void dfs1(int u) { siz[u] = 1; for (int i = hed[u], v = to[i]; i; i = nxt[i], v = to[i]) if (v != fa[u]) { fa[v] = u, dep[v] = dep[u] + 1, dfs1(v), siz[u] += siz[v]; if (siz[v] &gt; siz[son[u]]) son[u] = v; }}void dfs2(int u, int toppoint) { top[u] = toppoint, id[u] = ++pos, wid[id[u]] = u; if (siz[u] == 1) return; dfs2(son[u], toppoint); for (int i = hed[u], v = to[i]; i; i = nxt[i], v = to[i]) if (v != fa[u] &amp;&amp; v != son[u]) dfs2(v, v);}struct node { int l, r, mid; int sum, tag;} p[N &lt;&lt; 2];inline void pushup(int u, int x) { p[u].tag = x, p[u].sum = x ? (p[u].r - p[u].l + 1) : 0;}inline void pushdown(int u) { if (p[u].tag == -1 || p[u].l == p[u].r) return; pushup(u &lt;&lt; 1, p[u].tag), pushup(u &lt;&lt; 1 | 1, p[u].tag), p[u].tag = -1;}void build(int u, int l, int r) { p[u].l = l, p[u].r = r, p[u].mid = (l + r) &gt;&gt; 1, p[u].tag = -1; if (l == r) return; build(u &lt;&lt; 1, l, p[u].mid); build(u &lt;&lt; 1 | 1, p[u].mid + 1, r);}void modify(int u, int l, int r, int x) { if (l &gt; r) return; pushdown(u); if (p[u].l == l &amp;&amp; p[u].r == r) return pushup(u, x); if (r &lt;= p[u].mid) modify(u &lt;&lt; 1, l, r, x); else if (l &gt; p[u].mid) modify(u &lt;&lt; 1 | 1, l, r, x); else modify(u &lt;&lt; 1, l, p[u].mid, x), modify(u &lt;&lt; 1 | 1, p[u].mid + 1, r, x); p[u].sum = p[u &lt;&lt; 1].sum + p[u &lt;&lt; 1 | 1].sum;}int lca(int u, int v) { while (top[u] != top[v]) { if (dep[top[u]] &gt; dep[top[v]]) std::swap(u, v); v = fa[top[v]]; } return dep[u] &lt; dep[v] ? u : v;}int jump(int u, int v) { while (dep[u] - dep[top[u]] + 1 &lt;= v) { v -= dep[u] - dep[top[u]] + 1; u = fa[top[u]]; } return wid[id[u] - v];}void main() { read(n), read(m); for (int i = 1; i &lt; n; i++) read(u), read(v), add_edge(u, v); dep[1] = 1, dfs1(1), dfs2(1, 1), build(1, 1, n); for (int i = 1; i &lt;= m; i++) { read(cnt), read(rt), modify(1, 1, n, 1); for (int i = 2; i &lt;= cnt; i++) { read(u), t = lca(rt, u); left = dep[rt] - dep[t] + 1, right = dep[u] - dep[t] + 1; dis = left + right - 1, mid = dis &gt;&gt; 1; if (mid &lt; right) { v = jump(u, mid - 1); modify(1, id[v], id[v] + siz[v] - 1, 0); } else { v = jump(rt, dis - mid - 1); modify(1, 1, id[v] - 1, 0); modify(1, id[v] + siz[v], n, 0); } } print(p[1].sum, '\\n'); }}} signed main() { return ringo::main(), 0; }","link":"/loj6514/"},{"title":"洛谷1251 - 餐巾计划问题","text":"到这题为止网络流 24 题也快刷完了呢，还剩下几道码量特大的等着以后有空去浪费时间（逃 这题一眼最小费用最大流，一开始我想了个类似于 NOI2008 志愿者招募 之类的利用满流的方法，但是一直没有调出来。后来怂了，直接连边，最后因为有个 - 1 没有删干净还是调了老半天。orz ，我还是太菜了。 把每一天分成两个节点，一个接受干净的毛巾，一个输出用过的毛巾。直接在这两个点之间连边显然不现实，我们可以分别把这两个点和源点、汇点连边。然后再按照题目条件一一连上对应边。这样最大流肯定能够跑满，求最小费用的话就是这图的最小费用最大流了。 这告诉我们对于不清楚的知识点不要瞎用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long long#define rep(i,l,r) for (int i = l; i &lt;= r; i++)#define getc(x) getchar(x)#define putc(x) putchar(x)template &lt;typename T&gt; inline void read(T &amp;x) { x = 0; register char ch; register bool fl = 0; while (ch = getc(), ch &lt; 48 || 57 &lt; ch) fl ^= ch == '-'; x = (ch &amp; 15); while (ch = getc(), 47 &lt; ch &amp;&amp; ch &lt; 58) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch &amp; 15); if (fl) x = -x;}template &lt;typename T&gt; inline void print(T x, char c = '\\n') { static int buf[40]; if (x == 0) { putc('0'); return; } if (x &lt; 0) putc('-'), x = -x; for (buf[0] = 0; x; x /= 10) buf[++buf[0]] = x % 10 + 48; while (buf[0]) putc((char) buf[buf[0]--]); putc(c);}const int maxn = 4010, maxe = 50010;const int inf = 1000000000;int n, m, u, v, l, r, s, e, p;int t1, t2, v1, v2, tmp, flow;int a[maxn], pre[maxn], q[maxn], inq[maxn];ll ans, dis[maxn];int tot = 2, hed[maxn], nxt[maxe], to[maxe], val[maxe], cst[maxe];inline void add_simple_edge(int u, int v, int w, int c) { nxt[tot] = hed[u], to[tot] = v; val[tot] = w, cst[tot] = c; hed[u] = tot++;}inline void add_edge(int u, int v, int w, int c) { add_simple_edge(u, v, w, c); add_simple_edge(v, u, 0, -c);}bool spfa() { memset(dis, 127, sizeof(dis)); memset(pre, 0, sizeof(pre)); l = r = 1, q[1] = s, dis[s] = 0, inq[s] = 1; while (l &lt;= r) { u = q[(l++) % (e + 10)], inq[u] = 0; for (int i = hed[u], v = to[i]; i; i = nxt[i], v = to[i]) if (val[i] &amp;&amp; dis[v] &gt; dis[u] + cst[i]) { dis[v] = dis[u] + cst[i]; pre[v] = i; if (!inq[v]) { inq[v] = 1; q[(++r) % (e + 10)] = v; } } } return pre[e];}int main() { read(n), s = (n &lt;&lt; 1) + 1, e = s + 1; for (int i = 1; i &lt;= n; i++) read(a[i]); read(p), read(t1), read(v1), read(t2), read(v2); for (int i = 1; i &lt;= n; i++) add_edge(s, i + n, a[i], 0); for (int i = 1; i &lt;= n; i++) add_edge(i, e, a[i], 0); for (int i = 1; i &lt;= n; i++) add_edge(s, i, inf, p); for (int i = 1; i + t1 &lt;= n; i++) add_edge(i + n, i + t1, inf, v1); for (int i = 1; i + t2 &lt;= n; i++) add_edge(i + n, i + t2, inf, v2); for (int i = 1; i &lt; n; i++) add_edge(i, i + 1, inf, 0); while (spfa()) { flow = inf; for (int i = pre[e]; i; i = pre[to[i ^ 1]]) flow = std::min(flow, val[i]); for (int i = pre[e]; i; i = pre[to[i ^ 1]]) val[i] -= flow, val[i ^ 1] += flow; for (int i = pre[e]; i; i = pre[to[i ^ 1]]) ans += cst[i] * (ll)flow; } print(ans); return 0;}","link":"/luogu1251/"},{"title":"洛谷2051 - [AHOI2009]中国象棋","text":"逐行 DP ，一行一行扫下去，显然之前选择的是那几列不重要，重要的是有多少列已经放了一个棋子，多少列已经放了两个棋子。 用 $f[k][i][j]$ 表示到第 $k$ 行为止，有 $i$ 行放了一个棋子， $j$ 行放了两个棋子的方案数，没放棋子的行数可以由此推出。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;int read() { int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;}const int maxn = 110;const int p = 9999973;int n, m, ans;int f[maxn][maxn][maxn];ll inv2;int C(int x) { return inv2 * x % p * (x - 1) % p; }ll inv(ll x) { if (x == 0 || x == 1) return 1; return (p - p / x) * inv(p % x) % p;}int main() { inv2 = inv(2); n = read(), m = read(); f[0][0][0] = 1; for (int k = 0; k &lt;= n; k++) for (int i = 0; i &lt;= m; i++) for (int j = 0; i + j &lt;= m; j++) { (f[k + 1][i][j] += f[k][i][j]) %= p; (f[k + 1][i + 1][j] += 1LL * f[k][i][j] * (m - i - j) % p) %= p; (f[k + 1][i + 2][j] += 1LL * f[k][i][j] * C(m - i - j) % p) %= p; (f[k + 1][i][j + 1] += 1LL * f[k][i][j] * (m - i - j) % p * i % p) %= p; (f[k + 1][i - 1][j + 1] += 1LL * f[k][i][j] * i % p) %= p; (f[k + 1][i - 2][j + 2] += 1LL * f[k][i][j] * C(i) % p) %= p; } for (int i = 0; i &lt;= m; i++) for (int j = 0; i + j &lt;= m; j++) (ans += f[n][i][j]) %= p; printf(\"%d\\n\", ans); return 0;}","link":"/luogu2051/"},{"title":"洛谷1979 - 华容道","text":"一道经典的搜索题。由于棋子没必要也不可能和非空格的棋子交换，目标棋子也只可能通过与空格交换位置达到目标位置，因此我们只需要存储空格和目标棋子的位置即可。这样爆搜即可拿到 $80$ 分。 接着考虑能否继续优化：每次目标棋子改变位置空格必须在他旁边，因此存储除了初始状态和终止状态外的空格不在目标棋子旁边的状态没有意义。因此我们可以用 BFS 处理出状态之间转移的代价，然后用 SPFA 等最短路算法跑一遍即可。本题由于状态个数和状态之间的边不多，正常常数的 SPFA 不会被卡掉。 需要注意的是：在使用 BFS 搜索空格转移代价时不能经过目标棋子。算法时间复杂度：$O(n^4)$ 代码（出于某些原因我写的比较长，其实很短的 QAQ）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;int read() { int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;}namespace wyl { const int maxn = 32; const int mov[4][2] = { {1, 0}, {-1, 0}, {0, 1}, {0, -1}, }; int n, m, p, u, v, l, r; int x, y, x1, x2, y1, y2; int s, e, sx, sy, ex, ey, tx, ty; int pos; int a[35][35], id[35][35][35][35], dis[1000000]; int q[10000000]; bool inq[1000000], vis[35][35]; struct status { int x, y, stp; status () {} status (int a, int b, int c) { x = a, y = b, stp = c; } } q0[10000000]; int tot = 2, tmptot, hed[1000000], tmphed[1000000], to[8000000], nxt[8000000], val[8000000]; void add_edge(int u, int v, int w) { if (!~w) return; nxt[tot] = hed[u], to[tot] = v, val[tot] = w; hed[u] = tot++; } int bfs(int sx, int sy, int ex, int ey, int kx, int ky) { if (sx == ex &amp;&amp; sy == ey) return 0; status u, v; memset(vis, 0, sizeof(vis)); l = r = 1; q0[1] = status(sx, sy, 0); vis[sx][sy] = vis[kx][ky] = 1; while (l &lt;= r) { u = q0[l++]; for (int t = 0; t &lt; 4; t++) { v.x = u.x + mov[t][0]; v.y = u.y + mov[t][1]; v.stp = u.stp + 1; if ((!a[v.x][v.y]) &amp;&amp; !vis[v.x][v.y]) { if (v.x == ex &amp;&amp; v.y == ey) { return v.stp; } vis[v.x][v.y] = 1; q0[++r] = v; } } } return -1; } int spfa(int s, int e) { memset(dis, -1, sizeof(dis)); l = r = 1, q[1] = s, dis[s] = 0, inq[s] = 1; while (l &lt;= r) { u = q[l++], inq[u] = 0; for (int i = hed[u]; i; i = nxt[i]) { int v = to[i]; if (!~dis[v] || dis[v] &gt; dis[u] + val[i]) { dis[v] = dis[u] + val[i]; if (!inq[v]) { q[++r] = v; inq[v] = 1; } } } } return dis[e]; } int main() { n = read(), m = read(), p = read(); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) a[i][j] = read() ^ 1; for (int i = 0; i &lt;= n + 1; i++) a[i][0] = a[i][m + 1] = 1; for (int i = 0; i &lt;= m + 1; i++) a[0][i] = a[n + 1][i] = 1; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) if (!a[i][j]) { for (int t = 0; t &lt; 4; t++) { x = i + mov[t][0]; y = j + mov[t][1]; if (!a[x][y]) { id[i][j][x][y] = ++pos; } } } for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) if (!a[i][j]) { for (int t = 0; t &lt; 4; t++) { x = i + mov[t][0]; y = j + mov[t][1]; if (!a[x][y]) add_edge(id[i][j][x][y], id[x][y][i][j], 1); } for (int t1 = 0; t1 &lt; 4; t1++) { x1 = i + mov[t1][0]; y1 = j + mov[t1][1]; if (!a[x1][y1]) for (int t2 = 0; t2 &lt; 4; t2++) if (t1 ^ t2) { x2 = i + mov[t2][0]; y2 = j + mov[t2][1]; if (!a[x2][y2]) add_edge(id[i][j][x1][y1], id[i][j][x2][y2], bfs(x1, y1, x2, y2, i, j)); } } } tmptot = tot; memcpy(tmphed, hed, sizeof(hed)); while (p--) { tot = tmptot; memcpy(hed, tmphed, sizeof(hed)); tx = read(), ty = read(), sx = read(), sy = read(), ex = read(), ey = read(); s = ++pos, e = ++pos; if (sx == ex &amp;&amp; sy == ey) { puts(\"0\"); continue; } for (int t = 0; t &lt; 4; t++) { x = sx + mov[t][0]; y = sy + mov[t][1]; if (id[sx][sy][x][y]) { add_edge(s, id[sx][sy][x][y], bfs(tx, ty, x, y, sx, sy)); } } for (int t = 0; t &lt; 4; t++) { x = ex + mov[t][0]; y = ey + mov[t][1]; if (id[ex][ey][x][y]) { add_edge(id[ex][ey][x][y], e, 0); } } printf(\"%d\\n\", spfa(s, e)); pos -= 2; } return 0; }} int main() { return wyl::main();}","link":"/luogu1979/"},{"title":"洛谷2325 - [SCOI2005]王室联邦","text":"给树分块即可，为树上分块 / 树上莫队做铺垫。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longint read() { int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;}const int maxn = 1010;int n, m, u, v, pos, top;int ans[maxn], stk[maxn], center[maxn];int tot = 2, hed[maxn], nxt[maxn &lt;&lt; 1], to[maxn &lt;&lt; 1];void add_edge(int u, int v) { nxt[tot] = hed[u], to[tot] = v, hed[u] = tot++; }void dfs(int u, int father) { int bottom = top; for (int i = hed[u], v = to[i]; i; i = nxt[i], v = to[i]) if (v != father) { dfs(v, u); if (top - bottom &gt;= m) { ++pos, center[pos] = u; while (top &gt; bottom) { int v = stk[top--]; ans[v] = pos; } } } stk[++top] = u;}int main() { n = read(), m = read(); for (int i = 1; i &lt; n; i++) { u = read(), v = read(); add_edge(u, v); add_edge(v, u); } dfs(1, 0); if (top) { while (top) { int v = stk[top--]; ans[v] = pos; } } printf(\"%d\\n\", pos); for (int i = 1; i &lt;= n; i++) printf(\"%d \", ans[i]); puts(\"\"); for (int i = 1; i &lt;= pos; i++) printf(\"%d \", center[i]); puts(\"\"); return 0;}","link":"/luogu2325/"},{"title":"洛谷2600 - [ZJOI2008]瞭望塔","text":"三分即可。calc(x, y)函数求在点 $(x, y)$ 建造灯塔的最低高度。 时间复杂度 $O(n ^ 2 \\times \\texttt{某个大常数})$ 。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;int read() { int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;}const int maxn = 310;int n;double mid, ans = 1e200, lbound, rbound, lmid, rmid;double x[maxn], y[maxn], k[maxn], b[maxn];double calc(double x, double y) { double ans = 0; for (int i = 1; i &lt; n; i++) ans = max(ans, x * k[i] + b[i] - y); return ans;}int main() { scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) scanf(\"%lf\", &amp;x[i]); for (int i = 1; i &lt;= n; i++) scanf(\"%lf\", &amp;y[i]); for (int i = 1; i &lt; n; i++) { k[i] = (y[i + 1] - y[i]) / (x[i + 1] - x[i]); b[i] = y[i] - x[i] * k[i]; } for (int i = 1; i &lt; n; i++) { lbound = x[i]; rbound = x[i + 1]; for (int t = 100; t; t--) { lmid = lbound + (rbound - lbound) / 3; rmid = rbound - (rbound - lbound) / 3; if (calc(lmid, lmid * k[i] + b[i]) &lt; calc(rmid, rmid * k[i] + b[i])) rbound = rmid; else lbound = lmid; } mid = (lbound + rbound) / 2; ans = min(ans, calc(mid, mid * k[i] + b[i])); } printf(\"%.3lf\\n\", ans); return 0;}","link":"/luogu2600/"},{"title":"洛谷2387 - [NOI2014]魔法森林","text":"题意可以理解为找到一条 $1$ 到 $n$ 的路径，使得其中 $a$ 的最大值和 $b$ 的最大值之和最小。 我们可以先按照 $a$ 的值排序，然后使用 LCT 维护关于 $b$ 的最小生成树；算法的正确性很容易证明：对于每一个 $a$ 的最大值我们都取到了 $b$ 的最大值的最小值。 维护动态最小生成树：对于新加的边 $(u, v)$ ，如果已经连接，则需要断掉其中最大的一条（当前的 $b$ 值比最大的 $b$ 值还大就不用加了），否则无脑 link 。所以我们的 LCT 还要存储下最大的边以及对应的编号。 由于 LCT 只能维护点不能维护边，我们可以考虑化边为点，总共有 $n$ 个 LCT 中的点表示实际意义的点，以及 $m$ 的 LCT 中的点表示实际意义的边。这样子瞎搞即可。 注意一定要当 $1$ 和 $n$ 已经联通时才能用当前的状态尝试更新答案哦！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longint read() { int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;}const int maxn = 50010, maxm = 100010, maxp = 150010;int n, m, u, v, a, b, t, ans = 1e9;int fa[maxp], ch[maxp][2], max[maxp], pto[maxp], lazy[maxp], val[maxp];struct edge { int u, v, a, b;} g[maxm];bool cmp(edge a, edge b) { return a.a &lt; b.a;}bool is_root(int x) { return ch[fa[x]][0] != x &amp;&amp; ch[fa[x]][1] != x; }bool get_son(int x) { return ch[fa[x]][1] == x; }void update(int x) { max[x] = val[x], pto[x] = x; if (ch[x][0] &amp;&amp; max[pto[ch[x][0]]] &gt; max[pto[x]]) pto[x] = pto[ch[x][0]]; if (ch[x][1] &amp;&amp; max[pto[ch[x][1]]] &gt; max[pto[x]]) pto[x] = pto[ch[x][1]];}void rotate(int x) { if (!x || !fa[x]) return; int f = fa[x], fson = get_son(x); int ff = fa[f], ffson = get_son(f); int y = ch[x][fson ^ 1]; if (!is_root(f)) ch[ff][ffson] = x; fa[y] = f, fa[f] = x, fa[x] = ff; ch[f][fson] = y, ch[x][fson ^ 1] = f; update(f), update(x);}void clean_up(int x) { if (!is_root(x)) clean_up(fa[x]); if (lazy[x]) { std::swap(ch[x][0], ch[x][1]); lazy[ch[x][0]] ^= 1; lazy[ch[x][1]] ^= 1; lazy[x] = 0; }}void splay(int x) { clean_up(x); while (!is_root(x)) { int f = fa[x]; if (!is_root(f)) { if (get_son(x) ^ get_son(f)) rotate(x); else rotate(f); } rotate(x); } update(x);}void access(int x) { for (int y = 0; x; y = x, x = fa[x]) splay(x), ch[x][1] = y, update(x);}void mroot(int x) { access(x), splay(x); lazy[x] ^= 1;}void select(int u, int v) { mroot(u), access(v), splay(v);}int get_root(int x) { access(x), splay(x); while (ch[x][0]) x = ch[x][0]; return x;}void link(int u, int v) { mroot(u); fa[u] = v;}void cut(int u, int v) { select(u, v); fa[u] = ch[v][0] = 0; update(v);}int main() { n = read(), m = read(); for (int i = 1; i &lt;= m; i++) { g[i].u = read(), g[i].v = read(); g[i].a = read(), g[i].b = read(); } std::sort(g + 1, g + m + 1, cmp); for (int i = 1; i &lt;= m; i++) val[n + i] = g[i].b; for (int i = 1; i &lt;= m; i++) { u = g[i].u, v = g[i].v; a = g[i].a, b = g[i].b; if (get_root(u) == get_root(v)) { select(u, v), t = pto[v]; if (max[t] &gt; b) { cut(g[t - n].u, t); cut(t, g[t - n].v); link(u, i + n); link(i + n, v); } } else { link(u, i + n); link(i + n, v); } if (get_root(1) == get_root(n)) { select(1, n); ans = std::min(ans, a + max[pto[n]]); } } printf(\"%d\\n\", ans == 1e9 ? -1 : ans); return 0;}","link":"/luogu2387/"},{"title":"洛谷2787 - 语文1（chin1）- 理理思维","text":"为什么这题的名字这么奇怪？为什么这题的题解都是分块？ 好，我们讲怎么用线段树做：首先先把 $1$ 和 $2$ 两个操作用线段树维护出来（这很简单），至于排序我们直接统计区间内每个字母的数量（用操作 $1$ ），然后再直接放回去即可（用操作 $2$ ）。 以及这题大小写字母都会出现，无视即可。 时间复杂度 $O(n \\log n \\times 26)$ 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longint read() { int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;}int readc() { char c = getchar(); while (!isupper(c) &amp;&amp; !islower(c)) c = getchar(); if (isupper(c)) return c - 'A'; return c - 'a';}const int maxn = 50010;int n, m, l, r, x, opt;int a[maxn], sum[26];struct seg_node { int l, r, mid; int cnt[26], tag;} p[maxn &lt;&lt; 2];inline void update(int u) { for (int i = 0; i &lt; 26; i++) p[u].cnt[i] = p[u &lt;&lt; 1].cnt[i] + p[u &lt;&lt; 1 | 1].cnt[i];}inline void pushup(int u, int x) { memset(p[u].cnt, 0, sizeof(p[u].cnt)); p[u].cnt[x] = p[u].r - p[u].l + 1; p[u].tag = x;}inline void pushdown(int u) { if (~p[u].tag) { if (p[u].l ^ p[u].r) { pushup(u &lt;&lt; 1, p[u].tag); pushup(u &lt;&lt; 1 | 1, p[u].tag); } p[u].tag = -1; }}void build(int u, int l, int r) { p[u].l = l, p[u].r = r, p[u].mid = (l + r) &gt;&gt; 1; p[u].tag = -1; if (l == r) { p[u].cnt[a[l]]++; return; } build(u &lt;&lt; 1, l, p[u].mid); build(u &lt;&lt; 1 | 1, p[u].mid + 1, r); update(u);}void modify(int u, int l, int r, int x) { pushdown(u); if (p[u].l == l &amp;&amp; p[u].r == r) { pushup(u, x); return; } if (r &lt;= p[u].mid) modify(u &lt;&lt; 1, l, r, x); else if (l &gt; p[u].mid) modify(u &lt;&lt; 1 | 1, l, r, x); else modify(u &lt;&lt; 1, l, p[u].mid, x), modify(u &lt;&lt; 1 | 1, p[u].mid + 1, r, x); update(u);}int query(int u, int l, int r, int x) { pushdown(u); if (p[u].l == l &amp;&amp; p[u].r == r) return p[u].cnt[x]; if (r &lt;= p[u].mid) return query(u &lt;&lt; 1, l, r, x); else if (l &gt; p[u].mid) return query(u &lt;&lt; 1 | 1, l, r, x); else return query(u &lt;&lt; 1, l, p[u].mid, x) + query(u &lt;&lt; 1 | 1, p[u].mid + 1, r, x);}void sort(int l, int r) { for (int i = 0; i &lt; 26; i++) sum[i] = query(1, l, r, i); int u = l; for (int i = 0; i &lt; 26; i++) { if (sum[i]) modify(1, u, u + sum[i] - 1, i); u = u + sum[i]; }}int main() { n = read(), m = read(); for (int i = 1; i &lt;= n; i++) a[i] = readc(); build(1, 1, n); for (int i = 1; i &lt;= m; i++) { opt = read(), l = read(), r = read(); if (opt == 1) { x = readc(), printf(\"%d\\n\", query(1, l, r, x)); continue; } if (opt == 2) { x = readc(), modify(1, l, r, x); continue; } if (opt == 3) { sort(l, r); continue; } } return 0;}","link":"/luogu2787/"},{"title":"洛谷2962 - 灯","text":"一道非常神奇的题目。 尽管洛谷题解给的都是高斯消元，但实际上这题“普通”的DFS就可以AC。 因为直接DFS一遍的复杂度高达 $O(2 ^ n)$ ，所以我们从两边开始搜索，并把状态存在map里，复杂度降低为 $O(n \\times 2 ^ {\\frac{n}{2}})$ ，可以水过此题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;#define isnum(c) ('0' &lt;= c &amp;&amp; c &lt;= '9')#define read(x) do {\\ R::c = getchar(); R::m = 0; x = 0;\\ while (!isnum(R::c) &amp;&amp; R::c != '-') R::c = getchar();\\ if (R::c == '-') R::c = getchar(), R::m = 1;\\ while (isnum(R::c)) x = x * 10 + R::c - '0', R::c = getchar();\\ if (R::m) x = -x;\\} while(false)namespace R { char c; bool m; }using namespace std;const int maxn = 40;int n, m, lim, ans, l, r, tx, ty;long long a[maxn], check[maxn], FULL_STACK;bool found, vis[maxn], G[maxn][maxn];map &lt; long long, int &gt; Map;void reader() { read(n); read(m); for (int i = 1; i &lt;= n; i++) G[i][i] = 1; for (int i = 1; i &lt;= m; i++) { read(tx); read(ty); G[tx][ty] = 1; G[ty][tx] = 1; } }void printer(long long x) { for (int i = 1; i &lt;= n; i++) if (check[i] &amp; x) putchar('1'); else putchar('0'); printf(\"(%lld)\", x); putchar('\\n'); }void DFS1(int u, long long pin, int step) { if (u &gt; lim) return ; if (Map.find(pin) != Map.end()) Map[pin] = min(Map[pin], step); else Map[pin] = step; DFS1(u + 1, pin, step); DFS1(u + 1, pin ^ a[u + 1], step + 1);}void DFS2(int u, long long pin, int step) { if (u &gt; n) return ; if (Map.find(FULL_STACK ^ pin) != Map.end()) ans = min(ans, step + Map[FULL_STACK ^ pin]); DFS2(u + 1, pin, step); DFS2(u + 1, pin ^ a[u + 1], step + 1);}int main() { reader(); ans = n; for (int i = 1; i &lt;= n; i++) { for (int j = n; j &gt; 0; j--) if (G[i][j]) a[i] = a[i] &lt;&lt; 1 | 1; else a[i] = a[i] &lt;&lt; 1; } FULL_STACK = check[1] = 1; for (int i = 2; i &lt;= n; i++) { FULL_STACK = FULL_STACK &lt;&lt; 1 | 1; check[i] = (check[i - 1] &lt;&lt; 1); } lim = (n + 1) &gt;&gt; 1; DFS1(0, 0, 0); DFS2(lim, 0, 0); printf(\"%d\\n\", ans); return 0;}","link":"/luogu2962/"},{"title":"洛谷2783 - 有机化学之神偶尔会做作弊","text":"又是一道非常水的黑题。给你一个双向图，你需要代替炎魔之王拉格纳罗斯（？？？）会净化图中的所有环，也就是除了链以外的强连通分量，成为一颗无根树。然后询问树上距离。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;int read() { int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;}const int maxn = 10010, maxm = 50010;int n, m, q, u, v;int tim, pos, top;int dfn[maxn], low[maxn], id[maxn], stk[maxn], f[maxn][20], dep[maxn];bool ins[maxn];int tot = 2, hed[maxn], nxt[maxm &lt;&lt; 1], to[maxm &lt;&lt; 1];struct edge { int u, v; edge () {} edge (int a, int b) { u = a, v = b; }} e[maxm];void tarjan(int u, int fa) { dfn[u] = low[u] = ++tim; stk[++top] = u, ins[u] = 1; for (int i = hed[u]; i; i = nxt[i]) { int v = to[i]; if (v == fa) continue; if (!dfn[v]) { tarjan(v, u); low[u] = min(low[u], low[v]); } else if (ins[v]) { low[u] = min(low[u], dfn[v]); } } if (dfn[u] == low[u]) { ++pos; while (top) { int v = stk[top--]; id[v] = pos; if (u == v) break; } }}void dfs(int u) { for (int i = hed[u]; i; i = nxt[i]) { int v = to[i]; if (v != f[u][0] &amp;&amp; !dep[v]) { f[v][0] = u; dep[v] = dep[u] + 1; dfs(v); } }}int lca(int u, int v) { if (dep[u] &gt; dep[v]) swap(u, v); for (int i = 19; i &gt;= 0; i--) if (dep[f[v][i]] &gt;= dep[u] &amp;&amp; f[v][i]) v = f[v][i]; if (u == v) return u; for (int i = 19; i &gt;= 0; i--) if (f[u][i] != f[v][i] &amp;&amp; f[u][i] &amp;&amp; f[v][i]) u = f[u][i], v = f[v][i]; return f[u][0];}void print(int x) { if (x &gt; 1) print(x &gt;&gt; 1); putchar((x &amp; 1) + '0');}int main() { n = read(), m = read(); for (int i = 1; i &lt;= m; i++) { u = read(), v = read(); e[i] = edge(u, v); nxt[tot] = hed[u], to[tot] = v, hed[u] = tot++; nxt[tot] = hed[v], to[tot] = u, hed[v] = tot++; } for (int i = 1; i &lt;= n; i++) if (!dfn[i]) tarjan(i, -1); tot = 2, memset(hed, 0, sizeof(hed)); for (int i = 1; i &lt;= m; i++) { u = id[e[i].u], v = id[e[i].v]; if (u ^ v) { nxt[tot] = hed[u], to[tot] = v, hed[u] = tot++; nxt[tot] = hed[v], to[tot] = u, hed[v] = tot++; } } dep[1] = 1, dfs(1); for (int i = 1; i &lt; 20; i++) for (int j = 1; j &lt;= pos; j++) f[j][i] = f[f[j][i - 1]][i - 1]; q = read(); for (int i = 1; i &lt;= q; i++) { u = id[read()], v = id[read()]; print(dep[u] + dep[v] - (dep[lca(u, v)] &lt;&lt; 1) + 1); putchar('\\n'); } return 0;}","link":"/luogu2783/"},{"title":"洛谷2050 - [NOI2012]美食节","text":"网络流裸题，没什么好说的。需要注意的是，我们在给厨师拆点的时候，如果先把边都连好，时间是会炸掉的。所以我们就没“用掉”一个厨师新建一次点即可。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// =================================// author: memset0// date: 2019.01.28 17:19:06// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;#define ll long longnamespace ringo {template &lt;class T&gt; inline void read(T &amp;x) { x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;}template &lt;class T&gt; inline void print(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);}template &lt;class T&gt; inline void print(T x, char c) { print(x), putchar(c); }const int N = 50, M = 110, P = 810, Nd = 80110, Ed = 2e7 + 10;int n, m, s, e, cnt, ans, sum, cos;int a[N], w[N][M], at[N], id[M][P], pre[Nd], dis[Nd], vis[Nd], lst[M], bln[Nd];int tot = 2, hed[Nd], nxt[Ed], to[Ed], val[Ed], cst[Ed];inline void add(int u, int v, int w, int c) { nxt[tot] = hed[u], to[tot] = v, val[tot] = w, cst[tot] = c, hed[u] = tot++; nxt[tot] = hed[v], to[tot] = u, val[tot] = 0, cst[tot] = -c, hed[v] = tot++;}bool spfa() { for (int i = 1; i &lt;= cnt; i++) pre[i] = 0, dis[i] = 0x3f3f3f3f; static int q[Nd], l, r, u; vis[q[l = r = 1] = s] = 1, dis[s] = 0; while (l &lt;= r) { vis[u = q[(l++) % Nd]] = 0; for (int i = hed[u], v = to[i]; i; i = nxt[i], v = to[i]) if (val[i] &amp;&amp; dis[u] + cst[i] &lt; dis[v]) { dis[v] = dis[u] + cst[i], pre[v] = i; if (!vis[v]) vis[q[(++r) % Nd] = v] = 1; } } return pre[e];}void main() { read(n), read(m), s = ++cnt, e = ++cnt; for (int i = 1; i &lt;= n; i++) read(a[i]), at[i] = ++cnt, sum += a[i]; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) read(w[i][j]); for (int i = 1; i &lt;= n; i++) add(s, at[i], a[i], 0); for (int i = 1; i &lt;= m; i++) for (int j = 1; j &lt;= sum; j++) id[i][j] = ++cnt, bln[cnt] = i; for (int i = 1; i &lt;= m; i++) { add(id[i][lst[i] = 1], e, 1, 0); for (int j = 1; j &lt;= n; j++) add(at[j], id[i][1], 1, w[j][i]); } for (int t = 1; t &lt;= sum; t++) { spfa(); for (int i = pre[e]; i; i = pre[to[i ^ 1]]) --val[i], ++val[i ^ 1], ans += cst[i]; cos = bln[to[pre[e] ^ 1]]; add(id[cos][++lst[cos]], e, 1, 0); for (int i = 1; i &lt;= n; i++) add(at[i], id[cos][lst[cos]], 1, lst[cos] * w[i][cos]); } print(ans, '\\n');}} signed main() { return ringo::main(), 0; }","link":"/luogu2050/"},{"title":"洛谷2996 - 拜访奶牛","text":"首先，这题无法用贪心实现，下面是一个反例： 贪心的话最大值是 $5$，然而可以在中途放弃一个点从而取到最大值 $6$ 。 我们使用 $f[i][0]$ 来表示到第 $i$ 个点但不取这个点所能获得的最大值，用 $f[i][1]$ 表示到第 $i$ 个点且取这个点所能获得的最大值。 先将每个点都DFS遍历一遍，在回溯时进行DP（ $u$ 是当前节点，$G[u][i]$ 是孩子节点）： 如果当前节点不选，那么孩子节点选或不选均可$f[u][0] += max(f[G[u][i]][0], f[G[u][i]][1]) $ 如果当前节点选中，那么孩子节点只能不选$f[u][1] += f[G[u][i]][0] $ 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;#define isnum(c) ('0' &lt;= c &amp;&amp; c &lt;= '9')#define read(x) do {\\ char c = getchar(); bool m = 0; x = 0;\\ while (!isnum(c) &amp;&amp; c != '-') c = getchar();\\ if (c == '-') c = getchar(), m = 1;\\ while (isnum(c)) x = x * 10 + c - '0', c = getchar();\\ if (m) x = -x;\\} while(false) //宏定义快读using namespace std;const int maxn = 50010;int n, tx, ty, a[maxn], tag[maxn], f[maxn][2];vector &lt; int &gt; G[maxn];void DFS(int u) { tag[u] = 1; f[u][1] = 1; for (int i = 0; i &lt; G[u].size(); i++) if (!tag[G[u][i]]) { //没有打上tag标记说明是孩子节点 DFS(G[u][i]); f[u][0] += max(f[G[u][i]][0], f[G[u][i]][1]); f[u][1] += f[G[u][i]][0]; }}int main() { read(n); for (int i = 1; i &lt; n; i++) { read(tx); read(ty); G[tx].push_back(ty); G[ty].push_back(tx); } DFS(1); printf(\"%d\\n\", max(f[1][0], f[1][1])); return 0;}","link":"/luogu2996/"},{"title":"洛谷2606 - [ZJOI2010] 排列计数","text":"原问题等价于询问节点个数为 $ n $ 的完全二叉树形态的二叉堆的个数。 考虑递推，用 $ f(i) $ 表示 $ i $ 个节点时的答案。考虑除去此时的根节点外，根的左右子树大小分别为 $ l $ 和 $ r $ （可由完全二叉树这一性质计算得出）。此时根节点的编号肯定为 $ 1 $ ，而 $ f(l) $ 和 $ f(r) $ 分别是子树中的根节点编号为 $ 1 $ 的情况，若把编号分配，相当于求两个有序数列并成一个的方案数，即 $ C _ { l + r} ^ l $。得出： $$ f(i) = f(l) \\times f(r) \\times C _ { l + r } ^ l $$ 预处理阶乘递推即可。若 $ n &gt; q $ 则需要卢卡斯定理简单处理。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// =================================// author: memset0// date: 2018.12.07 13:51:11// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;namespace ringo {typedef long long ll;template &lt; class T &gt;inline void read(T &amp;x) { x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;}template &lt; class T &gt;inline void print(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);}template &lt; class T &gt;inline void print(T x, char c) { print(x), putchar(c);}const int N = 1e6 + 10;int n, p, l, r, t;int fac[N], inv[N], ans[N], lg2[N];int c(int n, int m) { return (ll)fac[n] * inv[m] % p * inv[n - m] % p; }int lucas(int n, int m) { return m ? (ll)c(n % p, m % p) * lucas(n / p, m / p) % p : 1; }void main() { read(n), read(p); fac[0] = inv[0] = inv[1] = 1; for (int i = 1; i &lt;= std::min(n, p); i++) fac[i] = (ll)fac[i - 1] * i % p; for (int i = 2; i &lt;= std::min(n, p); i++) inv[i] = (ll)(p - p / i) * inv[p % i] % p; for (int i = 1; i &lt;= std::min(n, p); i++) inv[i] = (ll)inv[i] * inv[i - 1] % p; for (int i = 1; (1 &lt;&lt; i) &lt;= n + 1; i++) lg2[1 &lt;&lt; i] = i; for (int i = 1; i &lt;= n + 1; i++) lg2[i] = lg2[lg2[i] ? i : i - 1]; ans[0] = 1; for (int i = 1; i &lt;= n; i++) { t = lg2[i + 1], l = std::min((1 &lt;&lt; t) - 1, i - (1 &lt;&lt; (t - 1))), r = i - 1 - l; ans[i] = (ll)lucas(i - 1, l) * ans[l] % p * ans[r] % p; } print(ans[n], '\\n');}} signed main() { return ringo::main(), 0; }","link":"/luogu2606/"},{"title":"洛谷3285 - [SCOI2014]方伯伯的OJ","text":"本题的 $n$ 特别大，如果直接开那么大的空间，想必会直接超时。所以我们可以先把所有“用户”合并成一个点，需要访问到哪个就进行分裂。这样的话 $m$ 次操作每次都只会分裂一次，时间复杂度就能保证在 $O(m\\log m)$ ，空间也不会炸。 另外本题只有提到最前面和提到最后面两种操作，使用平衡树的必要不大，用动态开点线段树就好了。 p.s. 感觉 Leafy Tree 和这个好像啊 (=’w’​=) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longint read() { int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;}const int maxn = 100010;int n, m, x, y, k, u, cnt, opt, tmp, last, left_side, right_side;std::map &lt; int, int &gt; mp;struct node { int value, size; node *l, *r; node() { value = size = 0; l = r = NULL; } node (int a, int b, node *c, node *d) { value = a, size = b; l = c, r = d; }} *root, *null, *st[maxn &lt;&lt; 6], t[maxn &lt;&lt; 6];int get_size(int l, int r) { return std::max(std::min(r, n) - std::max(1, l) + 1, 0);}node *newnode(int l, int r) { cnt++; if (l == r) t[cnt] = node(l, (1 &lt;= l &amp;&amp; l &lt;= n ? 1 : 0), null, null); else t[cnt] = node(0, get_size(l, r), null, null); return st[cnt] = &amp;t[cnt];}int query(int k, int l, int r, node *&amp;u) { if (u == null) u = newnode(l, r); if (l == r) return u-&gt;value; int mid = (l + r) &gt;&gt; 1; int left_size = (u-&gt;l == null) ? get_size(l, mid) : u-&gt;l-&gt;size; if (k &lt;= left_size) return query(k, l, mid, u-&gt;l); return query(k - left_size, mid + 1, r, u-&gt;r);}int rank(int x, int l, int r, node *&amp;u) { if (u == null) u = newnode(l, r); if (l == r) return 1; int mid = (l + r) &gt;&gt; 1; if (x &lt;= mid) return rank(x, l, mid, u-&gt;l); return rank(x, mid + 1, r, u-&gt;r) + ((u-&gt;l == null) ? get_size(l, mid) : u-&gt;l-&gt;size);}void modify(int x, int y, int l, int r, node *&amp;u) { if (u == null) u = newnode(l, r); if (l == r) { u-&gt;value = y; return; } int mid = (l + r) &gt;&gt; 1; if (x &lt;= mid) modify(x, y, l, mid, u-&gt;l); else modify(x, y, mid + 1, r, u-&gt;r);}void update(int x, int y, int z, int l, int r, node *&amp;u) { if (u == null) u = newnode(l, r); u-&gt;size += y; if (l == r) { u-&gt;value = z; return; } int mid = (l + r) &gt;&gt; 1; if (x &lt;= mid) update(x, y, z, l, mid, u-&gt;l); else update(x, y, z, mid + 1, r, u-&gt;r);}int main() { n = read(), m = read(); for (int i = 0; i &lt; (maxn &lt;&lt; 6); i++) st[i] = &amp;t[i]; null = new node(0, 0, null, null); root = new node(0, n, null, null); left_side = 1, right_side = n; for (int i = 1; i &lt;= m; i++) { opt = read(); if (opt == 1) { x = read() - last, y = read() - last; k = mp.find(x) != mp.end() ? mp[x] : x; printf(\"%d\\n\", last = rank(k, -m, n + m, root)); modify(k, y, -m, n + m, root); mp.erase(x), mp[y] = k; } else if (opt == 2) { x = read() - last, k = mp.find(x) != mp.end() ? mp[x] : x; printf(\"%d\\n\", last = rank(k, -m, n + m, root)); update(k, -1, -1, -m, n + m, root); update(mp[x] = --left_side, 1, x, -m, n + m, root); } else if (opt == 3) { x = read() - last, k = mp.find(x) != mp.end() ? mp[x] : x; printf(\"%d\\n\", last = rank(k, -m, n + m, root)); update(k, -1, -1, -m, n + m, root); update(mp[x] = ++right_side, 1, x, -m, n + m, root); } else if (opt == 4) { k = read() - last; printf(\"%d\\n\", last = query(k, -m, n + m, root)); } } return 0;}","link":"/luogu3285/"},{"title":"洛谷2921 - 在农场万圣节","text":"可以看做一张有n个节点的图，每个节点有且仅有一条向外连接的边（可以连自己）。那么图中只可能是环与链的组合。而且链的终点是环，进入环后就不会从环中出去，故一个链只可能接一个环，一个环只可能被一或多的链接。 故我们可以把整个分隔为一个个的环，并把接到他们的链找出来。 环内节点的答案 = 环的长度； 环外节点的答案 = 环的长度 + 当前节点到环的距离。 几趟 $O(n)$ 的搜索就可以搞定问题！ 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;#define isnum(c) ('0' &lt;= c &amp;&amp; c &lt;= '9')#define read(x) { \\ x = 0, rd::c = getchar(), rd::m = 0; \\ while (!isnum(rd::c) &amp;&amp; rd::c != '-') rd::c = getchar(); \\ if (rd::c == '-') rd::m = 1, rd::c = getchar(); \\ while (isnum(rd::c)) x = x * 10 + rd::c - '0', rd::c = getchar(); \\ if (rd::m) x *= -1; \\ }namespace rd { char c; bool m;}using namespace std;const int maxn = 100010;int n, u, v, l, r, q[maxn];struct Node { int e, cnt, val; bool nod, cld; vector &lt; int &gt; linkin;} a[maxn];int main() { read(n); for (int i = 1; i &lt;= n; i++) { read(a[i].e); a[a[i].e].cnt += 1; a[a[i].e].linkin.push_back(i); } for (int i = 1; i &lt;= n; i++) if (!a[i].cnt) { a[i].nod = 1; q[++r] = i; } l = 1; while (l &lt;= r) { u = q[l++]; a[a[u].e].cnt--; if (!a[a[u].e].cnt) { a[a[u].e].nod = 1; q[++r] = a[u].e; } } for (int i = 1; i &lt;= n; i++) { if (!a[i].nod) { q[1] = i, r = 1; while (1) { a[q[r]].nod = 1; q[r + 1] = a[q[r]].e; r++; if (a[q[r]].nod) { r--; break; } } for (int i = 1; i &lt;= r; i++) { a[q[i]].val = r; a[q[i]].cld = 1; } } } l = 1, r = 0; for (int i = 1; i &lt;= n; i++) if (a[i].cld) q[++r] = i; while (l &lt;= r) { u = q[l++]; for (int i = 0; i &lt; a[u].linkin.size(); i++) { v = a[u].linkin[i]; if (!a[v].cld) { a[v].cld = 1; a[v].val = a[u].val + 1; q[++r] = v; } } } for (int i = 1; i &lt;= n; i++) printf(\"%d\\n\", a[i].val); return 0;}","link":"/luogu2921/"},{"title":"洛谷3175 - [HAOI2015]按位或","text":"同理可 Min-Max 容斥： $$\\min(S) = \\frac{1}{1 - \\sum\\limits_{S’ \\subseteq S} \\sum\\limits_{u \\in S’} p_u}$$ FWT 一波即可。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// =================================// author: memset0// date: 2019.01.14 08:44:30// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;#define ll long longnamespace ringo {template &lt;class T&gt; inline void read(T &amp;x) { x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;}template &lt;class T&gt; inline void print(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);}template &lt;class T&gt; inline void print(T x, char c) { print(x), putchar(c); }const int N = 25, M = 1 &lt;&lt; 20;int n, lim;double ans, a[M];void fwt(double *a) { for (int len = 1; len &lt; lim; len &lt;&lt;= 1) for (int i = 0; i &lt; lim; i += (len &lt;&lt; 1)) for (int j = 0; j &lt; len; j++) { double x = a[i + j], y = a[i + j + len]; a[i + j + len] = x + y; }}void main() { read(n), lim = 1 &lt;&lt; n; for (int i = 0; i &lt; lim; i++) scanf(\"%lf\", &amp;a[i]); for (int i = lim - 1, t = 0; t != (lim - 1); i--) { if (i == -1) return (void)(puts(\"INF\")); if (a[i] &gt; 0) t |= i; } fwt(a); for (int i = 1; i &lt; lim; i++) ans += (__builtin_popcount(i) &amp; 1 ? 1 : -1) / (1 - a[(lim - 1) ^ i]); printf(\"%.9lf\\n\", ans);}} signed main() { return ringo::main(), 0; }","link":"/luogu3175/"},{"title":"洛谷3321 [SDOI2015]序列统计","text":"与上一题类似，我们可以考虑生成函数。但是由于本题是 $\\mod m$ 意义下的乘法，所以我们可以把原来的乘法转换为与 $m$ 的原根的对数的加法。再用上题目类似的思路即可。 定义生成函数 $f$ ： $$f(x) = \\sum\\limits_{i=0}^{\\varphi(m)} tag(i) \\times x^i$$ 其中 $tag(i) = 1$ 当且仅当存在 $x \\in S$ 使得 $\\log_g x = i$ 。 最后答案为： $$[x^k]f^n(x)$$ 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101// =================================// author: memset0// date: 2019.01.12 18:02:25// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;// #define int long long#define ll long longnamespace ringo {template &lt;class T&gt; inline void read(T &amp;x) { x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;}template &lt;class T&gt; inline void print(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);}template &lt;class T&gt; inline void print(T x, char c) { print(x), putchar(c); }const int N = 8010 &lt;&lt; 2, mod = 1004535809;int n, m, x, g, len;int a[N], s[N], t[N], pow[N], map[N], rev[N], pre_g[2][30];inline int fpow(int a, int b, int mod) { int s = 1; for (; b; b &gt;&gt;= 1, a = (ll)a * a % mod) if (b &amp; 1) s = (ll)s * a % mod; return s;}int get_g(int p) { static int stk[100]; int top = 0, x = p - 1; for (int i = 2; i * i &lt;= x; i++) if (x % i == 0) { stk[++top] = i; while (x % i == 0) x /= i; } if (x != 1) stk[++top] = x; for (int g = 2, flag = 1; ; g++, flag = 1) { for (int j = 1; j &lt;= top &amp;&amp; flag; j++) flag &amp;= fpow(g, (p - 1) / stk[j], p) != 1; if (flag) return g; }}void ntt(int *a, int lim, int flag) { for (int i = 0; i &lt; lim; i++) if (i &lt; rev[i]) std::swap(a[i], a[rev[i]]); for (int len = 1, cnt = 1; len &lt; lim; len &lt;&lt;= 1, ++cnt) for (int i = 0, wn = pre_g[flag][cnt]; i &lt; lim; i += (len &lt;&lt; 1)) for (int j = 0, w = 1; j &lt; len; j++, w = (ll)w * wn % mod) { int x = a[i + j], y = (ll)w * a[i + j+ len] % mod; a[i + j] = (x + y) % mod, a[i + j + len] = (x - y + mod) % mod; }}inline void maintain(int *a, int len) { for (int i = len - 1; i &gt;= m - 1; i--) (a[i % (m - 1)] += a[i]) %= mod, a[i] = 0;}void solve() { int len = 1, k = 0, inv; while (len &lt;= ((m - 1) &lt;&lt; 1)) len &lt;&lt;= 1, ++k; inv = fpow(len, mod - 2, mod); for (int i = 0; i &lt; len; i++) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (k - 1)); memset(s, 0, sizeof(s)), s[0] = 1; while (n) { if (n &amp; 1) { for (int i = 0; i &lt; len; i++) t[i] = a[i]; ntt(s, len, 0), ntt(t, len, 0); for (int i = 0; i &lt; len; i++) s[i] = (ll)s[i] * t[i] % mod; ntt(s, len, 1); for (int i = 0; i &lt; len; i++) s[i] = (ll)s[i] * inv % mod; maintain(s, len); } n &gt;&gt;= 1; ntt(a, len, 0); for (int i = 0; i &lt; len; i++) a[i] = (ll)a[i] * a[i] % mod; ntt(a, len, 1); for (int i = 0; i &lt; len; i++) a[i] = (ll)a[i] * inv % mod; maintain(a, len); }}void main() { for (int i = 0; i &lt; 30; i++) { pre_g[0][i] = fpow(3, (mod - 1) / (1 &lt;&lt; i), mod); pre_g[1][i] = fpow(334845270, (mod - 1) / (1 &lt;&lt; i), mod); } read(n), read(m), read(x), read(len); for (int i = 1; i &lt;= len; i++) read(s[i]); g = get_g(m), pow[0] = 1; for (int i = 1; i &lt; m; i++) pow[i] = (ll)pow[i - 1] * g % m; for (int i = 0; i &lt; m - 1; i++) map[pow[i]] = i; for (int i = 1; i &lt;= len; i++) if (s[i]) a[map[s[i]]] = 1; solve(), print(s[map[x]], '\\n');}} signed main() { return ringo::main(), 0; }","link":"/luogu3321/"},{"title":"洛谷3411 - 序列变换","text":"题意给定一个长度为N的数列Ai。你可以对数列进行若干次操作，每次操作可以从数列中任选一个数，把它移动到数列的开头或者结尾。求最少经过多少次操作，可以把数列变成单调不减的。“单调不减”意味着数列中的任意一个数都不大于排在它后边的数。 分析你可以把题意转化为：找到一个不降子序列，使得未选中的数必须不处于子序列的最小值和最大值之间（理由：小于等于最小值的可以移到前面去，大于等于最大值的可以移到后面去）即找到一个值的区间[L, R]，在其中选择一个不降子序列，使得其包含了区间(L, R)中的所有值。（[L, R]表示闭区间，(L, R)表示开区间！） 那么你只要维护一个答案队列，使得其满足题意。每次考虑扩展右区间，同时检查可行性，更新最优解。需要注意的是，新增的节点值相同时可能会互相产生干扰，我们应当考虑倒序检查，之后顺序入队。 代码 &amp; 注释（使用了C++11新语法，请加上--std=c++11编译） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// ==============================// author: memset0// website: https://memset0.cn// date: 2018.08.07 14:22:32// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;int read() { int x = 0; char c = getchar(); bool m = 0; while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') c = getchar(), m = 1; while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;}const int maxn = 1e6 + 10;int n, m, l, r, cnt, ans, a[maxn], q[maxn];vector &lt; int &gt; b[maxn];int main() { n = read(); for (int i = 1; i &lt;= n; i++) { a[i] = read(); b[a[i]].push_back(i); m = max(m, a[i]); } l = 1, r = 0; for (int i = 1; i &lt;= m; i++) if (b[i].size()) { cnt = 0; for (auto it = b[i].rbegin(); it != b[i].rend(); it++) { // 反向更新，避免值相同的数产生影响 int i = *it; while (l &lt;= r &amp;&amp; q[r] &gt; i) { // 进入while循环说明发现当前节点不能直接加入到答案队列中 // 但由前面可知要使答案有效所去的数必须连续 // 那么删除答案队列的末尾使得当前节点可以被加入 while (l &lt;= r &amp;&amp; a[q[l]] &lt; a[q[r]]) l++; // 如果删除当前的R可能导致答案队列不能使得值域连续 // 这样的话只能删除答案队列里之前的值 r--; // 删除答案队列里的末尾值 } cnt++; ans = max(ans, r - l + 1 + cnt); // 请不要写 ans=max(ans,r-l+1+(++cnt))，否则 WA 40 分等着你！ } for (auto it = b[i].begin(); it != b[i].end(); it++) q[++r] = *it; // 加入到答案队列中 } printf(\"%d\\n\", n - ans); return 0;}","link":"/luogu3411/"},{"title":"洛谷3701 -「伪模板」主席树","text":"去他妈的NOI难度 从 $S$ 到 byx 的每个人连条容量为生命的边，从手气君的每个人到 $E$ 连条容量为生命的边；如果 byx 的这个人能打赢对方的某个人连一条容量为 $1$ 的边，$+1s$ 的话直接加到生命里，最后跑一遍最大流即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;int read() { int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;}int readc() { char c = getchar(), t; while (!isupper(c)) c = getchar(); t = getchar(); while (isupper(t)) t = getchar(); return c;}const int maxn = 2010, maxm = 100010;int n, m, ans, cnt;struct people { char kind; int health;} a[maxn], b[maxn];int tot = 2, hed[maxn], nxt[maxm], to[maxm], val[maxm];void add_edge(int u, int v, int w) { nxt[tot] = hed[u]; to[tot] = v; val[tot] = w; hed[u] = tot++; nxt[tot] = hed[v]; to[tot] = u; val[tot] = 0; hed[v] = tot++;}const int inf = 2e9 + 7;int u, s, e, flag, flow;int cur[maxn], pre[maxn], dep[maxn], gap[maxn];#define v (to[i])int max_flow() { int ans = 0; for (int i = 1; i &lt;= e; i++) cur[i] = hed[i]; u = s, pre[u] = 0, gap[0] = e; while (dep[u] &lt; e) { flag = 0; for (int &amp;i = cur[u]; i; i = nxt[i]) if (val[i] &amp;&amp; dep[u] == dep[v] + 1) { u = v; pre[v] = i; flag = 1; break; } if (!flag) { if (!--gap[dep[u]]) break; dep[u] = e; for (int i = hed[u]; i; i = nxt[i]) if (val[i] &amp;&amp; dep[v] + 1 &lt; dep[u]) { dep[u] = dep[v] + 1; cur[u] = i; } ++gap[dep[u]]; if (u != s) u = to[pre[u] ^ 1]; } if (u == e) { flow = inf; for (int i = pre[e]; i; i = pre[to[i ^ 1]]) flow = min(flow, val[i]); for (int i = pre[e]; i; i = pre[to[i ^ 1]]) val[i] -= flow, val[i ^ 1] += flow; ans += flow; u = s; } } return ans;}#undef vint main() { n = read(), m = read(); for (int i = 1; i &lt;= n; i++) a[i].kind = readc(); for (int i = 1; i &lt;= n; i++) b[i].kind = readc(); for (int i = 1; i &lt;= n; i++) a[i].health = read(); for (int i = 1; i &lt;= n; i++) b[i].health = read(); cnt = 0; for (int i = 1; i &lt;= n; i++) if (a[i].kind == 'Y') cnt++; for (int i = 1; i &lt;= n; i++) if (a[i].kind == 'J') a[i].health += cnt; cnt = 0; for (int i = 1; i &lt;= n; i++) if (b[i].kind == 'Y') cnt++; for (int i = 1; i &lt;= n; i++) if (b[i].kind == 'J') b[i].health += cnt; s = (n &lt;&lt; 1) + 1, e = (n + 1) &lt;&lt; 1; for (int i = 1; i &lt;= n; i++) add_edge(s, i, a[i].health); for (int i = 1; i &lt;= n; i++) add_edge(i + n, e, b[i].health); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) {#define A (a[i].kind)#define B (b[j].kind) if ((A == 'W' &amp;&amp; (B == 'E' || B == 'Y')) || (A == 'J' &amp;&amp; (B == 'H' || B == 'W')) || (A == 'E' &amp;&amp; (B == 'Y' || B == 'J')) || (A == 'Y' &amp;&amp; (B == 'H' || B == 'J')) || (A == 'H' &amp;&amp; (B == 'W' || B == 'E'))) add_edge(i, j + n, 1);#undef A#undef B } ans = min(max_flow(), m); printf(\"%d\\n\", ans); return 0;}","link":"/luogu3701/"},{"title":"洛谷3601 签到题","text":"这题非常的签到。 考虑到一个数只能被小于根号的质数筛到，暴力做即可。 复杂度为 $O(n \\log n)$ ，其中 $n = r - l + 1$ 。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// =================================// author: memset0// date: 2019.02.04 20:59:09// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;#define ll long longnamespace ringo {template &lt;class T&gt; inline void read(T &amp;x) { x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;}template &lt;class T&gt; inline void print(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);}template &lt;class T&gt; inline void print(T x, char c) { print(x), putchar(c); }const int N = 1e6 + 10;ll L, R, ans, pow[N], phi[N], lst[N];int c_pri, pri[N];bool vis[N];void main() { read(L), read(R); for (int i = 2, lim = sqrt(R); i &lt;= lim; i++) { if (!vis[i]) pri[++c_pri] = i; for (int j = 1; j &lt;= c_pri &amp;&amp; i * pri[j] &lt;= lim; j++) { vis[i * pri[j]] = 1; if (i % pri[j] == 0) continue; } } for (ll i = L; i &lt;= R; i++) phi[i - L] = 1, lst[i - L] = i; pow[0] = 1; for (int i = 1, x, cnt; i &lt;= c_pri; i++) { x = pri[i]; for (int i = 1; pow[i - 1] &lt;= R; i++) pow[i] = pow[i - 1] * x; for (ll t, j = L % x ? (L / x + 1) * x : L; j &lt;= R; j += x) { for (cnt = 0; lst[j - L] % x == 0; lst[j - L] /= x, ++cnt); if (cnt == 1) phi[j - L] *= (x - 1); else phi[j - L] *= (x - 1) * pow[cnt - 1]; } } for (int i = 0; i &lt;= R - L; i++) if (lst[i] != 1) phi[i] *= lst[i] - 1; // ans = (R - L + 1) * (L + R) / 2; // for (int i = 0; i &lt;= R - L; i++) print(phi[i], \" \\n\"[i == R - L]); for (int i = 0; i &lt;= R - L; i++) ans += i + L - phi[i]; print(ans % 666623333, '\\n');}} signed main() { return ringo::main(), 0; }","link":"/luogu3601/"},{"title":"洛谷3810 - 【模板】三维偏序（陌上花开）","text":"三维偏序，一维一维解决：第一维排序，第二维 CDQ ，第三维树状数组（或 CDQ ）。 先按照 $a$ 进行排序，考虑 CDQ ，先分治左右两边，使得左右两边的节点都按 $b$ 排序，于是依次从两边取（优先 $b$ ， $b$ 相等优先 $c$），左边的取出时在树状数组中更新，右边的取出时从树状数组中查询，考虑贡献。 需要注意的是，$a$ 、 $b$ 、 $c$ 的值都相同的节点有可能互相产生贡献，很难用 CDQ 解决，于是可以将这些点缩为一个，并单独计算他们内部互相产生的贡献。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;int read() { int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;}const int maxn = 100010;int n, m, p;int ans[maxn], sum[maxn &lt;&lt; 1], cnt[maxn];struct node { int a, b, c, i, s;} e[maxn], t[maxn];bool operator == (node a, node b) { return a.a == b.a &amp;&amp; a.b == b.b &amp;&amp; a.c == b.c;}bool cmp1(node a, node b) { if (a.a != b.a) return a.a &lt; b.a; if (a.b != b.b) return a.b &lt; b.b; return a.c &lt; b.c;}#define lowbit(x) ((x)&amp;(-(x)))void add(int k, int x) { for (int i = k; i &lt;= m; i += lowbit(i)) sum[i] += x;}int ask(int k) { int ans = 0; for (int i = k; i &gt;= 1; i -= lowbit(i)) ans += sum[i]; return ans;}void solve(int l, int r) { int mid = (l + r) &gt;&gt; 1; if (l == r) return; solve(l, mid); // 先分治解决左右两边 solve(mid + 1, r); // 在计算左边对右边的贡献 int L = l, R = mid + 1, T = 0; while (L &lt;= mid &amp;&amp; R &lt;= r) { if (e[L].b &lt; e[R].b || (e[L].b == e[R].b &amp;&amp; e[L].c &lt;= e[R].c)) { add(e[L].c, e[L].s); t[++T] = e[L++]; } else { ans[e[R].i] += ask(e[R].c); t[++T] = e[R++]; } } while (L &lt;= mid) t[++T] = e[L++]; while (R &lt;= r) { ans[e[R].i] += ask(e[R].c); t[++T] = e[R++]; } L = l, R = mid + 1; while (L &lt;= mid &amp;&amp; R &lt;= r) { if (e[L].b &lt; e[R].b || (e[L].b == e[R].b &amp;&amp; e[L].c &lt;= e[R].c)) { add(e[L].c, -e[L].s); L++; } else R++; } for (int i = 1; i &lt;= T; i++) e[l + i - 1] = t[i];}int main() { n = read(), m = read(); for (int i = 1; i &lt;= n; i++) e[i].a = read(), e[i].b = read(), e[i].c = read(), e[i].i = i, e[i].s = 1; sort(e + 1, e + n + 1, cmp1); p = 1; for (int i = 2; i &lt;= n; i++) if (e[i] == e[i - 1]) e[p].s++; else e[++p] = e[i]; swap(n, p); solve(1, n); // 进行 CDQ for (int i = 1; i &lt;= n; i++) ans[e[i].i] += e[i].s - 1; for (int i = 1; i &lt;= n; i++) cnt[ans[e[i].i]] += e[i].s; for (int i = 0; i &lt; p; i++) printf(\"%d\\n\", cnt[i]); return 0;}","link":"/luogu3810/"},{"title":"洛谷3980 - [NOI2008]志愿者招募","text":"巧妙的使用满流的特性解决问题。 对每一天，连一条容量为 $INF - 需求人数$ 的边，对于补充的人连一条容量为 $INF$ ，花费为价格的边。 对这个图跑最小费用最大流，其中最大流一定是 $INF$ ，最小费用即答案。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;int read() { int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;}const int maxn = 11010, maxm = 45010, inf = 1e9;int n, m, u, v, l, r, x, e, s;int flow, cost, max_flow, min_cost;int pre[maxn], dis[maxn], q[maxn * maxn], inq[maxn];int tot = 2, hed[maxn], nxt[maxm], to[maxm], val[maxm], cst[maxm];void add_simple_edge(int u, int v, int w, int c) { nxt[tot] = hed[u], to[tot] = v, val[tot] = w, cst[tot] = c; hed[u] = tot++;}void add_edge(int u, int v, int w, int c) { add_simple_edge(u, v, w, c); add_simple_edge(v, u, 0, -c);}bool spfa() { memset(dis, -1, sizeof(dis)); memset(pre, 0, sizeof(pre)); l = r = 1, q[1] = s, dis[s] = 0, inq[s] = 1; while (l &lt;= r) { u = q[l++], inq[u] = 0; for (int i = hed[u]; i; i = nxt[i]) if (val[i]) { v = to[i]; if (dis[v] == -1 || dis[u] + cst[i] &lt; dis[v]) { dis[v] = dis[u] + cst[i]; pre[v] = i; if (!inq[v]) { inq[v] = 1; q[++r] = v; } } } } return pre[e];}int main() { n = read(), m = read(); for (int i = 1; i &lt;= n; i++) { x = read(); add_edge(i, i + 1, inf - x, 0); } for (int i = 1; i &lt;= m; i++) { l = read(), r = read(), x = read(); add_edge(l, r + 1, inf, x); } s = n + 2, e = n + 3; add_edge(s, 1, inf, 0); add_edge(n + 1, e, inf, 0); while (spfa()) { flow = inf, cost = 0; for (int i = pre[e]; i; i = pre[to[i ^ 1]]) flow = min(flow, val[i]); for (int i = pre[e]; i; i = pre[to[i ^ 1]]) val[i] -= flow, val[i ^ 1] += flow; for (int i = pre[e]; i; i = pre[to[i ^ 1]]) cost += cst[i] * flow; max_flow += flow, min_cost += cost; } printf(\"%d\\n\", min_cost); return 0;}","link":"/luogu3980/"},{"title":"洛谷4168 - [Violet]蒲公英","text":"这道黑题为什么那么水 QAQ这道题在 BZOJ 上为什么又又又又又是权限题 本题求区间众数，强制在线。 对于每次查询，必定可以分为整块的和非整块的，我们先预处理出第 $i$ 块到第 $j$ 块的众数（ $max[i][j]$ ）和某个数 $i$ 在前 $j$ 个块内的前缀和（ $sum[i][j]$ ）。对于非整块的部分 $O(\\sqrt n)$ 暴力加到桶里，加上整块中的个数判断能否更新答案。然后判断 $l$ 与 $r$ 之间的块的众数是否能否更新答案。 预处理的话 $max$ 和 $sum$ 数组全都暴力扫一遍更新，时间复杂度 $O(n \\sqrt n)$，详见代码。 时间复杂度：$O(n \\sqrt n + m \\sqrt m)$ 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long long#define rep(i,l,r) for (int i = l; i &lt;= r; i++)int read() { int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;}const int maxn = 40010, maxm = 210;int n, m, l, r, bl, br, tn, sqn, ans, now;int a[maxn], b[maxn], bln[maxn], fst[maxm], tmp[maxn];int cnt[maxn][maxm], sum[maxn][maxm], max[maxm][maxm];bool better(int x, int y, int a, int b) { return (x &gt; y) || (x == y &amp;&amp; a &lt; b);}int query(int l, int r) { ans = 0; if (bln[l] == bln[r]) { for (int i = l; i &lt;= r; i++) if (better(++tmp[a[i]], tmp[ans], a[i], ans)) ans = a[i]; for (int i = l; i &lt;= r; i++) --tmp[a[i]]; } else { br = bln[r] - 1, bl = bln[l]; for (int i = l; i &lt; fst[bln[l] + 1]; i++) if (better(++tmp[a[i]] + sum[a[i]][br] - sum[a[i]][bl], tmp[ans] + sum[ans][br] - sum[ans][bl], a[i], ans)) ans = a[i]; for (int i = fst[bln[r]]; i &lt;= r; i++) if (better(++tmp[a[i]] + sum[a[i]][br] - sum[a[i]][bl], tmp[ans] + sum[ans][br] - sum[ans][bl], a[i], ans)) ans = a[i]; if (better(tmp[max[bl + 1][br]] + sum[max[bl + 1][br]][br] - sum[max[bl + 1][br]][bl], tmp[ans] + sum[ans][br] - sum[ans][bl], max[bl + 1][br], ans)) ans = max[bl + 1][br]; for (int i = l; i &lt; fst[bln[l] + 1]; i++) --tmp[a[i]]; for (int i = fst[bln[r]]; i &lt;= r; i++) --tmp[a[i]]; } return ans;}int main() { n = read(), m = read(); for (int i = 1; i &lt;= n; i++) b[i] = a[i] = read(); std::sort(b + 1, b + n + 1); tn = std::unique(b + 1, b + n + 1) - b - 1; for (int i = 1; i &lt;= n; i++) a[i] = std::lower_bound(b + 1, b + tn + 1, a[i]) - b; sqn = sqrt(n) + 1; if (sqn * sqn &lt; n) sqn++; bln[sqn + 1] = n + 1; for (int i = 1; i &lt;= n; i++) { bln[i] = (i - 1) / sqn + 1; if (!fst[bln[i]]) fst[bln[i]] = i; } for (int i = 1; i &lt;= n; i++) cnt[a[i]][bln[i]]++; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= sqn; j++) sum[i][j] = sum[i][j - 1] + cnt[i][j]; for (int i = 1; i &lt;= sqn; i++) { memset(tmp, 0, sizeof(tmp)), now = 0; for (int j = i; j &lt;= sqn; j++) { for (int k = fst[j]; k &lt; fst[j + 1]; k++) if (better(++tmp[a[k]], tmp[now], a[k], now)) now = a[k]; max[i][j] = now; } } for (int i = 1; i &lt;= m; i++) { l = (read() + ans - 1) % n + 1; r = (read() + ans - 1) % n + 1; if (l &gt; r) std::swap(l, r); printf(\"%d\\n\", ans = b[query(l, r)]); } return 0;}","link":"/luogu4168/"},{"title":"洛谷3620 - [APIO/CTSC 2007] 数据备份","text":"首先我们把原来的距离数组 $p$ 差分为数组 $a$。原题可以等同为在 $a$ 数组中选择 $k$ 个不相邻的数使得总和最小。 假设我们已经选择了 $a_i$ ，那么 $a_{i-1}$ 和 $a_{i+1}$ 要么同时选择，要么同时没有被选择。同时，如果我们同时选择，需要的花费即 $V_{a_{i+1}} + V_{a_{i-1}} - V_{a_i}$ 。我们维护一个堆和双向链表，每次从小根堆选择堆顶，把 $a_i$、 $a_{i-1}$ 和 $a_{i+1}$ 同时删除，再新建一个价值为 $V_{a_{i+1}} + V_{a_{i-1}} - V_{a_i}$ 的节点，扔到堆里，重复 $k$ 次就能得到答案。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long long#define rep(i,l,r) for (int i = l; i &lt;= r; i++)#define getc(x) getchar(x)#define putc(x) putchar(x)template &lt;typename T&gt; inline void read(T &amp;x) { x = 0; register char ch; register bool fl = 0; while (ch = getc(), ch &lt; 48 || 57 &lt; ch) fl ^= ch == '-'; x = (ch &amp; 15); while (ch = getc(), 47 &lt; ch &amp;&amp; ch &lt; 58) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch &amp; 15); if (fl) x = -x;}template &lt;typename T&gt; inline void readc(T &amp;x) { while (x = getc(), !islower(x) &amp;&amp; !isupper(x));}template &lt;typename T&gt; inline void print(T x, char c = ' ') { static int buf[40]; if (x == 0) { putc('0'); putc(c); return; } if (x &lt; 0) putc('-'), x = -x; for (buf[0] = 0; x; x /= 10) buf[++buf[0]] = x % 10 + 48; while (buf[0]) putc((char) buf[buf[0]--]); putc(c);}const int maxn = 1000010;int n, m, pos, l[maxn], r[maxn], tmp[maxn];ll ans, val[maxn];bool vis[maxn];struct node { int id; ll val;} u, v;bool operator &lt; (const node &amp;a, const node &amp;b) { return a.val &gt; b.val;}std::priority_queue &lt; node &gt; q;int main() { read(n), read(m), --n; for (int i = 1; i &lt;= n + 1; i++) read(tmp[i]); for (int i = 1; i &lt;= n; i++) val[i] = tmp[i + 1] - tmp[i]; for (int i = 1; i &lt;= n; i++) l[i] = i - 1, r[i] = i + 1; pos = n + 1; for (int i = 1; i &lt;= n; i++) q.push(node{i, val[i]}); val[0] = val[n + 1] = 1e9; for (int i = 1; i &lt;= m; i++) { while (vis[q.top().id] &amp;&amp; q.size()) q.pop(); if (!q.size()) break; u = q.top(), q.pop(); vis[u.id] = vis[l[u.id]] = vis[r[u.id]] = 1; ans += u.val, v.id = ++pos; l[v.id] = l[l[u.id]], r[v.id] = r[r[u.id]]; r[l[v.id]] = v.id, l[r[v.id]] = v.id; val[v.id] = v.val = val[l[u.id]] + val[r[u.id]] - val[u.id]; q.push(v); } print(ans, '\\n'); return 0;}","link":"/luogu3620/"},{"title":"洛谷4248 - [AHOI2013]差异","text":"SAM 板子题。 可以发现两个串的 LCS 即在 SAM 上的 LCA 的 len ，对于每一个点统计对答案的贡献次数即可。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// =================================// author: memset0// date: 2019.01.17 20:59:48// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;#define int long long#define ll long longnamespace ringo {template &lt;class T&gt; inline void read(T &amp;x) { x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;}template &lt;class T&gt; inline void print(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);}template &lt;class T&gt; inline void print(T x, char c) { print(x), putchar(c); }const int N = 1e6 + 10;int n;ll ans;char s[N];struct samStruct { int clen, cnt, lst; int fa[N], len[N], siz[N], ch[N][26]; std::vector &lt;int&gt; G[N]; inline samStruct() { cnt = lst = 1; } inline void insert(int c) { int f = lst, u = ++cnt; len[lst = u] = ++clen, siz[u] = 1; while (f &amp;&amp; !ch[f][c]) ch[f][c] = u, f = fa[f]; if (!f) return (void)(fa[u] = 1); int s = ch[f][c]; if (len[s] == len[f] + 1) return (void)(fa[u] = s); int p = ++cnt; len[p] = len[f] + 1, fa[p] = fa[s], fa[s] = fa[u] = p; for (register int i = 0; i &lt; 26; i++) ch[p][i] = ch[s][i]; while (f &amp;&amp; ch[f][c] == s) ch[f][c] = p, f = fa[f]; } void dfs(int u, int depth) { int sum = 0; for (int i = 0, v; i &lt; G[u].size(); i++) v = G[u][i], dfs(v, depth + len[v] - len[u]), sum += siz[v]; ans += (ll)sum * siz[u] * 2 * depth; for (int i = 0, v; i &lt; G[u].size(); i++) v = G[u][i], ans += (ll)siz[v] * (sum - siz[v]) * depth; siz[u] += sum; } inline void solve() { for (int i = 2; i &lt;= cnt; i++) G[fa[i]].push_back(i); dfs(1, 0); }} sam;void main() { scanf(\"%s\", s + 1), n = strlen(s + 1); for (int i = n; i &gt;= 1; i--) sam.insert(s[i] - 'a'); sam.solve(); ans = ((unsigned long long)n * (n - 1) * (n + 1) &gt;&gt; 1) - ans; print(ans, '\\n');}} signed main() { return ringo::main(), 0; }","link":"/luogu4248/"},{"title":"洛谷4396 - [AHOI2013]作业","text":"最近忽然发现 BZOJ 的权限题还是很多的（可能是因为以前搜不到就不搜了现在上 DARKBZOJ ），看来还是得众筹买个权限号了（雾 这是一道傻逼数据结构题，由于数据范围小，各种奇葩算法随便过。本菜鸡就写了个普通的树状数组套莫队，各位大佬不要见笑。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long long#define rep(i,l,r) for (int i = l; i &lt;= r; i++)int read() { int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;}const int maxn = 100010, maxm = 100010;#define lowbit(x) ((x)&amp;(-(x)))int n, m, l, r, x, y, tn, ql, qr, sqn;int a[maxn], b[maxn], bln[maxn], cnt[maxn], s[2][maxn], ans[2][maxm];struct query { int l, r, x, y, i;} q[maxm];bool cmp(query x, query y) { if (bln[x.l] ^ bln[y.l]) return x.l &lt; y.l; return x.r &lt; y.r;}inline void modify(int i, int x, int k) { i++; for (; i &lt;= n + 1; i += lowbit(i)) s[k][i] += x;}inline int query(int i, int k) { int ret = 0; i++; for (; i &gt;= 2; i -= lowbit(i)) ret += s[k][i]; return ret;}inline void add(int x) { if (!cnt[x]) { modify(x, 1, 1); } modify(x, 1, 0); cnt[x]++;}inline void del(int x) { modify(x, -1, 0); cnt[x]--; if (!cnt[x]) { modify(x, -1, 1); }}int main() { n = read(), m = read(), sqn = n / sqrt(m * 2.0 / 3); if (sqn == 0) sqn++; for (int i = 1; i &lt;= n; i++) bln[i] = i / sqn; for (int i = 1; i &lt;= n; i++) a[i] = read(); for (int i = 1; i &lt;= n; i++) b[i] = a[i]; std::sort(b + 1, b + n + 1); tn = std::unique(b + 1, b + n + 1) - b - 1; for (int i = 1; i &lt;= n; i++) a[i] = std::lower_bound(b + 1, b + tn + 1, a[i]) - b; for (int i = 1; i &lt;= m; i++) { q[i].l = read(), q[i].r = read(); q[i].x = read(), q[i].y = read(); q[i].i = i; } std::sort(q + 1, q + m + 1, cmp); ql = 1, qr = 0; for (int i = 1; i &lt;= m; i++) { l = q[i].l, r = q[i].r; x = q[i].x, y = q[i].y; x = std::lower_bound(b + 1, b + tn + 1, x) - b - 1; y = std::upper_bound(b + 1, b + tn + 1, y) - b - 1; while (ql &lt; l) del(a[ql++]); while (ql &gt; l) add(a[--ql]); while (qr &gt; r) del(a[qr--]); while (qr &lt; r) add(a[++qr]); ans[0][q[i].i] = query(y, 0) - query(x, 0); ans[1][q[i].i] = query(y, 1) - query(x, 1); } for (int i = 1; i &lt;= m; i++) printf(\"%d %d\\n\", ans[0][i], ans[1][i]); return 0;}","link":"/luogu4396/"},{"title":"洛谷4102 - [HEOI2014]林中路径","text":"数据范围容易想到利用矩阵进行计算。 考虑 $f(k) = (A, B)$ ，其中 $A$ 表示恰好等于 $k$ 的路径条数， $B$ 表示小于等于 $k$ 的路径条数。则可以这样转移： $(A, B) \\times (C, D) = (A \\times C, B + A \\times D)$ 。 需要注意的是，对长度为 $L$ 的路径对答案的贡献可以表示为一个二次多项式（即 $f(L) = L ^ 2$），转移时不能直接计算，而需要记录一次项和常数项系数。注意多项式乘法时需要乘上组合数。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113// =================================// author: memset0// date: 2019.01.17 17:10:00// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;#define pb push_back#define rep(i, l, r) for (register int i = l; i &lt;= r; i++)namespace ringo {typedef long long ll;typedef unsigned long long ull;inline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s == t ? t = (s = buf) + fread(buf, 1, IN_LEN, stdin), (s == t ? -1 : *s++) : *s++);}template &lt;class T&gt; inline void read(T &amp;x) { static bool f; static char c; for (f = 0, c = read(); !isdigit(c); c = read()) { f ^= c == '-'; if (c == -1) return; } for (x = 0; isdigit(c); c = read()) x = ((x + (x &lt;&lt; 2)) &lt;&lt; 1) + (c ^ '0'); if (f) x = -x;}const int OUT_LEN = 10000000; char obuf[OUT_LEN], *ooh = obuf;inline void print(char c) { if (ooh == obuf + OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), ooh = obuf; *ooh++ = c;}template&lt;class T&gt; inline void print(T x) { static int buf[30], cnt; if (!x) { print('0'); return; } if (x &lt; 0) print('-'), x = -x; for (cnt = 0; x; x /= 10) buf[++cnt] = x % 10 + '0'; while (cnt) print((char)buf[cnt--]);}inline void flush() { fwrite(obuf, 1, ooh - obuf, stdout); }template &lt;class T&gt; inline void maxd(T &amp;a, T b) { if (b &gt; a) a = b; }template &lt;class T&gt; inline void mind(T &amp;a, T b) { if (b &lt; a) a = b; }template &lt;class T&gt; inline void print(T x, char c) { print(x), print(c); }template &lt;class T&gt; inline T abs(const T &amp;a) { if (a &lt; 0) return -a; return a; }const int N = 110, mod = 1e9 + 7;int n, m, k, q;struct pair { struct matrix { struct poly { int f[3]; inline void inc() { ++f[0], ++f[1], ++f[2]; } inline void operator += (const poly &amp;other) { f[0] += other.f[0]; if (f[0] &gt;= mod) f[0] -= mod; f[1] += other.f[1]; if (f[1] &gt;= mod) f[1] -= mod; f[2] += other.f[2]; if (f[2] &gt;= mod) f[2] -= mod; } friend inline poly operator + (const poly &amp;a, const poly &amp;b) { static poly s; s.f[0] = a.f[0] + b.f[0]; if (s.f[0] &gt;= mod) s.f[0] -= mod; s.f[1] = a.f[1] + b.f[1]; if (s.f[1] &gt;= mod) s.f[1] -= mod; s.f[2] = a.f[2] + b.f[2]; if (s.f[2] &gt;= mod) s.f[2] -= mod; return s; } friend inline poly operator * (const poly &amp;a, const poly &amp;b) { static poly s; s.f[0] = (ll)a.f[0] * b.f[0] % mod; s.f[1] = ((ll)a.f[0] * b.f[1] + (ll)a.f[1] * b.f[0]) % mod; s.f[2] = ((ll)a.f[2] * b.f[0] + (ll)a.f[0] * b.f[2] + 2LL * a.f[1] * b.f[1]) % mod; return s; } } a[100][100]; inline void inc(int x, int y) { a[x][y].inc(); } inline int ask(int x, int y) { return a[x][y].f[2]; } inline void operator += (const matrix &amp;other) { for (register int i = 0; i &lt; n; i++) for (register int j = 0; j &lt; n; j++) a[i][j] += other.a[i][j]; } friend inline matrix operator + (const matrix &amp;a, const matrix &amp;b) { static matrix c; for (register int i = 0; i &lt; n; i++) for (register int j = 0; j &lt; n; j++) c.a[i][j] = a.a[i][j] + b.a[i][j]; return c; } friend inline matrix operator * (const matrix &amp;a, const matrix &amp;b) { static matrix c; for (register int i = 0; i &lt; n; i++) for (register int j = 0; j &lt; n; j++) c.a[i][j].f[0] = c.a[i][j].f[1] = c.a[i][j].f[2] = 0; for (register int i = 0; i &lt; n; i++) for (register int k = 0; k &lt; n; k++) for (register int j = 0; j &lt; n; j++) c.a[i][j] += a.a[i][k] * b.a[k][j]; return c; } } A, B; inline int ask(int x, int y) { return B.ask(x, y); } inline void inc(int x, int y) { A.inc(x, y), B.inc(x, y); } inline void operator *= (const pair &amp;other) { A = A * other.A, B += A * other.B; } friend inline pair operator * (const pair &amp;a, const pair &amp;b) { return (pair){a.A * b.A, a.B + a.A * b.B}; }} a, s;void main() { read(n), read(m), read(k), read(q); for (int i = 1, u, v; i &lt;= m; i++) read(u), read(v), --u, --v, a.inc(u, v); for (s = a, --k; k; k &gt;&gt;= 1, a = a * a) if (k &amp; 1) s = s * a; for (int i = 1, u, v; i &lt;= q; i++) read(u), read(v), --u, --v, print(s.ask(u, v), '\\n');}} signed main() { return ringo::main(), ringo::flush(), 0; }","link":"/luogu4102/"},{"title":"洛谷4767 - [IOI2000]邮局","text":"非常简单的四边形不等式优化模板题。 （一）首先考虑 $O(n^2 \\times m)$ 的做法，先将 $a$ 数组排序，假设 $f[i][j]$ 表示前 $i$ 个村庄中设立 $j$ 个邮局，可以列出转移方程： $$f[i][j] = min(f[i][j], f[k][j - 1] + dis(k + 1, i))$$ 其中 $dis(l, r)$ 表示在 $l$ 到 $r$ 的区间中建立一个邮局所对答案产生的贡献，利用人类智慧可知把邮局建在中间花费最少。 （二）在进行四边形不等式优化之前，我们先考虑如何在 $O(1)$ 的时间复杂度内求出 $dis(l, r)$： 在暴力做法中，我们需要枚举 $l$ 到 $r$ 之间的数，去其与中间的村庄的距离差的绝对值，代码大概如下： 12for (int i = l; i &lt;= r; i++) ans += abs(a[i] - a[mid]); 由于 $a$ 数组是有序的，我们可知在 $mid$ 左面的村庄 $abs(a_i - a_{mid}) = a_{mid} - a_i$，右边的村庄 $abs(a_i - a_{mid}) = a_i - a_{mid}$ 。那么通过前缀和即可在 $O(1)$ 的时间复杂度内求出。 （三）四边形不等式优化必须满足： $$f[a][c]+f[b][d]&lt;=f[b][c]+f[a][d]$$ 且决策单调。 本题可以通过打表等方法证明成立，那么 $f[i][j]$ 的状态只能从 $f[i][j - 1]$ 到 $f[i + 1][j]$ 的决策中选择一个进行转移。 （四）代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;int read() { int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;}const int maxn = 3010, maxm = 310;int n, m;int a[maxn];int s[maxn][maxn];int f[maxn][maxn];int dis[maxn][maxn];int tran[maxn][maxn];int main() { memset(f, 0x3f, sizeof(f)); n = read(), m = read(); for (int i = 1; i &lt;= n; i++) a[i] = read(); sort(a + 1, a + n + 1); for (int i = 1; i &lt;= n; i++) for (int j = i; j &lt;= n; j++) s[i][j] = s[i][j - 1] + a[j]; for (int l = 1; l &lt;= n; l++) for (int r = l; r &lt;= n; r++) { int mid = (l + r) &gt;&gt; 1; dis[l][r] += (mid - l) * a[mid] - s[l][mid - 1]; dis[l][r] += s[mid + 1][r] - (r - mid) * a[mid]; } for (int i = 1; i &lt;= n; i++) f[i][1] = dis[1][i]; for (int j = 2; j &lt;= m; j++) { tran[n + 1][j] = n; for (int i = n; i &gt;= 1; i--) { for (int k = tran[i][j - 1]; k &lt;= tran[i + 1][j]; k++) if (f[k][j - 1] + dis[k + 1][i] &lt; f[i][j]) { f[i][j] = f[k][j - 1] + dis[k + 1][i]; tran[i][j] = k; } } } printf(\"%d\\n\", f[n][m]); return 0;}","link":"/luogu4767/"},{"title":"洛谷4131 - [WC2005]友好的生物","text":"首先 $c$ 没什么卵用，我们直接把他乘到属性里。 可以发现这里的 $d$ 是两个属性值减一减的绝对值，所以我们要考虑怎么维护这个绝对值。 我们先考虑 $K = 1$ 的情况，先把这些生物按照 $d$ 的大小排个序，那么后一个减前一个的值一定就是非负的，也就等于绝对值，直接扫一遍就好了。 接下来考虑 $K \\not = 1$ 的时候的前 $K - 1$ 位，根据幼儿园学过的知识我们可以知道： $$a - b \\leq |a -b|$$ 由于我们要求绝对值的和的最大值，所以我们只要枚举每个属性的正负把他们一起取最大值即可。 那么第 $K $ 位怎么办呢？我们可是要加上绝对值的相反数啊。没关系，采用之前 $K = 1$ 的时候的方法，减一减扫过去，就能保证你去到的值非负啦。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// =================================// author: memset0// date: 2019.01.06 09:54:22// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;#define int long long#define ll long longnamespace ringo {template &lt;class T&gt; inline void read(T &amp;x) { x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;}template &lt;class T&gt; inline void print(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);}template &lt;class T&gt; inline void print(T x, char c) { print(x), putchar(c); }const int N = 1e5 + 10, M = 6;int n, m, sum;int c[M];struct status { int min, id; inline bool operator &lt; (const status &amp;other) const { return min &lt; other.min; }} min[1 &lt;&lt; 5];struct answer { int max, x, y; inline bool operator &lt; (const answer &amp;other) const { return max &lt; other.max; }} ans;struct node { int b[6], id; inline bool operator &lt; (const node &amp;other) const { return b[m] &lt; other.b[m]; }} a[N];void main() { read(n), read(m); for (int i = 1; i &lt;= m; i++) read(c[i]); for (int i = 1; i &lt;= n; i++) { a[i].id = i; for (int j = 1; j &lt;= m; j++) { read(a[i].b[j]); a[i].b[j] *= c[j]; } } std::sort(a + 1, a + n + 1); for (int x = 0, lim = 1 &lt;&lt; (m - 1); x &lt; lim; x++) min[x].min = 1e9 + 7; for (int i = 1; i &lt;= n; i++) { for (int x = 0, lim = 1 &lt;&lt; (m - 1); x &lt; lim; x++) { sum = 0; for (int j = 1; j &lt; m; j++) sum += (x &amp; (1 &lt;&lt; (j - 1)) ? 1 : -1) * a[i].b[j]; ans = std::max(ans, (answer){sum - min[x].min - a[i].b[m], a[i].id, min[x].id}); min[x] = std::min(min[x], (status){sum - a[i].b[m], a[i].id}); } } print(ans.x, ' '), print(ans.y, '\\n'), print(ans.max, '\\n');}} signed main() { return ringo::main(), 0; }","link":"/luogu4131/"},{"title":"洛谷4514 - 上帝造题的七分钟","text":"丢一发友链就跑 https://www.cnblogs.com/xuanyi/p/9010816.html qaq。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;int read() { int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;}char readc() { char c = getchar(); while (!isupper(c) &amp;&amp; !islower(c) &amp;&amp; c != EOF) c = getchar(); return c;}#define lowbit(x) ((x)&amp;(-(x)))const int maxn = 3010;int n, m, a, b, c, d, x, ans;int s[4][maxn][maxn];char opt;void modify(int a, int b, int x) { for (int i = a; i &lt;= n; i += lowbit(i)) for (int j = b; j &lt;= m; j += lowbit(j)) { s[0][i][j] += x; s[1][i][j] += x * a; s[2][i][j] += x * b; s[3][i][j] += x * a * b; }}int query(int a, int b) { int ans = 0; for (int i = a; i; i -= lowbit(i)) for (int j = b; j; j -= lowbit(j)) { ans += s[0][i][j] * a * b; ans -= s[1][i][j] * b; ans -= s[2][i][j] * a; ans += s[3][i][j]; } return ans;}int main() { n = read(), m = read(); while ((opt = readc()) != EOF) { if (opt == 'L') { a = read(), b = read(), c = read(), d = read(), x = read(); modify(a, b, x); modify(a, d + 1, -x); modify(c + 1, b, -x); modify(c + 1, d + 1, x); } else { a = read(), b = read(), c = read(), d = read(), ans = 0; ans += query(a, b); ans -= query(a, d + 1); ans -= query(c + 1, b); ans += query(c + 1, d + 1); printf(\"%d\\n\", ans); } } return 0;}","link":"/luogu4514/"},{"title":"洛谷4826 - [USACO15FEB]Superbull 超级牛","text":"把淘汰赛问题转换为一棵生成树，每一条边相当于一个二选一淘汰的过程。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;ll read() { ll x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;}const int maxn = 2010;ll n, cnt, ans;ll a[maxn], fa[maxn];struct edge { ll u, v, w; edge () {} edge (ll a, ll b, ll c) { u = a, v = b, w = c; }} e[2000010];bool operator &lt; (edge a, edge b) { return a.w &gt; b.w;}ll find(ll x) { if (fa[x] == x) return x; return fa[x] = find(fa[x]);}int main() { n = read(); for (int i = 1; i &lt;= n; i++) a[i] = read(); for (int i = 1; i &lt;= n; i++) for (int j = i + 1; j &lt;= n; j++) e[++cnt] = edge(i, j, a[i] ^ a[j]); sort(e + 1, e + cnt + 1); for (int i = 1; i &lt;= n; i++) fa[i] = i; for (int i = 1; i &lt;= cnt; i++) if (find(e[i].u) != find(e[i].v)) { fa[find(e[i].u)] = find(e[i].v); ans += e[i].w; } printf(\"%lld\\n\", ans); return 0;}","link":"/luogu4826/"},{"title":"洛谷4385 - [COCI2009]Dvapravca","text":"今天模拟赛的第三题（又达成了原题考试的成就）。考场的时候由于 T2 调太久这题暴力都没写… 现在依然不会正解于是写了个随机化算法 AC 。 每次随机两个点，然后计算出他们的连线的斜率，每次 $O(n)$ 判断一下选取与这条直线平行的两条直接的答案，随机个次几万次w就过了… 这里可能有个细节问题，也就是说我们每次选出的两个点中可能有不合法的点，实际上影响不大，因为我们可以通过略倾斜直线来取到另一个合法的点。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// =================================// author: memset0// date: 2019.01.07 16:15:49// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;#define ll long longnamespace ringo {template &lt;class T&gt; inline void read(T &amp;x) { x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;}template &lt;class T&gt; inline void print(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);}template &lt;class T&gt; inline void print(T x, char c) { print(x), putchar(c); }const int N = 1e3 + 10;const double inf = 1e30;int n, ans, now;struct node { int x, y; inline bool operator == (const node &amp;other) const { return x == other.x &amp;&amp; y == other.y; }};std::vector &lt;node&gt; a, b, c;int solve() { int ans = 0, __1 = rand() % c.size(), __2 = rand() % c.size(); node _1 = c[__1], _2 = c[__2]; if (_1 == _2 || (__1 &gt; a.size() &amp;&amp; __2 &gt; a.size())) { rand(); return 0; } if (_1.x == _2.x) { int min = -1e9 - 10, max = 1e9 + 10; for (auto u : b) u.x &lt; _1.x ? min = std::max(min, u.x) : max = std::min(max, u.x); for (auto u : a) if (min &lt;= u.x &amp;&amp; u.x &lt;= max) ++ans; rand(); } else { double k = (_1.y - _2.y) / (double)(_1.x - _2.x); double _b = ((ll)_1.y * _2.x - (ll)_2.y * _1.x) / (double)(_2.x - _1.x); double min = -inf, max = inf; for (auto u : b) { double b = u.y - k * u.x; b &lt; _b ? min = std::max(min, b) : max = std::min(max, b); } for (auto u : a) { double b = u.y - k * u.x; if (min &lt;= b &amp;&amp; b &lt;= max) ++ans; } } return ans;}void main() { srand(20040725); read(n); for (int i = 1, x, y, c; i &lt;= n; i++) { read(x), read(y), c = getchar(); if (c == 'R') a.push_back((node){x, y}); else b.push_back((node){x, y}); } for (auto u : a) c.push_back(u); for (auto u : b) c.push_back(u); int limit = 130000000 / n; while (limit--) ans = std::max(ans, solve()); print(ans, '\\n');}} signed main() { return ringo::main(), 0; }","link":"/luogu4385/"},{"title":"洛谷4768 -  [NOI2018]归程","text":"真是纳闷，为什么这题在 BZOJ 上是权限题？？？ 首先你需要了解一下 这种算法，然后你在重构树上树形 DP 处理出子树中距离的最小值，最后对于每次询问倍增找出最高点回答即可。 过程就不详细说啦，相信在坐的各位大佬早就会啦。。。 不过也有 sqq 这种巨佬写了可持久化并查集 AC 了的 QAQ ，下次写写。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;int read() { int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;}const int N = 200010, N2 = 400010, N3 = 800010;int T, n, m, u, v, w, c, p, l, k, s;int fu, fv, pos, lastans;int fa[N2], f[N2][20], g[N2][20], dis[N2], lim[N2];bool vis[N];int tot, hed[N2], nxt[N3], to[N3], val[N3];struct edge { int u, v, w, c; edge () {} edge (int _u, int _v, int _w, int _c) { u = _u, v = _v, w = _w, c = _c; }} e[N2];bool operator &lt; (const edge &amp;a, const edge &amp;b) { return a.c &gt; b.c;}struct status { int u, w; status () {} status (int _u, int _w) { u = _u, w = _w; }};bool operator &lt; (const status &amp;a, const status &amp;b) { return a.w &gt; b.w;}priority_queue &lt; status &gt; q;int find(int x) { if (fa[x] == x) return x; return fa[x] = find(fa[x]);}void add_edge(int u, int v, int w = 0) { nxt[tot] = hed[u], to[tot] = v, val[tot] = w; hed[u] = tot++;}void dfs(int u) { for (int i = hed[u], v = to[i]; i; i = nxt[i], v = to[i]) if (v != f[u][0]) { f[v][0] = u; g[v][0] = lim[u]; dfs(v); dis[u] = ~dis[u] &amp;&amp; dis[u] &lt; dis[v] ? dis[u] : dis[v]; }}void solve() { n = read(), m = read(); for (int i = 1; i &lt;= m; i++) { u = read(), v = read(), w = read(), c = read(); add_edge(u, v, w), add_edge(v, u, w); e[i] = edge(u, v, w, c); } q.push(status(1, 0)), dis[1] = 0; while (q.size()) { u = q.top().u, q.pop(); if (vis[u]) continue; vis[u] = 1; for (int i = hed[u], v = to[i]; i; i = nxt[i], v = to[i]) if (!~dis[v] || dis[u] + val[i] &lt; dis[v]) { dis[v] = dis[u] + val[i]; q.push(status(v, dis[v])); } } sort(e + 1, e + m + 1); tot = 2, memset(hed, 0, sizeof(hed)); for (int i = 1; i &lt;= n &lt;&lt; 1; i++) fa[i] = i; for (int i = 1; i &lt;= m; i++) { u = e[i].u, v = e[i].v, w = e[i].w, c = e[i].c; if ((fu = find(u)) == (fv = find(v))) continue; lim[n + (++pos)] = c, fa[fu] = fa[fv] = n + pos; add_edge(fu, n + pos), add_edge(n + pos, fu); add_edge(fv, n + pos), add_edge(n + pos, fv); } dfs(n + pos); for (int i = 1; i &lt;= 19; i++) for (int j = 1; j &lt;= n &lt;&lt; 1; j++) { f[j][i] = f[f[j][i - 1]][i - 1]; g[j][i] = g[f[j][i - 1]][i - 1]; } p = read(), k = read(), s = read(); for (int i = 1; i &lt;= p; i++) { u = (read() + k * lastans - 1) % n + 1; l = (read() + k * lastans) % (s + 1); for (int i = 19; i &gt;= 0; i--) if (f[u][i] &amp;&amp; l &lt; g[u][i]) { u = f[u][i]; } printf(\"%d\\n\", lastans = (~dis[u] ? dis[u] : -1)); }}void init() { tot = 2, pos = lastans = 0; while (q.size()) q.pop(); memset(f, 0, sizeof(f)); memset(g, 0, sizeof(g)); memset(hed, 0, sizeof(hed)); memset(vis, 0, sizeof(vis)); memset(dis, -1, sizeof(dis));}int main() { T = read(); while (T--) { init(); solve(); } return 0;}","link":"/luogu4768/"},{"title":"洛谷4606 - [SDOI2018]战略游戏","text":"先考虑 $|S| = 2$ 的情况：把原图缩成一棵圆方树，查询两点路径上的圆点个数（除去这两个点本身）。我们可以很方便的把这个性质拓展到 $|S|$ 为任意值的的情况，只要先差分出圆方树上每个点到根节点的圆点个数，然后把每次查询的点建出虚树，进行简单的树上差分即可。需要注意的是多组数据间的变量初始化，以及圆方树的节点个数是原来的两倍。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119// =================================// author: memset0// date: 2018.12.23 20:16:50// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;#define walk(i, u, v, G) for (int i = G.hed[u], v = G.to[i]; i; i = G.nxt[i], v = G.to[i])#define rep(i, l, r) for (register int i = l; i &lt;= r; i++)namespace ringo {typedef long long ll;typedef unsigned long long ull;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;}template &lt;class T&gt; inline void print(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);}template &lt;class T&gt; inline void maxd(T &amp;a, T b) { if (b &gt; a) a = b; }template &lt;class T&gt; inline void mind(T &amp;a, T b) { if (b &lt; a) a = b; }template &lt;class T&gt; inline void print(T x, char c) { print(x), putchar(c); }template &lt;class T&gt; inline T abs(const T &amp;a) { if (a &lt; 0) return -a; return a; }const int N = 2e5 + 10, M = 4e5 + 10;int T, n, m, i, u, v, p, top, cnt, tim, nod;int a[N], in[N], fa[N], pre[N], ins[N], out[N], dep[N], stk[N], dfn[N], low[N], f[N][20];std::vector &lt;int&gt; rub;struct graph { int tot, hed[N], nxt[M], to[M]; graph () { tot = 2; } void init() { tot = 2, memset(hed, 0, sizeof(hed)); } inline void add_edge(int u, int v) { nxt[tot] = hed[u], to[tot] = v, hed[u] = tot++; nxt[tot] = hed[v], to[tot] = u, hed[v] = tot++; }} G1, G2, G3;inline int cmp(int a, int b) { return in[a] &lt; in[b]; }inline int lca(int u, int v) { if (dep[u] &gt; dep[v]) std::swap(u, v); for (int i = 19; i &gt;= 0; i--) if (dep[f[v][i]] &gt;= dep[u]) v = f[v][i]; if (u == v) return u; for (int i = 19; i &gt;= 0; i--) if (f[u][i] != f[v][i]) u = f[u][i], v = f[v][i]; return f[u][0];}void tarjan(int u, int father) { dfn[u] = low[u] = ++tim, stk[++top] = u, ins[u] = 1; walk(i, u, v, G1) if (!dfn[v]) { tarjan(v, u), mind(low[u], low[v]); if (low[v] &gt;= dfn[u]) { G2.add_edge(u, ++nod); int x; do { x = stk[top--]; G2.add_edge(x, nod), ins[x] = false; } while (x != v); } } else if (ins[v] &amp;&amp; v != father) mind(low[u], dfn[v]);}void build(int u, int sum) { in[u] = ++tim, pre[u] = (sum += u &lt;= n); walk(i, u, v, G2) if (v != f[u][0]) { f[v][0] = u, dep[v] = dep[u] + 1; build(v, sum); } out[u] = ++tim;}int dp(int u, int father) { int sum = u &lt;= n; walk(i, u, v, G3) if (v != father) sum += dp(v, u) + pre[f[v][0]] - pre[u]; return sum;}void main() { for (read(T); T--; ) { top = tim = f[1][0] = 0, G1.init(), G2.init(); memset(ins, 0, sizeof(ins)); memset(dfn, 0, sizeof(dfn)); read(n), read(m); for (int i = 1; i &lt;= m; i++) read(u), read(v), G1.add_edge(u, v); dep[1] = 1, nod = n, tarjan(1, 0), tim = 0, build(1, 0), top = 0; for (int i = 1; i &lt; 20; i++) for (int j = 1; j &lt;= nod; j++) f[j][i] = f[f[j][i - 1]][i - 1]; read(m); for (int i = 1; i &lt;= m; i++) { rub.clear(), G3.tot = 2, top = 0, rub.push_back(1); read(p); for (int i = 1; i &lt;= p; i++) read(a[i]); std::sort(a + 1, a + p + 1, cmp); for (int i = 1, u, v; i &lt;= p; i++) { u = a[i]; while (top &gt; 1 &amp;&amp; in[u] &lt; in[stk[top - 1]] &amp;&amp; out[stk[top - 1]] &lt; out[u]) G3.add_edge(stk[top - 1], stk[top]), top--; if (in[u] &lt; in[stk[top]] &amp;&amp; out[stk[top]] &lt; out[u]) G3.add_edge(u, stk[top--]); v = lca(u, stk[top]); while (top &gt; 1 &amp;&amp; in[v] &lt; in[stk[top - 1]] &amp;&amp; out[stk[top - 1]] &lt; out[v]) G3.add_edge(stk[top - 1], stk[top]), top--; if (in[v] &lt; in[stk[top]] &amp;&amp; out[stk[top]] &lt; out[v]) G3.add_edge(v, stk[top--]); if (stk[top] != v) stk[++top] = v, rub.push_back(v); if (stk[top] != u) stk[++top] = u, rub.push_back(u); } for (int i = 1; i &lt; top; i++) G3.add_edge(stk[i], stk[i + 1]); print(dp(stk[1], 0) - p, '\\n'); for (int i : rub) G3.hed[i] = 0; } }}} signed main() { return ringo::main(), 0; }","link":"/luogu4606/"},{"title":"洛谷4949 - 最短距离","text":"本题大概是一个基环树上带修改边权的最短距离。可以把他看做一棵树，把多的那条边拎出来，树剖维护距离，分类讨论即可。大概是你谷蓝题难度吧。 由于树剖只需要查询 dfs 序上区间最小值，可以考虑树状数组维护常熟较小。目前不卡常的情况下你谷效率 rk1 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long long#define rep(i,l,r) for (int i = l; i &lt;= r; i++)#define getc(x) getchar(x)#define putc(x) putchar(x)template &lt;typename T&gt; inline void read(T &amp;x) { x = 0; register char ch; register bool fl = 0; while (ch = getc(), ch &lt; 48 || 57 &lt; ch) fl ^= ch == '-'; x = (ch &amp; 15); while (ch = getc(), 47 &lt; ch &amp;&amp; ch &lt; 58) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch &amp; 15); if (fl) x = -x;}template &lt;typename T&gt; inline void readc(T &amp;x) { while (x = getc(), !islower(x) &amp;&amp; !isupper(x));}template &lt;typename T&gt; inline void print(T x, char c = ' ') { static int buf[40]; if (x == 0) { putc('0'); putc(c); return; } if (x &lt; 0) putc('-'), x = -x; for (buf[0] = 0; x; x /= 10) buf[++buf[0]] = x % 10 + 48; while (buf[0]) putc((char) buf[buf[0]--]); putc(c);}const int maxn = 100010;int n, m, x, y, u, v, w, tu, tv, tw, opt, ans, pos;int a[maxn], s[maxn], cst[maxn], tmp[maxn];int fa[maxn], id[maxn], top[maxn], son[maxn], wid[maxn], dep[maxn], siz[maxn];bool vis[maxn];int tot = 2, hed[maxn], to[maxn &lt;&lt; 1], val[maxn &lt;&lt; 1], nxt[maxn &lt;&lt; 1];struct edge { int u, v, w;} e[maxn];void dfs1(int u) { vis[u] = siz[u] = 1; for (int i = hed[u], v = to[i]; i; i = nxt[i], v = to[i]) if (!vis[v]) { fa[v] = u, dep[v] = dep[u] + 1, cst[v] = val[i]; dfs1(v); siz[u] += siz[v]; if (siz[v] &gt; siz[son[u]]) son[u] = v; } else if (v != fa[u]) { tu = u, tv = v, tw = val[i]; }}void dfs2(int u, int toppoint) { top[u] = toppoint, id[u] = ++pos, wid[id[u]] = u; if (siz[u] == 1) return; dfs2(son[u], toppoint); for (int i = hed[u], v = to[i]; i; i = nxt[i], v = to[i]) if (v != fa[u] &amp;&amp; v != son[u] &amp;&amp; !(u == tu &amp;&amp; v == tv) &amp;&amp; !(u == tv &amp;&amp; v == tu)) dfs2(v, v);}int lca(int u, int v) { while (top[u] != top[v]) { if (dep[top[u]] &gt; dep[top[v]]) std::swap(u, v); v = fa[top[v]]; } if (dep[u] &gt; dep[v]) std::swap(u, v); return u;}void modify(int k, int w) { for (int i = k; i &lt;= n; i += i &amp; -i) s[i] += w - tmp[k]; tmp[k] = w;}int query(int l, int r) { int ret = 0; for (int i = r; i; i -= i &amp; -i) ret += s[i]; for (int i = l - 1; i; i -= i &amp; -i) ret -= s[i]; return ret;}int query_path_to_root(int u, int v) { int ret = 0; while (top[u] != top[v]) { ret += query(id[top[u]], id[u]); u = fa[top[u]]; } if (u != v) ret += query(id[son[v]], id[u]); return ret;}int query_path(int u, int v) { int ret = 0, t = lca(u, v); ret += query_path_to_root(u, t); ret += query_path_to_root(v, t); return ret;}int main() { read(n), read(m); for (int i = 1; i &lt;= n; i++) { read(u), read(v), read(w); e[i] = edge{u, v, w}; nxt[tot] = hed[u], to[tot] = v, val[tot] = w, hed[u] = tot++; nxt[tot] = hed[v], to[tot] = u, val[tot] = w, hed[v] = tot++; } dfs1(1), dfs2(1, 1); for (int i = 1; i &lt;= n; i++) for (int j = id[i]; j &lt;= n; j += j &amp; -j) s[j] += cst[i]; for (int i = 1; i &lt;= n; i++) tmp[id[i]] = cst[i]; for (int i = 1; i &lt;= m; i++) { read(opt), read(x), read(y); if (opt == 1) { u = e[x].u, v = e[x].v; if ((u == tu &amp;&amp; v == tv) || (u == tv &amp;&amp; v == tu)) { tw = y; } else { u = dep[u] &gt; dep[v] ? u : v; modify(id[u], y); } } else { ans = query_path(x, y); ans = std::min(ans, query_path(x, tu) + query_path(tv, y) + tw); ans = std::min(ans, query_path(y, tu) + query_path(tv, x) + tw); print(ans, '\\n'); } } return 0;}","link":"/luogu4949/"},{"title":"洛谷4839 - P哥的桶","text":"每个点维护线性基，线段树的两个子节点合并的时候直接把一个点的暴力插入到隔壁即可。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// =================================// author: memset0// date: 2019.01.14 16:12:11// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;#define ll long longnamespace ringo {template &lt;class T&gt; inline void read(T &amp;x) { x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;}template &lt;class T&gt; inline void print(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);}template &lt;class T&gt; inline void print(T x, char c) { print(x), putchar(c); }const int N = 5e4 + 10;int n, m;struct info { int f[31]; inline void insert(int x) { for (int i = 30; i &gt;= 0; i--) if ((x &gt;&gt; i) &amp; 1) { if (f[i]) x ^= f[i]; else return (void)(f[i] = x); } } inline int calc() { int ans = 0; for (int i = 30; i &gt;= 0; i--) if (!((ans &gt;&gt; i) &amp; 1)) ans ^= f[i]; return ans; }};inline info merge(const info &amp;a, const info &amp;b) { static info f; f = a; for (int i = 0; i &lt;= 30; i++) f.insert(b.f[i]); return f;}struct node { int l, r, mid; info x;} p[N &lt;&lt; 2];void build(int u, int l, int r) { p[u].l = l, p[u].r = r, p[u].mid = (l + r) &gt;&gt; 1; if (l == r) return; build(u &lt;&lt; 1, l, p[u].mid); build(u &lt;&lt; 1 | 1, p[u].mid + 1, r);}void insert(int u, int k, int x) { if (p[u].l == p[u].r) return p[u].x.insert(x); if (k &lt;= p[u].mid) insert(u &lt;&lt; 1, k, x); else insert(u &lt;&lt; 1 | 1, k, x); p[u].x = merge(p[u &lt;&lt; 1].x, p[u &lt;&lt; 1 | 1].x);}info query(int u, int l, int r) { if (p[u].l == l &amp;&amp; p[u].r == r) return p[u].x; if (r &lt;= p[u].mid) return query(u &lt;&lt; 1, l, r); if (l &gt; p[u].mid) return query(u &lt;&lt; 1 | 1, l, r); return merge(query(u &lt;&lt; 1, l, p[u].mid), query(u &lt;&lt; 1 | 1, p[u].mid + 1, r));}void main() { read(n), read(m); build(1, 1, m); for (int i = 1, k, x, l, r, opt; i &lt;= n; i++) { read(opt); if (opt == 1) { read(k), read(x); insert(1, k, x); } else { read(l), read(r); print(query(1, l, r).calc(), '\\n'); } }}} signed main() { return ringo::main(), 0; }","link":"/luogu4839/"},{"title":"洛谷4841 - 城市规划","text":"想 LJC00118 NOIP 考前就秒切了这题，memset0 又又又被吊打.jpg。 考虑有标号无向图的生成函数：$f(x) = \\sum\\limits_{i=0}^{\\infty} 2^{n \\choose i} \\frac{x^n}{n!} $。 考虑有标号无向联通图的生成函数 $g(x)$ ，容易证明 $exp(g(x)) = f(x)$ 。 此题需求 $g(x)$ ，那么直接多项式 $\\ln$ 即可。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// =================================// author: memset0// date: 2019.01.30 21:12:55// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;#define int long long#define rep(i, l, r) for (int i = l; i &lt; r; i++)#define ll long longnamespace ringo {template &lt;class T&gt; inline void read(T &amp;x) { x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;}template &lt;class T&gt; inline void print(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);}template &lt;class T&gt; inline void print(T x, char c) { print(x), putchar(c); }const int N = 130010 &lt;&lt; 2, mod = 1004535809;int n, a[N], b[N], w[N], rev[N], fac[N], inv_fac[N];inline int dec(int a, int b) { a -= b; return a &lt; 0 ? a + mod : a; }inline int sub(int a, int b) { a += b; return a &gt;= mod ? a - mod : a; }int inv(int x) { return !x || x == 1 ? 1 : (ll)(mod - mod / x) * inv(mod % x) % mod; }inline int fpow(int a, int b) { int s = 1; for (; b; b &gt;&gt;= 1, a = (ll)a * a % mod) if (b &amp; 1) s = (ll)s * a % mod; return s; }inline void pOut(int *a, int n) { for (int i = 0; i &lt; n; i++) print(a[i], \" \\n\"[i == n - 1]); }inline void pInt(int *f, int *g, int n) { for (int i = 1; i &lt; n; i++) g[i - 1] = (ll)f[i] * i % mod; }inline void pDer(int *f, int *g, int n) { for (int i = 0; i &lt; n - 1; i++) g[i + 1] = (ll)f[i] * inv(i + 1) % mod; }inline void ntt(int *a, int lim) { for (int i = 0; i &lt; lim; i++) if (i &lt; rev[i]) std::swap(a[i], a[rev[i]]); for (int len = 1; len &lt; lim; len &lt;&lt;= 1) for (int i = 0; i &lt; lim; i += (len &lt;&lt; 1)) for (int j = 0; j &lt; len; j++) { int x = a[i + j], y = (ll)a[i + j + len] * w[j + len] % mod; a[i + j] = sub(x, y), a[i + j + len] = dec(x, y); }}inline int pInit(int len) { int lim = 1, k = 0; while (lim &lt; len) lim &lt;&lt;= 1, ++k; for (int i = 0; i &lt; lim; i++) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (k - 1)); for (int len = 1, wn; len &lt; lim; len &lt;&lt;= 1) { wn = fpow(3, (mod - 1) / (len &lt;&lt; 1)), w[len] = 1; for (int i = 1; i &lt; len; i++) w[i + len] = (ll)w[i + len - 1] * wn % mod; } return lim;}inline void pMul(int *f, int *g, int *ans, int n, int m, int len) { int lim = pInit(n + m), inv_lim = inv(lim); rep(i, 0, n) a[i] = f[i]; rep(i, n, lim) a[i] = 0; rep(i, 0, m) b[i] = g[i]; rep(i, m, lim) b[i] = 0; ntt(a, lim), ntt(b, lim); for (int i = 0; i &lt; lim; i++) a[i] = (ll)a[i] * b[i] % mod; std::reverse(a + 1, a + lim), ntt(a, lim); for (int i = 0; i &lt; len; i++) ans[i] = (ll)a[i] * inv_lim % mod;}inline void pInv(int *f, int *g, int n) { g[0] = inv(f[0]), memset(a, 0, sizeof(a)), memset(b, 0, sizeof(b)); for (int len = 2; (len &gt;&gt; 1) &lt; n; len &lt;&lt;= 1) { int lim = pInit(len &lt;&lt; 1), inv_lim = inv(lim); for (int i = 0; i &lt; len; i++) a[i] = f[i], b[i] = g[i]; ntt(a, lim), ntt(b, lim); for (int i = 0; i &lt; lim; i++) a[i] = (ll)a[i] * b[i] % mod * b[i] % mod; std::reverse(a + 1, a + lim), ntt(a, lim); for (int i = 0; i &lt; len; i++) g[i] = ((g[i] &lt;&lt; 1) - (ll)a[i] * inv_lim % mod + mod) % mod; }}inline void pLn(int *f, int *g, int n) { static int a[N], b[N], c[N]; pInv(f, a, n), pInt(f, b, n), pMul(a, b, c, n, n, n), pDer(c, g, n);}void main() { static int f[N], g[N]; read(n), ++n, f[0] = f[1] = fac[0] = fac[1] = inv_fac[0] = inv_fac[1] = 1; for (int i = 2; i &lt; n; i++) fac[i] = (ll)fac[i - 1] * i % mod; for (int i = 2; i &lt; n; i++) inv_fac[i] = (ll)(mod - mod / i) * inv_fac[mod % i] % mod; for (int i = 2; i &lt; n; i++) inv_fac[i] = (ll)inv_fac[i - 1] * inv_fac[i] % mod; for (int i = 2; i &lt; n; i++) f[i] = (ll)fpow(2, (ll)i * (i - 1) / 2 % (mod - 1)) * inv_fac[i] % mod; pLn(f, g, n), print((ll)g[n - 1] * fac[n - 1] % mod, '\\n');}} signed main() { return ringo::main(), 0; }","link":"/luogu4841/"},{"title":"洛谷5068 - [Ynoi2015]我回来了","text":"一道 bitset 傻逼题。随便乱搞一下就好了，跑的飞快。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// =================================// author: memset0// date: 2019.01.11 18:20:48// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;#define pb push_back#define rep(i, l, r) for (register int i = l; i &lt;= r; i++)namespace ringo {typedef long long ll;typedef unsigned long long ull;inline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return (s == t ? t = (s = buf) + fread(buf, 1, IN_LEN, stdin), (s == t ? -1 : *s++) : *s++);}template &lt;class T&gt; inline void read(T &amp;x) { static bool f; static char c; for (f = 0, c = read(); !isdigit(c); c = read()) { f ^= c == '-'; if (c == -1) return; } for (x = 0; isdigit(c); c = read()) x = ((x + (x &lt;&lt; 2)) &lt;&lt; 1) + (c ^ '0'); if (f) x = -x;}const int OUT_LEN = 10000000; char obuf[OUT_LEN], *ooh = obuf;inline void print(char c) { if (ooh == obuf + OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), ooh = obuf; *ooh++ = c;}template&lt;class T&gt; inline void print(T x) { static int buf[30], cnt; if (!x) { print('0'); return; } if (x &lt; 0) print('-'), x = -x; for (cnt = 0; x; x /= 10) buf[++cnt] = x % 10 + '0'; while (cnt) print((char)buf[cnt--]);}inline void flush() { fwrite(obuf, 1, ooh - obuf, stdout); }template &lt;class T&gt; inline void maxd(T &amp;a, T b) { if (b &gt; a) a = b; }template &lt;class T&gt; inline void mind(T &amp;a, T b) { if (b &lt; a) a = b; }template &lt;class T&gt; inline void print(T x, char c) { print(x), print(c); }template &lt;class T&gt; inline T abs(const T &amp;a) { if (a &lt; 0) return -a; return a; }const size_t N = 1010;int n, m, q, t, limit[N];bool vis[N];std::bitset &lt;N&gt; ans, bit[N][N];std::vector &lt;int&gt; now[2], G[N];void main() { read(n), read(m), read(q); for (int i = 1, u, v; i &lt;= m; i++) { read(u), read(v); G[u].push_back(v); G[v].push_back(u); } for (int s = 1; s &lt;= n; ++s) { memset(vis, 0, sizeof(vis)); bit[s][0].set(s), now[1].push_back(s), vis[s] = 1; for (int i = 1; now[i &amp; 1].size(); ++i) { bit[s][i] = bit[s][i - 1]; for (auto u : now[i &amp; 1]) for (auto v : G[u]) if (!vis[v]) { vis[v] = 1, bit[s][i].set(v); now[i &amp; 1 ^ 1].push_back(v); } now[i &amp; 1].clear(), limit[s] = i; } } for (int i = 1, x, y; i &lt;= q; i++) { ans.reset(); for (read(t); t--; ) { read(x), read(y); ans |= bit[x][std::min(y, limit[x])]; } print(ans.count(), '\\n'); }}} signed main() { return ringo::main(), ringo::flush(), 0; }","link":"/luogu5068/"},{"title":"洛谷5029 - T'ill It's Over","text":"做那么多水题，会不会被婊… 还是网络流，只不过这次我们需要从一个区间连到另一个区间，那么就是个典型的线段树优化建边。需要注意一些小细节。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// luogu-judger-enable-o2// =================================// author: memset0// date: 2019.01.28 10:42:07// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;#define int long long#define ll long longnamespace ringo {template &lt;class T&gt; inline void read(T &amp;x) { x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;}template &lt;class T&gt; inline void print(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);}template &lt;class T&gt; inline void print(T x, char c) { print(x), putchar(c); }const int N = 1e5 + 10, M = 2e4 + 10, inf = 1e9, Nd = 8e5, Ed = 2e6;int n, m, k, s, e, cnt;int at[N][2], pre[Nd], cur[Nd], gap[Nd], dep[Nd];int tot = 2, hed[Nd], nxt[Ed], val[Ed], to[Ed];struct Node { int l, r, mid, id[2];} p[N &lt;&lt; 2];inline void add(int u, int v, int w) { nxt[tot] = hed[u], to[tot] = v, val[tot] = w, hed[u] = tot++; nxt[tot] = hed[v], to[tot] = u, val[tot] = 0, hed[v] = tot++;}void build(int l, int r, int u) { p[u].l = l, p[u].r = r, p[u].mid = (l + r) &gt;&gt; 1, p[u].id[0] = ++cnt, p[u].id[1] = ++cnt, add(p[u].id[1], p[u].id[0], inf); if (l == r) { at[l][0] = p[u].id[0], at[l][1] = p[u].id[1]; return; } build(l, p[u].mid, u &lt;&lt; 1), build(p[u].mid + 1, r, u &lt;&lt; 1 | 1); add(p[u &lt;&lt; 1].id[0], p[u].id[0], inf), add(p[u &lt;&lt; 1 | 1].id[0], p[u].id[0], inf); add(p[u].id[1], p[u &lt;&lt; 1].id[1], inf), add(p[u].id[1], p[u &lt;&lt; 1 | 1].id[1], inf);}void link(int l, int r, int v, bool rev, int u = 1) { if (p[u].l == l &amp;&amp; p[u].r == r) { rev ? add(v, p[u].id[1], inf) : add(p[u].id[0], v, inf); return; } if (r &lt;= p[u].mid) link(l, p[u].mid, v, rev, u &lt;&lt; 1); else if (l &gt; p[u].mid) link(p[u].mid + 1, r, v, rev, u &lt;&lt; 1 | 1); else link(l, p[u].mid, v, rev, u &lt;&lt; 1), link(p[u].mid + 1, r, v, rev, u &lt;&lt; 1 | 1);}int isap() { int ans = 0, flow, u = s, flag; gap[0] = cnt; while (dep[s] &lt; cnt) { flag = 0; for (int &amp;i = cur[u]; i; i = nxt[i]) if (val[i] &amp;&amp; dep[u] == dep[to[i]] + 1) { flag = 1, u = to[i]; pre[u] = i; break; } if (!flag) { if (!--gap[dep[u]]) break; dep[u] = cnt; for (int i = hed[u]; i; i = nxt[i]) if (val[i] &amp;&amp; dep[u] &gt; dep[to[i]] + 1) dep[u] = dep[to[i]] + 1, cur[u] = hed[u]; ++gap[dep[u]]; if (u != s) u = to[pre[u] ^ 1]; } else if (u == e) { flow = inf; for (int i = pre[e]; i; i = pre[to[i ^ 1]]) flow = std::min(flow, val[i]); for (int i = pre[e]; i; i = pre[to[i ^ 1]]) val[i] -= flow, val[i ^ 1] += flow; ans += flow, u = s; } } return ans;}void main() { read(n), read(m), read(k); build(1, k, 1), add(s = ++cnt, at[1][0], n), add(at[k][1], e = ++cnt, n); for (int i = 1, a, b, a1, a2, b1, b2, op, lim; i &lt;= m; i++) { read(op), read(lim); if (op == 1) read(a), read(b), add(at[a][0], at[b][1], lim); else if (op == 2) read(a1), read(a2), read(b), link(a1, a2, ++cnt, 0), add(cnt, at[b][1], lim); else if (op == 3) read(a), read(b1), read(b2), link(b1, b2, ++cnt, 1), add(at[a][0], cnt, lim); else read(a1), read(a2), read(b1), read(b2), link(a1, a2, ++cnt, 0), link(b1, b2, ++cnt, 1), add(cnt - 1, cnt, lim); } print(isap(), '\\n');}} signed main() { return ringo::main(), 0; }","link":"/luogu5029/"},{"title":"洛谷5071 - [Ynoi2015]此时此刻的光辉","text":"根据小学我们就学过的一个简单公式，如果 $x = \\prod p_i ^ { a_i } $ 那么 $x$ 因子个数为 $\\prod a_i + 1$ 。因此我们需要维护查询的区间内每一个质数的和。 考虑把原来的数分解，这一步我们只需要预处理出小于 $ \\sqrt { \\max {a_i} }$ 的质数即可。然后对于每个数 $ a_i $ 依次判断小于 $ a_i $ 的质数。复杂度 $ O( \\frac {n \\sqrt{\\max{a_i}}} {\\log n} )$ ，实际情况下表现非常优越。或者采用 Pollard-Rho 算法优化为 $ n \\times \\sum { a_i^{ 1 / 4 } }$ ，但实现会较为复杂而且没有必要。 接下来考虑分解出的质数如何处理，如果直接放在一起去莫队的话复杂度是 $ O(n \\sqrt n \\log n) $ ，如果常数不优秀的话会 TLE 。我们考虑一个优化方式，对于大小在前 $\\sqrt n$ 个的范围内的质数，预处理出个数，前缀和统计，不参与莫队，其余分解出的质数参与莫队，可以证明，每一个数需要参与莫队的数的个数是 $O(1)$ 级别的。这样的话复杂度降为 $n \\sqrt n$ ，事实上我们可以把范围由 $\\sqrt n$ 调整为 $100$ ~ $200$ 左右以获得一个较小的常数，跑到目前效率 rank 1。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134// =================================// author: memset0// date: 2018.12.09 20:57:04// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;namespace ringo {typedef long long ll;template &lt; class T &gt;inline void read(T &amp;x) { x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;}template &lt; class T &gt;inline void print(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);}template &lt; class T &gt;inline void print(T x, char c) { print(x), putchar(c);}const int N = 1e5 + 10, M = sqrt(1e9) + 10, L = 150, p = 19260817;int n, m, ul, ur, ql, qr, now = 1, pos, max, sqn, limit;int a[N], b[N], c[N], ans[N], bln[N], pri[N &lt;&lt; 1], lazy[N], cnt[N &lt;&lt; 1];bool vis[M];std::map &lt; int, int &gt; map;int inv[N * 20], sum[N][L + 1];struct pair { int first, second; pair () {} pair (int _first, int _second) { first = _first, second = _second; }};std::vector &lt; pair &gt; v[N];struct query { int l, r, i; inline bool operator &lt; (const query &amp;other) const { if (bln[l] == bln[other.l]) return bln[l] &amp; 1 ? r &gt; other.r : r &lt; other.r; return l &lt; other.l; }} q[N];inline void push_back(int k, int first, int second) { if (first &lt;= L) sum[k][first] += second; else v[k].push_back(pair(first, second));}inline void pre(int a, int k) { int cnt = 0; for (int i = 1; pri[i] * pri[i] &lt;= a &amp;&amp; i &lt;= pri[0]; i++) if (!(a % pri[i])) { cnt = 0; while (!(a % pri[i])) ++cnt, a /= pri[i]; push_back(k, i, cnt); } if (a != 1) { auto it = map.find(a); if (it == map.end()) map[a] = ++pos, pri[pos] = a, a = pos; else a = it-&gt;second; push_back(k, a, 1); }}inline void add(int x) { for (auto u : v[x]) { now = (ll)now * inv[cnt[u.first] % p] % p; cnt[u.first] += u.second; now = (ll)now * cnt[u.first] % p; }}inline void del(int x) { for (auto u : v[x]) { now = (ll)now * inv[cnt[u.first] % p] % p; cnt[u.first] -= u.second; now = (ll)now * cnt[u.first] % p; }}void main() { read(n), read(m), sqn = n / sqrt(m * 2.0 / 3); for (int i = 1; i &lt;= n; i++) { read(a[i]), b[i] = a[i]; max = std::max(max, a[i]); bln[i] = (i - 1) / sqn; } std::sort(b + 1, b + n + 1); int tn = std::unique(b + 1, b + n + 1) - b - 1; for (int i = 1; i &lt;= n; i++) c[i] = std::lower_bound(b + 1, b + tn + 1, a[i]) - b; limit = sqrt(max); for (int i = 2; i &lt;= limit; i++) { if (!vis[i]) pri[++pri[0]] = i, map[i] = pri[0]; for (int j = 1; j &lt;= pri[0] &amp;&amp; i * pri[j] &lt;= limit; j++) { vis[i * pri[j]] = 1; if (i % pri[j] == 0) break; } } pos = pri[0], max = 0; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= L; j++) sum[i][j] = sum[i - 1][j]; pre(a[i], i); for (auto u : v[i]) cnt[u.first] += u.second; } for (int i = 1; i &lt;= pos; i++) max = std::max(max, cnt[i]); inv[0] = inv[1] = 1, limit = max + 1; for (int i = 2; i &lt;= std::min(limit, p - 1); i++) inv[i] = (ll)(p - p / i) * inv[p % i] % p; for (int i = 1; i &lt;= pos; i++) cnt[i] = 1; for (int i = 1; i &lt;= m; i++) read(q[i].l), read(q[i].r), q[i].i = i; std::sort(q + 1, q + m + 1); ul = 1, ur = 0; for (int i = 1; i &lt;= m; i++) { ql = q[i].l, qr = q[i].r; while (ul &gt; ql) add(--ul); while (ur &lt; qr) add(++ur); while (ul &lt; ql) del(ul++); while (ur &gt; qr) del(ur--); ans[q[i].i] = now; for (int j = 1; j &lt;= L; j++) { ans[q[i].i] = (ll)ans[q[i].i] * (sum[qr][j] - sum[ql - 1][j] + 1) % p; } for (int i = 1; i &lt;= m; i++) print(ans[i], '\\n');}} signed main() { return ringo::main(), 0; }","link":"/luogu5071/"},{"title":"洛谷5046 - [YNOI2019] Yuno loves sqrt technology I","text":"一道卡常题。考虑分块。 如果查询的 $l$ 和 $r$ 不在同一个块内。 12查询区间 =&gt; ┌-----------------------------┐分好的块 =&gt; [.........][........][........][........][........][........] 把查询的区间分成三个部分、A（块前零散部分）、B（整块的）、C（块后零散部分） 先考虑每个部分自身与自身匹配对答案的贡献。我们可以预处理出从每个点出发，到所属块的开始 / 结尾的逆序对个数，分别用 lft[] 和 rit[] 表示，预处理时间复杂度 $O(\\sqrt n \\times \\sqrt n \\times \\log n)$。 123┌-----1.-----┐ 1. 这一部分的逆序对个数表示为 lft[i] ┌-----2.----┐ 2. 这一部分的逆序对个数表示为 rit[i][............i...........] 接下来我们考虑 A -&gt; B ， C -&gt; B 的贡献，类似于蒲公英这题，处理出 cnt[i][j] 数组表示前 $i$ 个块内小于等于 $j$ 的数字个数，查询时枚举 A 和 C 中的每一个数，利用这个前缀和查询对答案的贡献。这个部分也可以不在查询的时候做，而是预处理出结果，做二维前缀和，直接查询。 接下来考虑 A -&gt; C 的贡献，由于 A 和 C 是不重合的两个部分，可以采用类似归并排序的方法，把两个序列合并的同时计算出逆序对个数。 如果查询的 $l$ 和 $r$ 在同一个块内。 首先我们考虑，相邻的两个区间 A 和 B 。A 和 B 总共的逆序对个数，等于 A 内部的逆序对个数 + B 内部的逆序对个数 + A 对 B 贡献的逆序对个数。 好，那么我们再来考虑 $l$ 和 $r$ 在同一个块内： 1234┌------A+B-------┐ 这一部分即之前已经处理出的 lft[r]┌----A----┐ 这一部分即之前已经处理出的 lft[l] ┌--B---┐[.........l......r.......] 现在我们要求 B 的逆序对个数，只需要把 A + B 的逆序对个数减掉 A 内部的逆序对个数，再减掉 A 对 B 的逆序对个数即可。 剩下你只需要时间来卡常。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#pragma GCC diagnostic error \"-std=c++11\"#pragma GCC target(\"avx\")#pragma GCC optimize(3)#pragma GCC optimize(\"Ofast\")#pragma GCC optimize(\"inline\")#pragma GCC optimize(\"-fgcse\")#pragma GCC optimize(\"-fgcse-lm\")#pragma GCC optimize(\"-fipa-sra\")#pragma GCC optimize(\"-ftree-pre\")#pragma GCC optimize(\"-ftree-vrp\")#pragma GCC optimize(\"-fpeephole2\")#pragma GCC optimize(\"-ffast-math\")#pragma GCC optimize(\"-fsched-spec\")#pragma GCC optimize(\"unroll-loops\")#pragma GCC optimize(\"-falign-jumps\")#pragma GCC optimize(\"-falign-loops\")#pragma GCC optimize(\"-falign-labels\")#pragma GCC optimize(\"-fdevirtualize\")#pragma GCC optimize(\"-fcaller-saves\")#pragma GCC optimize(\"-fcrossjumping\")#pragma GCC optimize(\"-fthread-jumps\")#pragma GCC optimize(\"-funroll-loops\")#pragma GCC optimize(\"-fwhole-program\")#pragma GCC optimize(\"-freorder-blocks\")#pragma GCC optimize(\"-fschedule-insns\")#pragma GCC optimize(\"inline-functions\")#pragma GCC optimize(\"-ftree-tail-merge\")#pragma GCC optimize(\"-fschedule-insns2\")#pragma GCC optimize(\"-fstrict-aliasing\")#pragma GCC optimize(\"-fstrict-overflow\")#pragma GCC optimize(\"-falign-functions\")#pragma GCC optimize(\"-fcse-skip-blocks\")#pragma GCC optimize(\"-fcse-follow-jumps\")#pragma GCC optimize(\"-fsched-interblock\")#pragma GCC optimize(\"-fpartial-inlining\")#pragma GCC optimize(\"no-stack-protector\")#pragma GCC optimize(\"-freorder-functions\")#pragma GCC optimize(\"-findirect-inlining\")#pragma GCC optimize(\"-fhoist-adjacent-loads\")#pragma GCC optimize(\"-frerun-cse-after-loop\")#pragma GCC optimize(\"inline-small-functions\")#pragma GCC optimize(\"-finline-small-functions\")#pragma GCC optimize(\"-ftree-switch-conversion\")#pragma GCC optimize(\"-foptimize-sibling-calls\")#pragma GCC optimize(\"-fexpensive-optimizations\")#pragma GCC optimize(\"-funsafe-loop-optimizations\")#pragma GCC optimize(\"inline-functions-called-once\")#pragma GCC optimize(\"-fdelete-null-pointer-checks\")#include &lt;bits/stdc++.h&gt;#define il inline#define rg register#define ll long long#define getc getchar#define putc putchar#define rep(i, l, r) for (int i = l; i &lt;= r; ++i)namespace ringo {template &lt; class T &gt; il void read(T &amp;x) { x = 0; rg char c = getc(); rg bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getc(); while (isdigit(c)) x = x * 10 + c - '0', c = getc(); if (f) x = -x;}template &lt; class T &gt; il void print(T x) { if (x &lt; 0) putc('-'), x = -x; if (x &gt; 9) print(x / 10); putc('0' + x % 10);}const int N = 1e5 + 5, sqn = 320, M = sqn + 5, P = N / sqn + 5;int n, m, l, r, l1, l2, r1, r2, siz;int a[N], rnk[N], srt[N], bln[N], lft[N], rit[N], s[M], q1[M], q2[M], fst[P], cnt[P][N];ll ans, fur[P], sum[P][P], pre[P][N];bool tag[M];void modify(int k) { for (; k &lt;= siz; k += k &amp; -k) ++s[k]; }int query(int k) { int x = 0; for (; k; k -= k &amp; -k) x += s[k]; return x; }ll get(int a, int b, int c, int d) { return pre[b][d] - pre[b][c - 1] - pre[a - 1][d] + pre[a - 1][c - 1]; }int merge(int ll1, int rr1, int ll2, int rr2) { int l1 = 1, l2 = 1, r1 = 0, r2 = 0, ans = 0; memset(tag, 0, sizeof(tag)); for (rg int i = ll1; i &lt;= rr1; i++) tag[rnk[i]] = 1; for (rg int i = 1; i &lt;= fst[bln[l] + 1] - fst[bln[l]]; ++i) if (tag[i]) q1[++r1] = srt[fst[bln[l]] + i - 1]; memset(tag, 0, sizeof(tag)); for (rg int i = ll2; i &lt;= rr2; i++) tag[rnk[i]] = 1; for (rg int i = 1; i &lt;= fst[bln[r] + 1] - fst[bln[r]]; ++i) if (tag[i]) q2[++r2] = srt[fst[bln[r]] + i - 1]; while (l1 &lt;= r1 &amp;&amp; l2 &lt;= r2) if (q1[l1] &lt; q2[l2]) ++l1; else ++l2, ans += r1 - l1 + 1; return ans;}void main() { read(n), read(m); for (rg int i = 1; i &lt;= n; ++i) read(a[i]), srt[i] = a[i]; for (rg int i = 1; i &lt;= n; ++i) bln[i] = (i - 1) / sqn + 1; for (rg int i = 1; i &lt;= bln[n]; ++i) fst[i] = sqn * (i - 1) + 1; fst[bln[n] + 1] = n + 1; for (rg int i = 1; i &lt;= n; i++) ++cnt[bln[i]][a[i]]; for (rg int i = 1; i &lt;= bln[n]; i++) for (int j = 1; j &lt;= n; j++) cnt[i][j] += cnt[i - 1][j] + cnt[i][j - 1] - cnt[i - 1][j - 1]; for (rg int i = 1; i &lt;= bln[n]; i++) for (int j = 1; j &lt;= n; j++) pre[i][j] = pre[i][j - 1] + cnt[i][a[j] - 1]; for (rg int r = 1; r &lt;= bln[n]; r++) for (int l = 1; l &lt;= r; l++) { for (rg int j = fst[r]; j &lt; fst[r + 1]; j++) sum[l][r] += fst[r] - fst[l] - cnt[r - 1][a[j] - 1] + cnt[l - 1][a[j] - 1]; sum[l][r] += sum[l][r - 1]; } for (rg int i = 1; i &lt;= bln[n]; ++i) { siz = fst[i + 1] - fst[i], std::sort(srt + fst[i], srt + fst[i + 1]); for (rg int j = fst[i]; j &lt; fst[i + 1]; j++) rnk[j] = std::lower_bound(srt + fst[i], srt + fst[i + 1], a[j]) - srt - fst[i] + 1; memset(s, 0, sizeof(s)); for (rg int j = fst[i]; j &lt; fst[i + 1]; j++) lft[j] = (j == fst[i] ? 0 : lft[j - 1]) + j - fst[i] - query(rnk[j]), modify(rnk[j]); memset(s, 0, sizeof(s)); for (rg int j = fst[i + 1] - 1; j &gt;= fst[i]; j--) rit[j] = (j == fst[i + 1] - 1 ? 0 : rit[j + 1]) + query(rnk[j]), modify(rnk[j]); fur[i] = fur[i - 1] + rit[fst[i]]; } for (rg int i = 1, bl, br; i &lt;= m; ++i) { read(l), read(r); l ^= ans, r ^= ans; if (l &gt; r) std::swap(l, r); if (bln[l] == bln[r]) { ans = lft[r] - (l == fst[bln[l]] ? 0 : lft[l - 1]); ans -= merge(fst[bln[l]], l - 1, l, r); } else { bl = bln[l] + 1, br = bln[r] - 1; ans = rit[l] + lft[r] + sum[bl][br] - sum[bl][bl - 1] + fur[br] - fur[bl - 1]; ans += get(bl, br, l, fst[bl] - 1); ans -= get(bl, br, fst[br + 1], r); ans += (r - fst[br + 1] + 1) * (fst[br + 1] - fst[bl]); ans += merge(l, fst[bl] - 1, fst[br + 1], r); } print(ans), putc('\\n'); } std::cerr &lt;&lt; clock() / (double)CLOCKS_PER_SEC &lt;&lt; std::endl;}} int main() { return ringo::main(), 0; } （最近比较喜欢压行） 感谢您的阅读。","link":"/luogu5046/"},{"title":"洛谷5106 - dkw的lcm","text":"积性函数的定义： 如果 $(a,b) = 1$ ，那么 $f(ab) = f(a) \\times f(b)$ 。 显然欧拉函数是积性函数。 设 $lcm(i_1, i_2, …, i_k) = x$ ，我们把 $x$ 表示成 $x = \\prod {p_i ^ {a_i}}$ 的形式。对每个 $p_i ^ { a_i }$ 分开考虑，枚举每个质数与幂次，用简单容斥统计出每个 $\\varphi({p_i ^ {a_i}})$ 在答案中出现的次数，通过欧拉定理 + 快速幂计算答案。 假设我们当前枚举的质数为 $p^k$ ，我们把 $[1..n]$ 的数分成三个集合 $A, B, C$ 对于每个 $x \\in A$ ，当且仅当 $p^k \\not\\mid x$； 对于每个 $x \\in B$ ，当且仅当 $p^k \\mid x$ 且 $p^{k + 1} \\not\\mid x$ ； 对于每个 $x \\in C$ ，当且仅当 $p^{k+1} \\mid x$。 则答案中 $\\varphi({p^k})$ 的幂次相当于给 $k$ 个空位，只能放集合 $A$ 和 $B$ 中的元素且集合 $B$ 中的元素至少放一次的方案数，即 $(|A| + |B|)^k - |A|^k$，此处的值可能会超过 int 的存储范围，因而根据欧拉定理，对 $\\varphi(10^9+7) $ （即 $ 10^9+6$ ）取模。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// =================================// author: memset0// date: 2018.12.16 16:21:24// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;namespace ringo {typedef long long ll;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;}template &lt;class T&gt; inline void print(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);}template &lt;class T&gt; inline void maxd(T &amp;a, T b) { if (b &gt; a) a = b; }template &lt;class T&gt; inline void mind(T &amp;a, T b) { if (b &lt; a) a = b; }template &lt;class T&gt; inline void print(T x, char c) { print(x), putchar(c); }template &lt;class T&gt; inline T abs(const T &amp;a) { if (a &lt; 0) return -a; return a; }const int N = 1e6 + 10, M = 16777217, p = 1e9 + 7;int n, m, k, mi, ans = 1;int phi[M], pri[M / 10];int fpow(int a, int b, int p) { int s = 1; while (b) { if (b &amp; 1) s = (ll)s * a % p; b &gt;&gt;= 1, a = (ll)a * a % p; } return s;}void main() { read(n), read(k); phi[1] = 1; for (int i = 2; i &lt;= n; i++) { if (!phi[i]) { phi[i] = i - 1; pri[++pri[0]] = i; } for (int j = 1; j &lt;= pri[0] &amp;&amp; i * pri[j] &lt;= n; j++) { if (i % pri[j] == 0) { phi[i * pri[j]] = phi[i] * pri[j]; break; } else { phi[i * pri[j]] = phi[i] * (pri[j] - 1); } } } for (int i = 1; i &lt;= pri[0]; i++) { ll x = pri[i]; for (int j = 1, a, b; x &lt;= n; j++, x *= pri[i]) { a = n - n / x / pri[i]; b = - (n / x / pri[i]) + (n / x); // 请注意此处 a 、 b 变量分别为 |A| + |B|，|B| 。 mi = (fpow(a, k, p - 1) - fpow(a - b, k, p - 1) + p - 1) % (p - 1); ans = ((ll)ans * fpow(phi[x], mi, p)) % p; } } print(ans, '\\n');}} signed main() { return ringo::main(), 0; }","link":"/luogu5106/"},{"title":"洛谷5162 - WD与积木","text":"用 $f_i$ 表示 $i$ 个时的高度之和， $g_i$ 表示 $i$ 个时的方案数，显然： $$\\begin{align}g_n &amp;= \\sum\\limits_{i=1}^n {n \\choose i} g_{n-i} \\\\f_n &amp;= g_n + \\sum\\limits_{i=1}^n {n \\choose i} f_{n-i} \\\\ans_n &amp;= f_n \\times g_n^{-1}\\end{align}$$ 其实到这里可以直接分治 NTT ，不过我们考虑多项式求逆的做法。首先把 ${n \\choose i}$ 拆开，然后设 $F_n = f_n / n!$ ， $G_n = g_n / n!$ ， $H_n = 1 / n!$ 则 $$\\begin{align}G &amp;= (2 - H)^{-1} \\\\F &amp;= (G - 1) (2 - H)^{-1} \\\\ans_n &amp;= F_n G_n^{-1}\\end{align}$$ （推导时需要注意常数项系数，$f_0 = 0，g_0 = h_0 = 1$。） 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586// =================================// author: memset0// date: 2019.01.27 22:40:38// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;#define ll long longnamespace ringo {template &lt;class T&gt; inline void read(T &amp;x) { x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;}template &lt;class T&gt; inline void print(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);}template &lt;class T&gt; inline void print(T x, char c) { print(x), putchar(c); }const int N = 4e5 + 10, mod = 998244353;int T, n;int a[N], f[N], g[N], h[N], w[N], rev[N];int inv(int x) { return !x || x == 1 ? 1 : (ll)(mod - mod / x) * inv(mod % x) % mod; }inline int fpow(int a, int b) { int s = 1; for (; b; b &gt;&gt;= 1, a = (ll)a * a % mod) if (b &amp; 1) s = (ll)s * a % mod; return s; }inline void ntt(int *a, int lim) { for (int i = 0; i &lt; lim; i++) if (i &lt; rev[i]) std::swap(a[i], a[rev[i]]); for (int len = 1; len &lt; lim; len &lt;&lt;= 1) for (int i = 0; i &lt; lim; i += (len &lt;&lt; 1)) for (int j = 0; j &lt; len; j++) { int x = a[i + j], y = (ll)w[j + len] * a[i + j + len] % mod; a[i + j] = (x + y) % mod, a[i + j + len] = (x - y + mod) % mod; }}inline int init(int len) { int lim = 1, k = 0; while (lim &lt; len) lim &lt;&lt;= 1, ++k; for (int i = 0; i &lt; lim; i++) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (k - 1)); for (int len = 1, wn; len &lt; lim; len &lt;&lt;= 1) { wn = fpow(3, (mod - 1) / (len &lt;&lt; 1)), w[len] = 1; for (int i = 1; i &lt; len; i++) w[i + len] = (ll)w[i + len - 1] * wn % mod; } return lim;}void polyMul(int *f, int *g, int len) { static int a[N], b[N]; int lim = init(len &lt;&lt; 1), inv_lim = inv(lim); for (int i = 0; i &lt; lim; i++) a[i] = f[i], b[i] = g[i]; ntt(a, lim), ntt(b, lim); for (int i = 0; i &lt; lim; i++) a[i] = (ll)a[i] * b[i] % mod; std::reverse(a + 1, a + lim), ntt(a, lim); for (int i = 0; i &lt; lim; i++) f[i] = (ll)a[i] * inv_lim % mod;}void polyInv(int *f, int *g, int n) { static int a[N], b[N]; g[0] = inv(f[0]); for (int len = 2; (len &gt;&gt; 1) &lt; n; len &lt;&lt;= 1) { int lim = init(len &lt;&lt; 1), inv_lim = inv(lim); for (int i = 0; i &lt; len; i++) a[i] = f[i], b[i] = g[i]; ntt(a, lim), ntt(b, lim); for (int i = 0; i &lt; lim; i++) a[i] = (ll)a[i] * b[i] % mod * b[i] % mod; std::reverse(a + 1, a + lim), ntt(a, lim); for (int i = 0; i &lt; len; i++) g[i] = ((g[i] &lt;&lt; 1) - (ll)a[i] * inv_lim % mod + mod) % mod; }}void main() { read(T); for (int i = 1; i &lt;= T; i++) read(a[i]), n = std::max(n, a[i] + 1); h[0] = h[1] = 1; for (int i = 2; i &lt; n; i++) h[i] = (ll)(mod - mod / i) * h[mod % i] % mod; for (int i = 2; i &lt; n; i++) h[i] = (ll)h[i] * h[i - 1] % mod; for (int i = 1; i &lt; n; i++) if (h[i]) h[i] = mod - h[i]; polyInv(h, g, n); for (int i = 1; i &lt; n; i++) f[i] = g[i]; polyMul(f, g, n); for (int i = 1; i &lt;= T; i++) print((ll)f[a[i]] * inv(g[a[i]]) % mod, '\\n');}} signed main() { return ringo::main(), 0; }","link":"/luogu5162/"},{"title":"洛谷5104 - 红包发红包","text":"在 $[0,w]$ 中等概率取出的值的期望是 $\\frac{1}{2} w$ ，简单观察可以发现，答案就是 $\\frac{1}{2} ^ k$ ，快速幂一下就好了。 需要注意的是，根据欧拉定理，若 $p$ 是质数：$$a^b \\equiv a ^ {b \\mod \\varphi(p)} (\\mod p)$$所以这题如果你直接给 $k$ 模下 $p$ 就会挂啦 233. 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344// =================================// author: memset0// date: 2018.12.16 14:30:19// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;namespace ringo {typedef long long ll;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;}template &lt;class T&gt; inline void print(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);}template &lt;class T&gt; inline void maxd(T &amp;a, T b) { if (b &gt; a) a = b; }template &lt;class T&gt; inline void mind(T &amp;a, T b) { if (b &lt; a) a = b; }template &lt;class T&gt; inline void print(T x, char c) { print(x), putchar(c); }template &lt;class T&gt; inline T abs(const T &amp;a) { if (a &lt; 0) return -a; return a; }const int p = 1e9 + 7;int w;ll n, k;int fpow(int a, int b) { int s = 1; while (b) { if (b &amp; 1) s = (ll)s * a % p; b &gt;&gt;= 1, a = (ll)a * a % p; } return s;}void main() { read(w), read(n), read(k); print((ll)w * fpow(5e8 + 4, k % (p - 1)) % p, '\\n');}} signed main() { return ringo::main(), 0; }","link":"/luogu5104/"},{"title":"Min-Max 容斥学习笔记","text":"感谢 lyc 哥哥上次给我讲了一下…然而我并没有听懂，只能自己再去学了一遍 Min-Max 容斥： $$\\max(S) = \\sum\\limits_{S’ \\subseteq S} \\min(S’) (-1)^{|S’| - 1}$$ 可以用二项式反演证明：构造容斥函数 $f(x)$ 使得 $$\\max(S) = \\sum\\limits_{S’ \\subseteq S} \\min(S’) f(|S’|)$$ 考虑每个 $S’ \\subseteq S$ 中 $\\min(S’) = a_{x+1}$ 对答案的贡献为： $$g(x) = [x = 0] = \\sum\\limits_{i=0}^x {x \\choose i} f(i+1)$$ 二项式反演得： $$\\begin{aligned}f(x + 1) &amp;= \\sum\\limits_{i=0}^x (-1)^{x-i} {x \\choose i} g(i) \\\\\\Rightarrow \\ \\ \\ f(x + 1) &amp;= (-1)^{x} \\\\\\Rightarrow \\ \\ \\ f(x) &amp;= (-1)^{x-1}\\end{aligned}$$ 所以： $$\\begin{aligned}\\max(S) &amp;= \\sum\\limits_{S’ \\subseteq S} \\min(S’) f(|S’|) \\\\ &amp;= \\sum\\limits_{S’ \\subseteq S} \\min(S’) (-1)^{|S’| - 1}\\end{aligned}$$","link":"/min-max/"},{"title":"洛谷5105 - 不强制在线的动态快速排序","text":"考虑最后的集合是否为可重集对答案没有影响，我们可以把相邻或重合的区间合并 对于一个连续区间的异或和，其实就是连续奇数的异或和，对于每一个二进制位进行分析，发现他是有循环节的，故对于每一个二进制位进行分析，以 $O(\\log \\ \\texttt{值域})$ 的复杂度计算出答案。 对于相邻的两个区间，我们可以 $O(1)$ 直接计算 故把这些区间放到 std::set / std::vector / 平衡树 / 线段树上。每次暴力合并区间。由于每个区间最多被删一次，也最多被加一次，总复杂度为 $O(n \\log n)$ 。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115// =================================// author: memset0// date: 2018.12.16 14:46:24// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;namespace ringo {typedef long long ll;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;}template &lt;class T&gt; inline void print(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);}template &lt;class T&gt; inline void maxd(T &amp;a, T b) { if (b &gt; a) a = b; }template &lt;class T&gt; inline void mind(T &amp;a, T b) { if (b &lt; a) a = b; }template &lt;class T&gt; inline void print(T x, char c) { print(x), putchar(c); }template &lt;class T&gt; inline T abs(const T &amp;a) { if (a &lt; 0) return -a; return a; }const int N = 3e5 + 10;int n, l, r, op;ll ans;struct pair { int l, r; ll w; inline bool operator &lt; (const pair &amp;other) const { return l &lt; other.l; }};std::set &lt;pair&gt; set;typedef std::set &lt;pair&gt; ::iterator iterator;std::deque &lt;iterator&gt; rub;ll calc(int x) { ll ans = x &amp; 1; if (x % 4 == 2 || x % 4 == 3) ans ^= 2; for (int i = 2, t; i &lt;= 30; i++) { if (x &lt;= (1 &lt;&lt; (i - 1))) break; t = (x - 1) % (1 &lt;&lt; i) + 1; if (t &gt; (1 &lt;&lt; (i - 1)) &amp;&amp; (t &amp; 1)) ans ^= (1 &lt;&lt; i); } return ans;}void update_left(iterator x) { if (x != set.begin()) { ll u = (ll)x-&gt;l * x-&gt;l; --x; ans ^= u - ((ll)x-&gt;r * x-&gt;r); }}void update_right(iterator x) { if (x != --set.end()) { ll u = (ll)x-&gt;r * x-&gt;r; ++x; ans ^= ((ll)x-&gt;l * x-&gt;l) - u; }}void insert(pair x) { auto t = set.lower_bound(x), u = t; while (true) { if (u == set.begin()) break; --u; if (x.l - 1 &lt;= u-&gt;r) rub.push_front(u); else break; } u = t; while (true) { if (u == set.end()) break; if (x.r + 1 &gt;= u-&gt;l) rub.push_back(u); else break; ++u; } for (auto u : rub) { if (u-&gt;l &lt; x.l) x.l = u-&gt;l; if (u-&gt;r &gt; x.r) x.r = u-&gt;r; update_left(u); ans ^= u-&gt;w; } if (rub.size()) update_right(*--rub.end()); else { auto t = set.lower_bound(x); if (t != set.end()) update_left(t); } for (auto u : rub) set.erase(u); rub.clear(); x.w = calc(x.r) ^ calc(x.l); set.insert(x); update_left(set.find(x)); update_right(set.find(x)); ans ^= x.w;}void main() { for (read(n); n--; ) { if (read(op), op == 1) { read(l), read(r); insert((pair){l, r}); } else { print(ans, '\\n'); } }}} signed main() { return ringo::main(), 0; }","link":"/luogu5105/"},{"title":"关于这个博客最近收到的评论骚扰","text":"最近有人用脚本（或其他）方式在这个博客刷大量垃圾评论骚扰。我有一些内容想留给那位同学： 您刷的评论，完全是无中生有的指责；您在我的 Min-Max 学习笔记留下这样的内容，难道我要重新发明 Min-Max 容斥才能写题解吗？接着您在我的几乎每篇文章里都刷，我推荐一首歌你都刷，是不是有点过分了啊？ 我不是没有能力删除你的垃圾评论，只是要 WC 了我没时间跟你耗而已，你几十分钟刷的评论我只要一分钟就可以删完。Valine 也可以资瓷屏蔽垃圾评论的功能，但可能会屏蔽掉一些可能有意义的评论，在对 OI 圈平均素质的信任下我没有打开。 以你刷的时间和频率，你可能还有文化课的任务；以你的内容推测，您很可能在某谷抄题解被举报过。奉劝您好好学习，好好写题，抄题解抄多了对你没什么帮助的。目测如果你还来，我可能会考虑某些方式定位或屏蔽你；但暂时该博客没有此类脚本记录任何读者的隐私信息。 以上。 memset0.cn2018.1.19 p.s. 想必那位同学已经看到了，那么也就没什么好说的。如果你实在想搞事情， WC 后我们走着瞧！","link":"/ping-lun-sao-rao/"},{"title":"下载 Oneindex 网站的整个文件夹","text":"最近在别人的 Oneindex 下东西，懒得一个一个点于是就写了个脚本准备一次性下。 成品：github.com/memset0/oneindex-folder-spider 原理其实是很简单的，对于当前这个页面遍历每一个连接：如果是文件就下载，如果是文件夹就递归即可。下载出来的文件树会和 Oneindex 上的一样。 如果使用的话需要安装 Python3 &amp; requests &amp; wget 。 代码： 1234567891011121314151617181920212223242526import requests, re, os, urllibdef mkdir(path): # print('mkdir', path) if not os.path.exists(path): os.makedirs(path)def get(url, path): print('get', urllib.parse.unquote(url), urllib.parse.unquote(path)) if url[-1] == '/': mkdir(urllib.parse.unquote(path)) length = len(re.split(r'://[\\S]*?/', url)[-1]) + 1 content = requests.get(url).text children = re.findall(r'&lt;li class=\"mdui-list-item mdui-ripple\"&gt;\\n &lt;a href=\"[\\s\\S]*?\"&gt;', content) folders = [children[i][52 + length:-2] for i in range(1, len(children))] children = re.findall(r'&lt;li class=\"mdui-list-item file mdui-ripple\"&gt;\\n &lt;a href=\"[\\s\\S]*?\" target=\"_blank\"&gt;', content) files = [children[i][57 + length:-18] for i in range(0, len(children))] for child in files + folders: get(url + child, path + child) else: os.system('wget {url} -O {path}'.format(url=url, path=urllib.parse.unquote(path)))if __name__ == '__main__': url = 'https://drive.bakaawt.com/Videos/%E6%B4%9B%E8%B0%B7%E6%98%A5%E5%AD%A3%E5%9B%9E%E6%94%BE/TG/%E5%A4%8D%E8%B5%9B/' path = os.getcwd() + '/down/' get(url, path)","link":"/oneindex-folder-download/"},{"title":"PKUWC 2019 游记","text":"谨以此文记录我的 OI 生涯的第一次向 PKU 冲刺的机会。 持续更新。 Day -1逝者如斯。仿佛昨日仍是考挂的 NOIP Day 2 ，考场上自己紧张的脑海如同面前的白纸一般，我用尽全力去寻找那一丝的线索而后又一无所获。正解没想出 + 暴力写挂，让我完美地与 THUWC 擦肩而过，也更不可能去参加 WC 了。 回顾这两个月的时光。11 月考完后各种浪 + 学习了一系列多项式算法、12 月各种模拟赛 + 巩固知识 + 搞博客 、 1 月学习一系列字符串算法 + 复习巩固 LCT 。其中也有和 CJ 的联考，认识了 xzz 、 yyb 等大佬；冬日绘板的维护中也认识了 OwenOwl 。 每次大考前的自己都难免会紧张，现在也不例外，所以来更博客。最近复习巩固的算法不知道考场上考到的话自己能不能写出来，感觉数学题还可以再复习一下，就留作明天的最后冲刺吧。 昨晚看到一位同学的博客。才 10 月分，我刚熟练掌握树链剖分哪会儿，他就已经会动态 DP 了（woc 我当时怎么没学这玩意儿）。然而，他的博客也永远停留在了 10 月。没有复赛的入场券，意味着他只能回初中准备中考。 也许，竞赛就是这么残忍的东西吧。实力的竞争让曾经的挚友反目成仇，几分的差距让多少 OIer 的清北梦破碎。有人在抱怨，有人在哭诉，然而这又有什么用呢，不如用自己的努力去争取。 PKUWC ，第一个给在 NOIP 中失利的我证明自己的机会。 memset0， 要对自己说： 加油！ Day 0今天上午是我自幼儿园（那个时候几乎没什么记忆了…）后第一次坐飞机… 想这种在天上飞的感觉这的好啊。中午 &amp; 下午在坐了好久的车（广州到中山还是挺远的），前半程调板子，后半程和龙天龙天颓象棋（他爆踩窝 Orz）。 下午试机，当坐在考场里， NOIp 时那种紧张和焦虑感又重新涌上心头。也许这就是考试的紧张吧，希望明天的我能尽力克服。晚上在调试机题（下午没在写，先回寝室休息了）。 明天是正式的 Day 1 了，现在再看会儿板子，等到了考场还是专心考试吧，争取不要紧张，PKUWC2019 rp++！ Day 1今天彻底凉透了。 上午开幕式领导讲话，北大老师：“清华北门朝东，东门朝南，你看一个学校连门都开不好，想必…”。 然后就是机试： 开局先写 T1 暴力，写着写着就会正解了，然后大概一刻钟写了个暴力，再一刻钟写了个正解 AC 。 一看时间还多，又看了眼 T2 和 T3 。T2 看错题，还以为此题的虚树和其他大融合里的那种虚树是一样的，即总点数是 $O(n)$ 于是一直往那边想（滚粗 flag $\\times$ 1），显然 GG 。忽然感觉链的情况很好写，赶快码码码。然后发现这么一个东西不会处理： $$ans_i = \\sum\\limits_{j=1}^n b_j {a_j \\choose i}$$ 码了个暴力交上去爆零（然而有人卡卡常就过了，滚粗 flag $\\times$ 2），写了个 NTT 不知是写挂了还是式子推错了，暂时放着没管（滚粗 flag $\\times$ 3） 于是开始看 T3 ，一看时间还多，写个 13 分还是没问题的，一写就是 2h （滚粗 flag $\\times$ 4），一看时间还有 2h 了，T3 暴力还是 WA ，想想这个时候苟 T2 也没什么用了（滚粗 flag $\\times$ 5）赶快重构了一遍，然而还是 WA… T2 的 NTT 也没时间调，于是最后 1min 只能瞪着时间默默观察自己爆零 233… 晚上和同学聊了挺久的吧，毕竟深知自己明天不可能翻盘做好自己就行。 Day 2今天考 Day2 ，因为肯定不可能翻盘所以也就不在意了。 上午考数学，表示有 Python 非常滴吼…几乎全程写的 Python 。就是 IDLE 有点卡，写个 Python 死机死了两次。后来换 Sublime 写就十分舒适… 下午机试，T1 很快写了个暴力然而不会第二档部分分。然后就自闭了。出于 Day1 的经历不敢不开 T2 ，于是直接想了一下，可以把以简单环为点转换为以边为点。接着开了一下 T3 ，准备先写个随机撒点。调出来了以后想到了一个 47 分做法——由于一个环覆盖另一个环一定是一个连续的区间，打算先写 T2 再开。 T2 一开始的思路是假的，我枚举两条有公共点的单向边 $e \\to u$ 和 $u \\to s$ 会对答案产生贡献当且仅当 $\\exists$ 从 $s$ 到 $e$ 的路径。于是写了个暴力拍出了这样一组 Hack 数据： 123453 41 22 11 33 1 这个数据告诉我们必须 $\\exists$ 一条从 $s$ 到 $e$ 的路径还不能经过 $u$ 。于是我的思维大概就定格在如何枚举两条边并且 Check $u$ 是不是 $s$ 到 $e$ 的割点。大概想到了 Tarjan 的方向，但是由于 T3 的 36 分还没写，所以赶快去写 T3 。 不幸的是，我 T3 照样没有调出来。由于坐标的值域可以到 $10^9$ ，所以如果直接全部用 double 存平方一下就炸精度了 233… 我虽然想到了这个但是已经没有时间改 long long 了。由于 Day 1 爆炸 Day 2 本来就没抱多大希望，所以也不是很难过吧(话说这个 Day 1 和 2 换一下我可能会考的比较好吧…) 晚上和 lty 下象棋，然后颓了会儿知乎就睡了 Day 3今天是面试日，由于肯定不会有什么一本约所以就根本没准备了。 名字如期出现在了列表里，要面试三次，大概总结一下吧： 第一个老师是先让我作 1 min 的自我介绍，然而因为我没准备就说了个名字和学校就编不下去了。然后她问我未来的方向，我说机器学习。接着问会的语言：说了 Python 、PHP、还有一些前端语言，除 OI 外主要写 Python （这是真事儿）。然后就让我走了？？？面试好快啊… 第二个老师问了我一些有关文化课的问题，比如学习成绩怎么样之类的。还问了我初三停课的话文化课打算怎么办… 我就如实回答了，也没吹牛逼。 第三个老师是我们监考老师，考场电脑两次死机所以这位老师也记住我了 Orz。开头讨论了大概半分钟为啥我的电脑死机了(他认为我 Chrome 窗口开太多了，我认为我在 IDLE 里跑了个 Python 那电脑就咕咕咕了 233)，不过这不是重点。然后就问了一些非常正常的问题吧。我也如实说了我这次考试爆炸什么的。他让我稳住心态 QAQ ，然后就正常的结束了… 考完出来竟然没有一种如释重负的感觉。可能是因为 Day 1 的时候就知道这一切已经结束了吧，毕竟人贵有自知之明，这点分数我也不奢求有什么结果了。 下午一个人把纪中校园走了个遍，感觉是真的大啊。会宾馆后可能会补上拍的照片和游记吧。 差不多没了。","link":"/pkuwc2019/"},{"title":"Splay 实现区间翻转（文艺平衡树）","text":"思路之前我们讲到了用 Splay 写普通平衡树，这次我们将用 Splay 来完成区间操作。 之前的 Splay 是按照权值排序，而这里的 Splay 则是要按照编号排序。 不难想到，整棵树的编号第 k 大点即数列中的第 k 个，整棵树的中序遍历即被维护的数列。 假设我们要翻转区间[l, r]，那么我们先把l - 1旋转到根节点，再把r + 1旋转到根节点的右孩子。那么r + 1的左子树即区间[l, r]。翻转该区间只需要把该区间内的每个节点的左右子树交换即可。 参考线段树的 lazytag，我们也使用一个类似于懒标记的方法，保证复杂度为O(log n)。 基本操作和普通平衡树一样。 12345678910void update(int x) { e[x].sum = e[e[x].ch[0]].sum + e[e[x].ch[1]].sum + e[x].cnt;}int identify(int x) { return e[e[x].father].ch[1] == x;}void connect(int u, int f, int son) { e[u].father = f; e[f].ch[son] = u;} 懒标记下放把当前节点的懒标记传给两个孩子，同时交换两个孩子的指针。 12345678void pushdown(int x) { if (e[x].tag) { swap(e[x].ch[0], e[x].ch[1]); e[e[x].ch[0]].tag ^= 1; e[e[x].ch[1]].tag ^= 1; e[x].tag = 0; }} 上旋 &amp; Splay和普通平衡树的操作相同，只不过需要先pushdown()改变了的节点。 123456789101112131415161718192021void rotate(int x) { int f = e[x].father, ff = e[f].father; pushdown(f), pushdown(x); int fson = identify(x), ffson = identify(f); int y = e[x].ch[fson ^ 1]; connect(y, f, fson); connect(f, x, fson ^ 1); connect(x, ff, ffson); update(f); update(x);}void splay(int at, int to) { to = e[to].father; while (e[at].father != to) { int up = e[at].father; pushdown(up), pushdown(at); if (e[up].father == to) rotate(at); else if (identify(at) == identify(up)) rotate(up), rotate(at); else rotate(at), rotate(at); }} 查找与普通平衡树的查找第 k 大相同。 由于只会在reverse操作中被调用所以没有 splay 到根。 12345678910int find(int x) { int u = root; while (u) { pushdown(u); int mincost = e[e[u].ch[0]].sum + e[u].cnt; if (e[e[u].ch[0]].sum &lt; x &amp;&amp; x &lt;= mincost) return u; if (x &lt; mincost) u = e[u].ch[0]; else x -= mincost, u = e[u].ch[1]; }} 建树setroot()操作用于在外部定义根节点。 build()操作类似于线段树，直接建树比写insert()操作插入节点要快。 123456789101112131415void setroot(int x) { root = x;}void build(int l, int r, int f) { if (l &gt; r) return; int m = (l + r) &gt;&gt; 1; e[m].val = m, e[m].father = f; e[m].cnt = e[m].sum = 1; e[m].ch[0] = e[m].ch[1] = 0; if (m &lt; f) e[f].ch[0] = m; else e[f].ch[1] = m; build(l, m - 1, m); build(m + 1, r, m); update(m);} 翻转参照之前的图。需要注意的是这样的写法需要下文初始化的配合 123456void reverse(int l, int r) { int x = find(l - 1), y = find(r + 1); splay(x, root); splay(y, e[x].ch[1]); e[e[y].ch[0]].tag ^= 1;} 初始化我们先使用build()操作建树。其中2 ~ n + 1节点表示数列的第1 ~ n个。 插入1和n + 2节点是为了保证被查找的树必定在区间内简化代码量。 12s.setroot((n + 3) &gt;&gt; 1);s.build(1, n + 2, 0); 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;int read() { int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;}const int maxn = 100010;int n, m, l, r;struct Splay { #define root (e[0].ch[1]) struct node { int val, sum, cnt, tag; int father, ch[2]; } e[maxn]; void setroot(int x) { root = x; } void update(int x) { e[x].sum = e[e[x].ch[0]].sum + e[e[x].ch[1]].sum + e[x].cnt; } int identify(int x) { return e[e[x].father].ch[1] == x; } void connect(int u, int f, int son) { e[u].father = f; e[f].ch[son] = u; } void pushdown(int x) { if (e[x].tag) { swap(e[x].ch[0], e[x].ch[1]); e[e[x].ch[0]].tag ^= 1; e[e[x].ch[1]].tag ^= 1; e[x].tag = 0; } } void rotate(int x) { int f = e[x].father, ff = e[f].father; pushdown(f), pushdown(x); int fson = identify(x), ffson = identify(f); int y = e[x].ch[fson ^ 1]; connect(y, f, fson); connect(f, x, fson ^ 1); connect(x, ff, ffson); update(f); update(x); } void splay(int at, int to) { to = e[to].father; while (e[at].father != to) { int up = e[at].father; pushdown(up), pushdown(at); if (e[up].father == to) rotate(at); else if (identify(at) == identify(up)) rotate(up), rotate(at); else rotate(at), rotate(at); } } int find(int x) { int u = root; while (u) { pushdown(u); int mincost = e[e[u].ch[0]].sum + e[u].cnt; if (e[e[u].ch[0]].sum &lt; x &amp;&amp; x &lt;= mincost) return u; if (x &lt; mincost) u = e[u].ch[0]; else x -= mincost, u = e[u].ch[1]; } } void build(int l, int r, int f) { if (l &gt; r) return; int m = (l + r) &gt;&gt; 1; e[m].val = m, e[m].father = f; e[m].cnt = e[m].sum = 1; e[m].ch[0] = e[m].ch[1] = 0; if (m &lt; f) e[f].ch[0] = m; else e[f].ch[1] = m; if (l == r) return; build(l, m - 1, m); build(m + 1, r, m); update(m); } void reverse(int l, int r) { int x = find(l - 1), y = find(r + 1); splay(x, root); splay(y, e[x].ch[1]); e[e[y].ch[0]].tag ^= 1; } #undef root} s;int main() { n = read(), m = read(); s.setroot((n + 3) &gt;&gt; 1); s.build(1, n + 2, 0); while (m--) { l = read(), r = read(); s.reverse(l + 1, r + 1); } for (int i = 1; i &lt;= n; i++) printf(\"%d \", s.find(i + 1) - 1); putchar('\\n'); return 0;} 备注 &amp; 参考资料参考资料： 题解 P3391 【模板】文艺平衡树（Splay） - zcysky 题解 P3391 【模板】文艺平衡树（Splay） - yybyyb Splay处理区间操作——翻转操作(Reverse) - _pks ‘w 代码提交： 洛谷 3391 【模板】文艺平衡树（Splay） LOJ #105. 文艺平衡树","link":"/splay-pro/"},{"title":"Splay 非指针模板（普通平衡树）","text":"踏上平衡树征程的第一步… 前言Splay 是一种简单且功能丰富的平衡树结构，其算法核心 Splay 操作能维持其均摊复杂度维持在 $O(logn)$ 。 定义我们将整棵 Splay 定义在结构体中。 并定义结构体node来表示 Splay 的每一个节点。 宏定义e[0].ch[1]为根节点， $1e9 + 10$ 为INF，并在结构体尾取消定义。 1234567891011121314struct Splay { #define root (e[0].ch[1]) #define inf (1e9+10) struct node { int val; // 当前节点存储的值 int cnt; // 当前节点存储的值出现的次数 int siz; // 当前节点包括其左右子树中包含的数的个数（不是节点数！） int father; // 当前节点的父亲节点 int ch[2]; // 当前节点的孩子节点，ch[0]表示左孩子，ch[1]表示右孩子 } // your code goes here... #undef root #undef inf} 基础操作update()操作用于更新当前节点的siz值； connect()操作用于连接节点； identify()操作用于确认当前节点是其父亲的左孩子还是右孩子。 12345678910void update(int x) { e[x].siz = e[e[x].ch[0]].siz + e[e[x].ch[1]].siz + e[x].cnt;}void connect(int x, int f, int son) { e[x].father = f; e[f].ch[son] = x;}int identify(int x) { return x == e[e[x].father].ch[0] ? 0 : 1;} 旋转平衡树的必备知识。 rotate(x)表示把x节点上旋到其父亲的位置。 12345678910void rotate(int x) { int f = e[x].father, fson = identify(x); int ff = e[f].father, ffson = identify(f); int y = e[x].ch[fson ^ 1]; connect(y, f, fson); connect(f, x, fson ^ 1); connect(x, ff, ffson); update(f); update(x);} SplaySplay 是 Splay 的核心操作。用于把一个节点旋转到指定位置。 需要注意的是，Splay在每次完成查询操作后都要将被查询的节点 Splay 到根。 12345678910void splay(int at, int to) { if (!at) return; to = e[to].father; while (e[at].father != to) { int up = e[at].father; if (e[up].father == to) rotate(at); else if (identify(at) == identify(up)) rotate(up), rotate(at); else rotate(at), rotate(at); }} 新建 / 擦除节点为 插入 / 删除 操作提供铺垫。 12345678910111213void crepoint(int val, int father) { int x = ++pos; e[x].val = val; e[x].father = father; e[x].cnt = e[x].siz = 1; e[x].ch[0] = e[x].ch[1] = 0;}void delpoint(int x) { e[x].val = 0; e[x].father = 0; e[x].cnt = e[x].siz = 0; e[x].ch[0] = e[x].ch[1] = 0;} 插入如果是空节点需要特判； 如果可以在树中找到一个值相同的节点那么直接使其cnt++； 其余情况根据平衡树的性质找到一个可行位置并插入。 12345678910111213141516171819202122232425void insert(int val) { int u = root; points++; if (points == 1) { // 特判无点状态（看个人写法？） crepoint(val, 0); root = pos; return; } while (u) { e[u].siz++; if (e[u].val == val) { e[u].cnt++; splay(u, root); return; } int son = val &lt; e[u].val ? 0 : 1; if (!e[u].ch[son]) { crepoint(val, u); e[u].ch[son] = pos; splay(pos, root); return; } u = e[u].ch[son]; }} 删除首先将要删除的节点旋转到根节点的位置。 如果要被删除的节点（注意现在它在根的位置）没有左孩子，那么直接摧毁这个节点，并将它的右孩子变成根。 如果自己有左孩子，那么就先把左子树中值最大的元素旋转到根的左孩子位置，然后将根节点的右孩子变成根节点的左孩子的右孩子，然后摧毁节点，并将左孩子变成根。 这样子做是为了使删除节点后的树维持平衡。 123456789101112131415161718192021void erase(int val) { int u = find(val); points--; if (e[u].cnt &gt; 1) { e[u].cnt--; e[u].siz--; return; } if (!e[u].ch[0]) { connect(e[u].ch[1], 0, 1); root = e[u].ch[1]; } else { int lft = e[u].ch[0], rit = e[u].ch[1]; while (e[lft].ch[1]) lft = e[lft].ch[1]; splay(lft, e[u].ch[0]); connect(rit, lft, 1); connect(lft, 0, 1); update(lft); } delpoint(u);} 排名 rank()查询 x 数的排名（定义为比当前数小的数的个数 +1 ) atrank()查询排名为 x 的数 12345678910111213141516171819202122int rank(int val) { int u = root, ans = 0; while (u) { if (val == e[u].val) { ans += e[e[u].ch[0]].siz + 1; splay(u, root); return ans; } if (val &lt; e[u].val) u = e[u].ch[0]; else ans += e[e[u].ch[0]].siz + e[u].cnt, u = e[u].ch[1]; }}int atrank(int x) { int u = root; while (u) { if (x &lt;= e[e[u].ch[0]].siz) u = e[u].ch[0]; else if (x &lt;= e[e[u].ch[0]].siz + e[u].cnt) { splay(u, root); return e[u].val; } else x -= e[e[u].ch[0]].siz + e[u].cnt, u = e[u].ch[1]; }} 前驱 &amp; 后继根据平衡树的性质即可。 需要注意的是相等时仍需要继续查找，那么等号的用法就特别讲究。 此份代码中将其特别突出。 123456789101112131415161718int lower(int val) { int u = root, result = -inf, cho = 0; while (u) { if (e[u].val &lt; val &amp;&amp; e[u].val &gt; result) result = e[u].val, cho = u; u = e[u].ch[val &lt;= e[u].val ? 0 : 1]; } splay(cho, root); return result;}int upper(int val) { int u = root, result = inf, cho = 0; while (u) { if (e[u].val &gt; val &amp;&amp; e[u].val &lt; result) result = e[u].val, cho = u; u = e[u].ch[val &gt;= e[u].val ? 1 : 0]; } splay(cho, root); return result;} 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;int read() { int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;}const int maxn = 100010;int n, opt;struct Splay { #define root (e[0].ch[1]) #define inf (1e9 + 10) struct node { int cnt, siz, val; int father, ch[2]; } e[maxn]; int pos, points; void update(int x) { e[x].siz = e[e[x].ch[0]].siz + e[e[x].ch[1]].siz + e[x].cnt; } void connect(int x, int f, int son) { e[x].father = f; e[f].ch[son] = x; } int identify(int x) { return x == e[e[x].father].ch[0] ? 0 : 1; } void rotate(int x) { int f = e[x].father, fson = identify(x); int ff = e[f].father, ffson = identify(f); int y = e[x].ch[fson ^ 1]; connect(y, f, fson); connect(f, x, fson ^ 1); connect(x, ff, ffson); update(f); update(x); } void splay(int at, int to) { if (!at) return; to = e[to].father; while (e[at].father != to) { int up = e[at].father; if (e[up].father == to) rotate(at); else if (identify(at) == identify(up)) rotate(up), rotate(at); else rotate(at), rotate(at); } } void crepoint(int val, int father) { int x = ++pos; e[x].val = val; e[x].father = father; e[x].cnt = e[x].siz = 1; e[x].ch[0] = e[x].ch[1] = 0; } void delpoint(int x) { e[x].val = 0; e[x].father = 0; e[x].cnt = e[x].siz = 0; e[x].ch[0] = e[x].ch[1] = 0; } int find(int val) { int u = root; while (u) { if (val == e[u].val) { splay(u, root); return u; } u = e[u].ch[val &lt; e[u].val ? 0 : 1]; } } void insert(int val) { int u = root; points++; if (points == 1) { crepoint(val, 0); root = pos; return; } while (u) { e[u].siz++; if (e[u].val == val) { e[u].cnt++; splay(u, root); return; } int son = val &lt; e[u].val ? 0 : 1; if (!e[u].ch[son]) { crepoint(val, u); e[u].ch[son] = pos; splay(pos, root); return; } u = e[u].ch[son]; } } void erase(int val) { int u = find(val); points--; if (e[u].cnt &gt; 1) { e[u].cnt--; e[u].siz--; return; } if (!e[u].ch[0]) { connect(e[u].ch[1], 0, 1); root = e[u].ch[1]; } else { int lft = e[u].ch[0], rit = e[u].ch[1]; while (e[lft].ch[1]) lft = e[lft].ch[1]; splay(lft, e[u].ch[0]); connect(rit, lft, 1); connect(lft, 0, 1); update(lft); } delpoint(u); } int rank(int val) { int u = root, ans = 0; while (u) { if (val == e[u].val) { ans += e[e[u].ch[0]].siz + 1; splay(u, root); return ans; } if (val &lt; e[u].val) u = e[u].ch[0]; else ans += e[e[u].ch[0]].siz + e[u].cnt, u = e[u].ch[1]; } } int atrank(int x) { int u = root; while (u) { if (x &lt;= e[e[u].ch[0]].siz) u = e[u].ch[0]; else if (x &lt;= e[e[u].ch[0]].siz + e[u].cnt) { splay(u, root); return e[u].val; } else x -= e[e[u].ch[0]].siz + e[u].cnt, u = e[u].ch[1]; } } int lower(int val) { int u = root, result = -inf, cho = 0; while (u) { if (e[u].val &lt; val &amp;&amp; e[u].val &gt; result) result = e[u].val, cho = u; u = e[u].ch[val &lt;= e[u].val ? 0 : 1]; } splay(cho, root); return result; } int upper(int val) { int u = root, result = inf, cho = 0; while (u) { if (e[u].val &gt; val &amp;&amp; e[u].val &lt; result) result = e[u].val, cho = u; u = e[u].ch[val &gt;= e[u].val ? 1 : 0]; } splay(cho, root); return result; } #undef root #undef inf} s;int main() { n = read(); while (n--) { opt = read(); switch(opt) { case 1: s.insert(read()); break; case 2: s.erase(read()); break; case 3: printf(\"%d\\n\", s.rank(read())); break; case 4: printf(\"%d\\n\", s.atrank(read())); break; case 5: printf(\"%d\\n\", s.lower(read())); break; case 6: printf(\"%d\\n\", s.upper(read())); break; } } return 0;} 备注 &amp; 参考资料本文只是模板向的 Splay 教程，请在理解 Splay 后查看。 题目链接： 3369 【模板】普通平衡树 - 洛谷 参考资料： https://www.luogu.org/blog/user19027/solution-p3369, 题解 P3369 【【模板】普通平衡树（Treap/SBT）】","link":"/splay/"},{"title":"SPOJ34096 - DIVCNTK - Counting Divisors (general)","text":"Min_25 筛板子题。 注意一些需要开 long long 的地方。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// =================================// author: memset0// date: 2019.01.19 08:17:07// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;#define ll unsigned long longnamespace ringo {template &lt;class T&gt; inline void read(T &amp;x) { x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;}template &lt;class T&gt; inline void print(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);}template &lt;class T&gt; inline void print(T x, char c) { print(x), putchar(c); }const int N = 2e5 + 10;ll n, k, sqr, a[N], g[N];int T, cnt, sqn, pri, prime[N];inline int id(ll x) { return x &lt;= sqn ? x : cnt - n / x + 1; }ll calcS(ll a, int b) { if (a &lt;= 1 || a &lt; prime[b]) return 0; ll ans = g[id(a)] - (b - 1) * (k + 1); for (int i = b; i &lt;= pri &amp;&amp; (ll)prime[i] * prime[i] &lt;= a; i++) { int p = prime[i]; ll x = p, f = k + 1, nxt; for (int j = 1; x * p &lt;= a; j++, x *= p, f = nxt) { nxt = (j + 1) * k + 1; ans += f * calcS(a / x, i + 1) + nxt; } } return ans;}void solve(ll n, ll k) { sqn = sqrt(n); for (ll i = 1; i &lt;= n; i = a[cnt] + 1) a[++cnt] = n / (n / i); for (int i = 1; i &lt;= cnt; i++) g[i] = a[i] - 1; for (int i = 2; i &lt;= sqn; i++) if (g[i] != g[i - 1]) { prime[++pri] = i, sqr = (ll)i * i; for (int j = cnt; a[j] &gt;= sqr; j--) g[j] -= g[id(a[j] / i)] - (pri - 1); } for (int i = 1; i &lt;= cnt; i++) g[i] *= k + 1; print(calcS(n, 1) + 1, '\\n');}void main() { for (read(T); T--; ) { pri = cnt = 0; read(n), read(k), solve(n, k); }}} signed main() { return ringo::main(), 0; }","link":"/spoj34096/"},{"title":"SPOJ2666 - QTREE4 - Query on a tree IV","text":"我在学习点分治时，一直卡在这道题，今天我一鼓作气想尽办法终于把她 AC 了。 将要讲述的方法是动态点分治，有另一种链分治的方法个人感觉较为麻烦且不自然就不在此赘述。 首先静态点分治一遍建立点分树，并算出初始答案，存储每个节点作为重心时到上一个节点的边。当动态修改时从底层向上逐层修改直到抵达根节点。 对于每个节点，我们存储每个子树中距离最远的点（用 son 维护）和距离当前节点距离最远的点（用 hep 维护），最后再维护一个答案堆 ans 供查询。这个堆要资瓷添加和删除操作，可以用经典的建两个堆的方法，一个插入，一个删除即可。 其他当前子树中没有白色时应该返回 $-inf$ ，否则与当前子树的根节点是白色节点时等价的 qwq。 如上，下面上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longint read() { int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;}char readc() { char c = getchar(); while (c != 'A' &amp;&amp; c != 'C') c = getchar(); return c;}const int maxn = 100010, maxm = 200010;const int inf = 1e9;int n, m, u, v, k, w, cnt, a[maxn];int core, root, from, full;int max[maxn], siz[maxn], vis[maxn], pre[maxn], old[maxm];std::vector &lt; int &gt; vec[maxn], dis[maxn];struct Heap { std::priority_queue &lt; int &gt; ins, del; void update() { while (ins.size() &amp;&amp; del.size()) if (ins.top() == del.top()) { ins.pop(), del.pop(); } else break; } void push(int x) { ins.push(x); } void pop(int x) { del.push(x); update(); } int top() { update(); return ins.size() ? ins.top() : -inf; } int size() { return ins.size() - del.size(); } int query() { if (size() &lt; 2) return 0; int tmp1 = top(); pop(tmp1); int tmp2 = top(); push(tmp1); return std::max(tmp1 + tmp2, 0); }} ans, hep[maxn], son[maxm];int tot = 2, hed[maxn], nxt[maxm], to[maxm], val[maxm];void add_edge(int u, int v, int w) { nxt[tot] = hed[u], to[tot] = v, val[tot] = w; hed[u] = tot++;}void dfs(int u, int father, int udis) { max[u] = 0, siz[u] = 1; if (~from) { vec[u].push_back(from); dis[u].push_back(udis); son[from].push(udis); } for (int i = hed[u], v = to[i]; i; i = nxt[i], v = to[i]) if (v != father &amp;&amp; !vis[v]) { dfs(v, u, udis + val[i]); siz[u] += siz[v]; max[u] = std::max(max[u], siz[v]); } max[u] = std::max(max[u], full - siz[u]); if (max[core] &gt; max[u]) core = u;}void solve(int u, int father) { vis[u] = true; for (int i = hed[u], v = to[i]; i; i = nxt[i], v = to[i]) if (v != father &amp;&amp; !vis[v]) { core = 0, full = siz[v], from = i, max[core] = inf; dfs(v, u, 0); pre[core] = i; solve(core, u); hep[u].push(son[i].top() + val[i]); old[i] = son[i].top(); } hep[u].push(0); ans.push(hep[u].query());}void insert(int u) { ans.pop(hep[u].query()); hep[u].push(0); ans.push(hep[u].query()); for (int i = 0; i &lt; (int)vec[u].size(); i++) son[vec[u][i]].push(dis[u][i]); for (int i = pre[u]; ~i; i = pre[u]) { u = to[i ^ 1]; if (old[i] ^ son[i].top()) { ans.pop(hep[u].query()); hep[u].pop(old[i] + val[i]); hep[u].push(son[i].top() + val[i]); ans.push(hep[u].query()); old[i] = son[i].top(); } }}void erase(int u) { ans.pop(hep[u].query()); hep[u].pop(0); ans.push(hep[u].query()); for (int i = 0; i &lt; (int)vec[u].size(); i++) son[vec[u][i]].pop(dis[u][i]); for (int i = pre[u]; ~i; i = pre[u]) { u = to[i ^ 1]; if (old[i] ^ son[i].top()) { ans.pop(hep[u].query()); hep[u].pop(old[i] + val[i]); hep[u].push(son[i].top() + val[i]); ans.push(hep[u].query()); old[i] = son[i].top(); } } }int main() { n = read(); for (int i = 1; i &lt; n; i++) { u = read(), v = read(), w = read(); add_edge(u, v, w); add_edge(v, u, w); } max[0] = inf, full = n, from = -1; dfs(1, 0, 0); pre[core] = -1; solve(core, 0); m = read(); cnt = n; for (int i = 1; i &lt;= m; i++) { if (readc() == 'A') { if (cnt) printf(\"%d\\n\", (cnt - 1) &amp;&amp; ans.size() ? ans.top() : 0); else printf(\"They have disappeared.\\n\"); } else { k = read(); if (a[k]) { cnt++, a[k] = 0; insert(k); } else { cnt--, a[k] = 1; erase(k); } } } return 0;}","link":"/spoj2666/"},{"title":"UVA1220 - Party at Hali-Bula","text":"用 $f[i][0]$ 表示 $i$ 不选所能取到的最大值， $f[i][1]$ 表示选 $i$ 能取到的最大值。 假设当前节点为 $u$ ，孩子节点为 $v$ ，则： $f[u][0] = \\sum\\limits_{v \\in son[u]} \\max(f[v][0], f[v][1])$ $f[u][1] = \\sum\\limits_{v \\in son[u]} f[v][0]$ 关于判断是否有多种情况：我们无需存种数，只要存是否即可，用数组 $d$ 表示，则： 如果当前节点 $u$ 更新状态选中的来自 $v$ 的某个状态存在多种，那么 $u$ 的这个状态也存在多种。 如果 $u$ 节点的某个孩子 $v$ 满足 $f[v][0] == f[v][1]$ ，那么 $f[u][0]$ 存在多种。 代码注意读入方式！！！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int maxn = 210;int n, id, f[maxn][2], d[maxn][2];int tot, hed[maxn], nxt[maxn &lt;&lt; 1], to[maxn &lt;&lt; 1];string a, b;bool more_ans;map &lt; string, int &gt; p;int init() { id = 0; tot = 2; more_ans = false; memset(hed, 0, sizeof(hed)); memset(f, 0, sizeof(f)); memset(d, 0, sizeof(d)); p.clear(); cin &gt;&gt; n; return n;}void add_edge(int u, int v) { nxt[tot] = hed[u], to[tot] = v, hed[u] = tot++; nxt[tot] = hed[v], to[tot] = u, hed[v] = tot++;}void dfs(int u, int father) { f[u][0] = 0, f[u][1] = 1; for (int i = hed[u], v = to[i]; i; i = nxt[i], v = to[i]) if (v != father) { dfs(v, u); f[u][0] += max(f[v][0], f[v][1]); if ((f[v][0] &gt; f[v][1] &amp;&amp; d[v][0]) || (f[v][0] &lt; f[v][1] &amp;&amp; d[v][1]) || (f[v][0] == f[v][1])) d[u][0] = 1; f[u][1] += f[v][0]; if (d[v][0]) d[u][1] = 1; }}int main() { ios::sync_with_stdio(false); while (init() != 0) { cin &gt;&gt; a, p[a] = id = 1; for (int i = 2; i &lt;= n; i++) { cin &gt;&gt; a &gt;&gt; b; if (!p[a]) p[a] = ++id; if (!p[b]) p[b] = ++id; add_edge(p[a], p[b]); } dfs(1, 0); printf(\"%d %s\\n\", max(f[1][0], f[1][1]), (f[1][0] == f[1][1]) || (f[1][0] &gt; f[1][1] &amp;&amp; d[1][0]) || (f[1][0] &lt; f[1][1] &amp;&amp; d[1][1]) ? \"No\" : \"Yes\"); } return 0;}","link":"/uva1220/"},{"title":"退役后的做题计划（一）","text":"本计划根据 Menci 博客 题解时间顺序排列。CodeVS 和 COGS 的部分题出于某些原因不打算做（主要是没有账号）。部分未完成且正准备做的题目可能会给出链接（优先级：洛谷 &gt; BZOJ &gt; LOJ &gt; UOJ）。 完成情况 题目名称 √ 「NOI2002」银河英雄传说 - 并查集 - 「CodeVS 3269」混合背包 - 背包 DP √ 「HNOI2004」宠物收养所 - set - 「CodeVS 3168 / 31」抄书问题 - 划分 DP / 二分答案 √ 「CTSC1997」选课 - 树形 DP - 「NOIP2000」乘积最大 - 划分 DP - 「CodeVS 2598」编辑距离问题 - 线性 DP - 「Tyvj 3317」火车票 - 划分 DP √ 「NOIP2006」能量项链 - 区间 DP √ 「NOIP2003」数字游戏 - 划分 DP - 「CodeVS 1345」饥饿的奶牛 - 线性 DP - 「CodeVS 3269」混合背包 - 背包 DP + 单调队列 √ 「BZOJ 2442」修剪草坪 - 线性 DP + 单调队列 √ 「NOIP2006」金明的预算方案 - 背包 DP + 树形 DP √ 「BZOJ 1251」序列终结者 - Splay √ 「NOIP2012」同余方程 - 扩展欧几里得 √ 「NOI2015」程序自动分析 - 离散化 + 并查集 √ 「NOI2015」软件包管理器 - 树链剖分 √ 「BZOJ 1477」青蛙的约会 - 扩展欧几里得 √ 「NOI2004」郁闷的出纳员 - Splay √ 「BZOJ 1756」小白逛公园 - 线段树 - 「CodeVS 1563」奶牛的交通 - 网络流 √ 「BZOJ 2683」简单题 - CDQ √ 「COGS 14」搭配飞行员 - 二分图匹配 √ 「COGS 728」最小路径覆盖问题 - 二分图匹配 √ 「COGS 396」魔术球问题 - 贪心 √ 「COGS 729」圆桌聚餐 - 网络流 - 「COGS 731」最长递增子序列 - 线性 DP + 网络流 √ 「COGS 727」太空飞行计划 - 最大权闭合图 √ 「COGS 439」软件补丁 - 记忆化搜索 + 位运算 √ 「COGS 734」方格取数 - 二分图最大独立集 √ 「COGS 738」数字梯形 - 费用流 √ 「COGS 746」骑士共存 - 二分图最大独立集 √ 「NOIP2010」关押罪犯 - 二分图染色 √ 「JSOI2008」最大数 - Splay √ 「COGS 739」运输问题 - 费用流 √ 「COGS 742」深海机器人 - 费用流 √ 「CTSC1999」星际转移 - 网络流 √ 「COGS 740」分配问题 - 二分图最大权匹配 √ 「COGS 741」负载平衡 - 费用流 √ 「SDOI2015」星际战争 - 网络流 √ 「SDOI2010」星际竞速 - 费用流 - 「CodeVS 2822」爱在心中 - 强连通分量 √ 「HAOI2006」受欢迎的牛 - 强连通分量 √ 「SCOI2011」糖果 - 强连通分量 + 拓扑排序 √ 「NOI2003」文本编辑器 - Splay 「SCOI2010」游戏 - 二分图匹配 √ 「AHOI2008」紧急集合 - 最近公共祖先 √ 「SCOI2007」修车 - 费用流 「NOI2006」最大获利 - 最大权闭合图 √ 「APIO2009」抢掠计划 - 强连通分量 - 「POJ 2728」Desert King - 01 分数规划 - 「UVa 11806」Cheerleaders - 组合数 + 容斥原理 - 「UVa 11538」Chess Queen - 计数原理 - 「UVa 11375」Matches - 递推 - 「UVa 11137」Ingenuous Cubrency - 递推 / 背包 DP - 「UVa 11174」Stand in a Line - 计数原理 + 乘法逆元 - 「POJ 1737」Connected Graph - 组合数 + 计数原理 + 递推 - 「UVa 1362」Exploring Pyramids - 区间 DP + 计数原理 - 「UVa 11361」Investigating Div-Sum Property - 数位 DP - 「UVa 10253」Series-Parallel Networks - 整数划分 + 组合数 √ 「SDOI2008」洞穴勘测 - Link-Cut Tree 「省选模拟赛」小奇的集合 - 矩阵乘法 「省选模拟赛」小奇的糖果 - 扫描线 + 链表 「省选模拟赛」染色 - 树链剖分 「SCOI2015」小凸玩矩阵 - 二分图匹配 「SCOI2015」情报传递 - 离线 + Link-Cut Tree 「SCOI2015」国旗计划 - 贪心 + 倍增 「BZOJ 2143」飞飞侠 - 最短路 「SCOI2015」小凸玩密室 - 树形 DP 「SCOI2015」小凸解密码 - set 「省选模拟赛」扔鸡蛋 - DP √ 「BZOJ 2038」小Z的袜子 - 莫队 「BZOJ 2296」随机种子 - 数论基础 √ 「HAOI2015」树上操作 - 树链剖分 + DFS序 截止到第 27 页","link":"/plan-menci-blog/"}],"tags":[{"name":"tarjan","slug":"tarjan","link":"/tags/tarjan/"},{"name":"点双联通分量","slug":"点双联通分量","link":"/tags/点双联通分量/"},{"name":"圆方树","slug":"圆方树","link":"/tags/圆方树/"},{"name":"美化","slug":"美化","link":"/tags/美化/"},{"name":"图论","slug":"图论","link":"/tags/图论/"},{"name":"割点","slug":"割点","link":"/tags/割点/"},{"name":"可持久化线段树","slug":"可持久化线段树","link":"/tags/可持久化线段树/"},{"name":"主席树","slug":"主席树","link":"/tags/主席树/"},{"name":"可持久化并查集","slug":"可持久化并查集","link":"/tags/可持久化并查集/"},{"name":"数学，数论","slug":"数学，数论","link":"/tags/数学，数论/"},{"name":"虚树","slug":"虚树","link":"/tags/虚树/"},{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"树形 DP","slug":"树形-DP","link":"/tags/树形-DP/"},{"name":"高斯消元","slug":"高斯消元","link":"/tags/高斯消元/"},{"name":"线性筛","slug":"线性筛","link":"/tags/线性筛/"},{"name":"树状数组","slug":"树状数组","link":"/tags/树状数组/"},{"name":"FFT","slug":"FFT","link":"/tags/FFT/"},{"name":"NTT","slug":"NTT","link":"/tags/NTT/"},{"name":"CRT","slug":"CRT","link":"/tags/CRT/"},{"name":"巧妙的思路","slug":"巧妙的思路","link":"/tags/巧妙的思路/"},{"name":"多项式","slug":"多项式","link":"/tags/多项式/"},{"name":"组合数学","slug":"组合数学","link":"/tags/组合数学/"},{"name":"多项式乘法","slug":"多项式乘法","link":"/tags/多项式乘法/"},{"name":"容斥","slug":"容斥","link":"/tags/容斥/"},{"name":"网络流","slug":"网络流","link":"/tags/网络流/"},{"name":"费用流","slug":"费用流","link":"/tags/费用流/"},{"name":"打表","slug":"打表","link":"/tags/打表/"},{"name":"结论题","slug":"结论题","link":"/tags/结论题/"},{"name":"高精度","slug":"高精度","link":"/tags/高精度/"},{"name":"最大流","slug":"最大流","link":"/tags/最大流/"},{"name":"树上差分","slug":"树上差分","link":"/tags/树上差分/"},{"name":"二分答案","slug":"二分答案","link":"/tags/二分答案/"},{"name":"博弈","slug":"博弈","link":"/tags/博弈/"},{"name":"SG 函数","slug":"SG-函数","link":"/tags/SG-函数/"},{"name":"强制在线","slug":"强制在线","link":"/tags/强制在线/"},{"name":"克鲁斯卡尔重构树","slug":"克鲁斯卡尔重构树","link":"/tags/克鲁斯卡尔重构树/"},{"name":"DFS 序","slug":"DFS-序","link":"/tags/DFS-序/"},{"name":"树上倍增","slug":"树上倍增","link":"/tags/树上倍增/"},{"name":"树链剖分","slug":"树链剖分","link":"/tags/树链剖分/"},{"name":"线段树","slug":"线段树","link":"/tags/线段树/"},{"name":"二项式反演","slug":"二项式反演","link":"/tags/二项式反演/"},{"name":"2-SAT","slug":"2-SAT","link":"/tags/2-SAT/"},{"name":"暴力枚举","slug":"暴力枚举","link":"/tags/暴力枚举/"},{"name":"数论分块","slug":"数论分块","link":"/tags/数论分块/"},{"name":"bitset","slug":"bitset","link":"/tags/bitset/"},{"name":"莫队","slug":"莫队","link":"/tags/莫队/"},{"name":"快速幂","slug":"快速幂","link":"/tags/快速幂/"},{"name":"AC 自动机","slug":"AC-自动机","link":"/tags/AC-自动机/"},{"name":"SPFA","slug":"SPFA","link":"/tags/SPFA/"},{"name":"负环","slug":"负环","link":"/tags/负环/"},{"name":"DFS","slug":"DFS","link":"/tags/DFS/"},{"name":"后缀数组","slug":"后缀数组","link":"/tags/后缀数组/"},{"name":"Hall 定理","slug":"Hall-定理","link":"/tags/Hall-定理/"},{"name":"二分图匹配","slug":"二分图匹配","link":"/tags/二分图匹配/"},{"name":"分块","slug":"分块","link":"/tags/分块/"},{"name":"拆点","slug":"拆点","link":"/tags/拆点/"},{"name":"调和级数","slug":"调和级数","link":"/tags/调和级数/"},{"name":"线性基","slug":"线性基","link":"/tags/线性基/"},{"name":"整体二分","slug":"整体二分","link":"/tags/整体二分/"},{"name":"计算几何","slug":"计算几何","link":"/tags/计算几何/"},{"name":"贪心","slug":"贪心","link":"/tags/贪心/"},{"name":"最大团","slug":"最大团","link":"/tags/最大团/"},{"name":"最大独立集","slug":"最大独立集","link":"/tags/最大独立集/"},{"name":"Bron Kerbosch","slug":"Bron-Kerbosch","link":"/tags/Bron-Kerbosch/"},{"name":"链表","slug":"链表","link":"/tags/链表/"},{"name":"倍增","slug":"倍增","link":"/tags/倍增/"},{"name":"生成函数","slug":"生成函数","link":"/tags/生成函数/"},{"name":"多项式快速幂","slug":"多项式快速幂","link":"/tags/多项式快速幂/"},{"name":"约束与放缩","slug":"约束与放缩","link":"/tags/约束与放缩/"},{"name":"状态压缩","slug":"状态压缩","link":"/tags/状态压缩/"},{"name":"背包","slug":"背包","link":"/tags/背包/"},{"name":"割","slug":"割","link":"/tags/割/"},{"name":"异或","slug":"异或","link":"/tags/异或/"},{"name":"树套树","slug":"树套树","link":"/tags/树套树/"},{"name":"动态 DP","slug":"动态-DP","link":"/tags/动态-DP/"},{"name":"全局平衡二叉树","slug":"全局平衡二叉树","link":"/tags/全局平衡二叉树/"},{"name":"矩阵乘法","slug":"矩阵乘法","link":"/tags/矩阵乘法/"},{"name":"STL","slug":"STL","link":"/tags/STL/"},{"name":"乱搞","slug":"乱搞","link":"/tags/乱搞/"},{"name":"游记","slug":"游记","link":"/tags/游记/"},{"name":"Dijkstra","slug":"Dijkstra","link":"/tags/Dijkstra/"},{"name":"最短路树","slug":"最短路树","link":"/tags/最短路树/"},{"name":"Tarjan","slug":"Tarjan","link":"/tags/Tarjan/"},{"name":"缩点","slug":"缩点","link":"/tags/缩点/"},{"name":"单调栈","slug":"单调栈","link":"/tags/单调栈/"},{"name":"线段树优化建边","slug":"线段树优化建边","link":"/tags/线段树优化建边/"},{"name":"多项式求逆","slug":"多项式求逆","link":"/tags/多项式求逆/"},{"name":"GCD","slug":"GCD","link":"/tags/GCD/"},{"name":"平衡树","slug":"平衡树","link":"/tags/平衡树/"},{"name":"分治 NTT","slug":"分治-NTT","link":"/tags/分治-NTT/"},{"name":"最长上升子序列","slug":"最长上升子序列","link":"/tags/最长上升子序列/"},{"name":"期望","slug":"期望","link":"/tags/期望/"},{"name":"Min-Max 容斥","slug":"Min-Max-容斥","link":"/tags/Min-Max-容斥/"},{"name":"IDA*","slug":"IDA","link":"/tags/IDA/"},{"name":"A*","slug":"A","link":"/tags/A/"},{"name":"估价函数","slug":"估价函数","link":"/tags/估价函数/"},{"name":"行列式","slug":"行列式","link":"/tags/行列式/"},{"name":"左偏树","slug":"左偏树","link":"/tags/左偏树/"},{"name":"逆序对","slug":"逆序对","link":"/tags/逆序对/"},{"name":"分治","slug":"分治","link":"/tags/分治/"},{"name":"FWT","slug":"FWT","link":"/tags/FWT/"},{"name":"树上高斯消元","slug":"树上高斯消元","link":"/tags/树上高斯消元/"},{"name":"概率","slug":"概率","link":"/tags/概率/"},{"name":"仙人掌","slug":"仙人掌","link":"/tags/仙人掌/"},{"name":"循环卷积","slug":"循环卷积","link":"/tags/循环卷积/"},{"name":"MTT","slug":"MTT","link":"/tags/MTT/"},{"name":"容斥原理","slug":"容斥原理","link":"/tags/容斥原理/"},{"name":"线段树分治","slug":"线段树分治","link":"/tags/线段树分治/"},{"name":"栈","slug":"栈","link":"/tags/栈/"},{"name":"背包 DP","slug":"背包-DP","link":"/tags/背包-DP/"},{"name":"二叉堆","slug":"二叉堆","link":"/tags/二叉堆/"},{"name":"卡常","slug":"卡常","link":"/tags/卡常/"},{"name":"搜索","slug":"搜索","link":"/tags/搜索/"},{"name":"树分块","slug":"树分块","link":"/tags/树分块/"},{"name":"三分法","slug":"三分法","link":"/tags/三分法/"},{"name":"LCT","slug":"LCT","link":"/tags/LCT/"},{"name":"最小生成树","slug":"最小生成树","link":"/tags/最小生成树/"},{"name":"动态最小生成树","slug":"动态最小生成树","link":"/tags/动态最小生成树/"},{"name":"卢卡斯定理","slug":"卢卡斯定理","link":"/tags/卢卡斯定理/"},{"name":"动态开点线段树","slug":"动态开点线段树","link":"/tags/动态开点线段树/"},{"name":"原根","slug":"原根","link":"/tags/原根/"},{"name":"对数函数","slug":"对数函数","link":"/tags/对数函数/"},{"name":"队列","slug":"队列","link":"/tags/队列/"},{"name":"欧拉函数","slug":"欧拉函数","link":"/tags/欧拉函数/"},{"name":"CDQ 分治","slug":"CDQ-分治","link":"/tags/CDQ-分治/"},{"name":"满流","slug":"满流","link":"/tags/满流/"},{"name":"SAM","slug":"SAM","link":"/tags/SAM/"},{"name":"LCA","slug":"LCA","link":"/tags/LCA/"},{"name":"四边形不等式优化","slug":"四边形不等式优化","link":"/tags/四边形不等式优化/"},{"name":"二维树状数组","slug":"二维树状数组","link":"/tags/二维树状数组/"},{"name":"随机化算法","slug":"随机化算法","link":"/tags/随机化算法/"},{"name":"Kruskal 重构树","slug":"Kruskal-重构树","link":"/tags/Kruskal-重构树/"},{"name":"并查集","slug":"并查集","link":"/tags/并查集/"},{"name":"基环树","slug":"基环树","link":"/tags/基环树/"},{"name":"多项式指数函数","slug":"多项式指数函数","link":"/tags/多项式指数函数/"},{"name":"BFS","slug":"BFS","link":"/tags/BFS/"},{"name":"积性函数","slug":"积性函数","link":"/tags/积性函数/"},{"name":"欧拉定理","slug":"欧拉定理","link":"/tags/欧拉定理/"},{"name":"set","slug":"set","link":"/tags/set/"},{"name":"Min_25 筛","slug":"Min-25-筛","link":"/tags/Min-25-筛/"},{"name":"点分治","slug":"点分治","link":"/tags/点分治/"},{"name":"动态点分治","slug":"动态点分治","link":"/tags/动态点分治/"},{"name":"K-D Tree","slug":"K-D-Tree","link":"/tags/K-D-Tree/"}],"categories":[{"name":"Diary","slug":"Diary","link":"/categories/Diary/"},{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"Geek","slug":"Geek","link":"/categories/Geek/"},{"name":"Solution","slug":"Solution","link":"/categories/Solution/"},{"name":"Contest","slug":"Contest","link":"/categories/Contest/"},{"name":"Plan","slug":"Plan","link":"/categories/Plan/"}]}