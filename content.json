{"meta":{"title":"memset0's blog","subtitle":"落霞与孤鹜齐飞，秋水共长天一色","description":null,"author":"memset0","url":"https://memset0.cn"},"pages":[{"title":"关于我","date":"2018-08-08T06:25:50.000Z","updated":"2018-12-08T15:26:03.122Z","comments":true,"path":"about/index-indigo.html","permalink":"https://memset0.cn/about/index-indigo.html","excerpt":"","text":"@card{ 「 落霞与孤鹜齐飞，秋水共长天一色 」 } @timeline{ 2018@item{ 12月4日在洛谷通过 800 题 } @item{ 11月5日在 BZOJ 通过 200 题 } @item{ 11月1日通关洛谷提高历练地 } @item{ 10月10日在洛谷通过 600 题 } @item{ 9月16日在洛谷通过蓝题紫题黑题共 200 题 } @item{ 8月30日在洛谷通过 400 题。 } @item{ 8月8日重新开始使用 Hexo 搭建这个博客。 } @item{ 5月26日在洛谷通过 200 题。 } 2017@item{ 12月2日开始尝试搭建个人博客。 } @item{ 7月31日在 CSDN 上发表了第一篇博客。 } }"},{"title":"分类","date":"2018-08-08T07:36:25.000Z","updated":"2018-10-10T12:14:53.321Z","comments":false,"path":"categories/index.html","permalink":"https://memset0.cn/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-08-12T12:44:30.000Z","updated":"2018-12-01T08:48:17.831Z","comments":true,"path":"friends/index.html","permalink":"https://memset0.cn/friends/index.html","excerpt":"","text":"@card{ 欢迎留言加友链 } .card h1 { background: #3f51b5; width: calc(100% + 40px); /* border-radiu: 3px; */ padding-top: 20px!important; padding-left: 20px; padding-right: 20px; margin-top: -20px!important; margin-left: -20px; margin-right: -20px; } .card h1 { font-size: 22px; color: #fff!important; } @column-2{ @card{ FriendsMenci men.ciQingnian Su cnblogs.com/cn-suqingnian_rqy rqy.moeHimself65 himself65.comriteme riteme.github.io蓝先生的小站 ble.ac.cnhz2016 hz2016.cnabc1763613206 ichr.topDecoration illusionalsky.cnChenQiQian chenqiqian.comJuicyMio juicymio.cfShq ishq.sitezshsh zsh2517.com小粉兔 cnblogs.com/PinkRabbityizr-cnyali yizr-cnyali.ac.cnyyb cnblogs.com/cjyyb } @card{ SchoolmatesScris scris.top按 Ctrl + W 会 AC cnblogs.com/xuanyiDilute dilute.coding.meWillem willem.linshihan.cnoierlin oierlin.github.iozx2003 csdn.net/zxin__zhouyuheng csdn.new/zhouyuheng2003EtaoinWu etaoinwu.winCMXRYNP cmxrynp.github.ioMichael Li csdn.net/qq_36056315yx cnblogs.com/DreamlessDreamstoxic toxic2018.ml } }"},{"title":"关于我","date":"2018-08-08T06:25:50.000Z","updated":"2018-12-09T02:36:58.429Z","comments":true,"path":"about/index.html","permalink":"https://memset0.cn/about/index.html","excerpt":"","text":"「 落霞与孤鹜齐飞，秋水共长天一色 」 table { } 2018.12 2018.12.4 洛谷 Accepted 800 题 2018.11 2018.11.5 BZOJ Accepted 200 题 2018.11.1 通关洛谷提高历练地 2018.10 2018.10.10 洛谷 Accepted 600 题 2018.9 2018.9.16 洛谷 Accepted 200 蓝紫黑题 2018.8 2018.8.30 洛谷 Accepted 400 题 2018.8.8 重构博客。 2018.7 2018-07-16 通关洛谷普及练习场 2018.5 2018.5.26 洛谷 Accepted 200 题 2017.12 2017.12.2 开始尝试搭建个人博客 2017.11 2017.11.16 通关洛谷新手村 2017.7 2017.7.31 发表了第一篇博客"},{"title":"做题总结","date":"2018-08-19T09:37:06.000Z","updated":"2018-10-10T12:14:53.322Z","comments":true,"path":"notes/ringo-is-cute.html","permalink":"https://memset0.cn/notes/ringo-is-cute.html","excerpt":"","text":"@card{ 数学，数论均摊 线性 模拟 环形 负载平衡问题[no link] 找到a[i]和a[i+1]保证他们不会被交换（易证存在） 破环为链，变为线性 树剖换根 换根维护子树：分类讨论 P3979 $u = root$ ：整棵树 $u \\not= lca(u, root)$ ：与换根无关 $u = lca(u, root)$ ：root到u的链中u的孩子的子树在所有点中的补集 换根维护LCA CF916E 分别求出 $lca(u, v)$ 、$lca(u, root)$、$lca(u, root)$ 取上面三个中深度最大的 }"},{"title":"任务列表","date":"2018-09-25T07:09:51.000Z","updated":"2018-10-10T12:14:53.322Z","comments":true,"path":"todo/index.html","permalink":"https://memset0.cn/todo/index.html","excerpt":"","text":"@card{ BZOJ} @card{ https://blog.csdn.net/csyzcyj/article/details/9343379[bzoj1756]Vijos1083小白逛公园 裸题- -。。线段树维护lmax,rmax,max,sum然后搞之。。 [Usaco2006 Nov]Roadblocks第二短路 我写的a*。。吐槽下。。这题的数据真的很弱。。第一次提交都忘判断第一短和第二短是否相等结果还a了。。囧 [Usaco2006 Nov]Fence Repair 切割木板 倒过来就是石子合并。。 [Usaco2007 Oct]Money奶牛的硬币 囧。。这为什么会是gold的题。。 [HNOI2003]激光炸弹 各种做法。。我看时限是10s就暴力枚举所有正方形了= =。。 [SCOI2009]粉刷匠 先dp出每一行涂k次的最多正确粉刷，再用对每行dp [Usaco2008Nov]安慰奶牛cheer 转化一下就是最小生成树。。边权=边权*2+端点点权。。再找到最小点权的起点加到ans里就好 [HNOI2004]打鼹鼠 按时间dp。。- - [bzoj1251]序列终结者 裸splay题。。- - [Scoi2010]游戏 明显是匹配。。 [Jsoi2011]括号序列 这题搞死我了。。= =。。维护flip,reverse,flipreverse三个形态。。然后狂写就好。。注意别把建树的复杂度搞成n^2。。（我是沙茶啊啊啊因为这t了一晚上。。） [JSOI2010]Group 部落划分 按边权排序，然后一次一次合并两个端点。。用并查集维护 [HNOI2008]GT考试 kmp上dp+矩阵乘。。好久不写kmp了。。 [Usaco2007 Jan]Running贝茜的晨练计划 dp。。一开始我还想暴力写2维的。。结果好像没这个必要- - [Baltic2009]monument 枚举坐标轴，在一个和这个轴垂直的所有面上做dp求出以x,y为左上角能得到的最大正方形。。然后再枚举正方形上每个点，沿着垂直于正方形的面上来回扫一遍就ok [Zjoi2011]礼物(gift) 同上= =。。 [HNOI2006]超级英雄Hero 又是裸匹配。。- - [Usaco2006 Oct]Another Cow Number Game 奶牛的数字游戏 无语的题。。 Usaco2008 Feb]Line连线游戏 囧。。。排个序然后扫一遍。。 [Usaco2008 Feb]Eating Together麻烦的聚餐 nlgn求最长非降，正着逆着都求一遍取最大。。 [Usaco2008 Mar]River Crossing渡河问题 裸dp。。 [Usaco2007 Jan]Balanced Lineup排队 裸线段树或树状数组或sparsetable。。 [Usaco2007 Dec]宝石手镯 01背包= = [Usaco2008 Oct]灌水 新增一个点连向所有的点边权是wi。。然后最小生成树之= = [ZJOI2007]仓库建设 斜率优化= =。。 [BeiJing2010组队]能量魔方 Cube 囧囧的最小割。。一开始没思路。。题解请见http://hi.baidu.com/edwardmj/blog/item/db04b53cc3fe8e3071cf6c7e.html [POI2008]砖块Klo 要求一个数据结构满足插入/删除一个数以及求中位数和对区间求和。。splay水掉。。 [BeiJing2010]取数游戏 game dp。。如果一个数能被取到，那么更新它所有&gt;=L的约数。。 [POI2008]CLO 可以发现只有树结构不满足条件。。枚举连通分量然后判断是不是树结构 [Poi2008]海报PLA 用栈维护一个递增序列。。搞搞就过了 [POI2008]激光发射器SZK 这题太囧了。。一开始不会。。去orz题解。。结果。。。。。。。。。。。。。。printf(“%d\\n”,n/2); [bzoj1475]方格取数 最大权独立集。。转化成最小割来做就好。。网络流24题里原题 [Usaco2008 Feb]Hotel 以前poj上做过，也是维护左、右、和最长连续的空位。。 [Usaco2008 Oct]笨重的石子 无语的题。。 [bzoj2045]双亲数 和poi2007zap神似，不过比zap简单好多。。可以像能量采集一样nlnn水过XD [NOI2007]货币兑换Cash 被虐到死。。 [bzoj1477]青蛙的约会 裸扩展gcd。。好像poj上也有过 [Usaco2008 Mar]土地购买 如果有大的矩形完全包住小的矩形，就先把小的去了，再斜率优化dp搞掉。。 [SCOI2009]生日礼物 排个序，然后扫一遍。。 [ZJOI2006]物流运输trans 枚举起始点和结束点，然后每次都建图跑最短路。。最后用dp [ZJOI2008]生日聚会Party dp。。dp[a][b][c][d]表示前a个人b个是男孩，其中到现在男的比女的多c个，女的比男的多d个。。（c或d必有一为0。。）。。弱死了。。一开始不会T_T。。 [SCOI2005]最大子矩阵 dp。。边界问题搞死我阿。。 [Ioi2007]Miners 矿工配餐 5维dp+滚动数组水过。。 }"},{"title":"标签","date":"2018-08-08T07:35:56.000Z","updated":"2018-10-10T12:14:53.322Z","comments":false,"path":"tags/index.html","permalink":"https://memset0.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"洛谷2606 - [ZJOI2010]排列计数","slug":"solution/luogu/2606","date":"2018-12-09T02:39:31.000Z","updated":"2018-12-09T02:53:08.800Z","comments":true,"path":"solution/luogu/2606/","link":"","permalink":"https://memset0.cn/solution/luogu/2606/","excerpt":"原问题等价于询问节点个数为 $ n $ 的完全二叉树形态的二叉堆的个数。 考虑递推，用 $ f(i) $ 表示 $ i $ 个节点时的答案。考虑除去此时的根节点外，根的左右子树大小分别为 $ l $ 和 $ r $ （可由完全二叉树这一性质计算得出）。此时根节点的编号肯定为 $ 1 $ ，而 $ f(l) $ 和 $ f(r) $ 分别是子树中的根节点编号为 $ 1 $ 的情况，若把编号分配，相当于求两个有序数列并成一个的方案数，即 $ C _ { l + r} ^ l $。得出： $$ f(i) = f(l) \\times f(r) \\times C _ { l + r } ^ l $$ 预处理阶乘递推即可。若 $ n &gt; q $ 则需要卢卡斯定理简单处理。","text":"原问题等价于询问节点个数为 $ n $ 的完全二叉树形态的二叉堆的个数。 考虑递推，用 $ f(i) $ 表示 $ i $ 个节点时的答案。考虑除去此时的根节点外，根的左右子树大小分别为 $ l $ 和 $ r $ （可由完全二叉树这一性质计算得出）。此时根节点的编号肯定为 $ 1 $ ，而 $ f(l) $ 和 $ f(r) $ 分别是子树中的根节点编号为 $ 1 $ 的情况，若把编号分配，相当于求两个有序数列并成一个的方案数，即 $ C _ { l + r} ^ l $。得出： $$ f(i) = f(l) \\times f(r) \\times C _ { l + r } ^ l $$ 预处理阶乘递推即可。若 $ n &gt; q $ 则需要卢卡斯定理简单处理。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// =================================// author: memset0// date: 2018.12.07 13:51:11// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;namespace ringo &#123;typedef long long ll;template &lt; class T &gt;inline void read(T &amp;x) &#123; x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;&#125;template &lt; class T &gt;inline void print(T x) &#123; if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);&#125;template &lt; class T &gt;inline void print(T x, char c) &#123; print(x), putchar(c);&#125;const int N = 1e6 + 10;int n, p, l, r, t;int fac[N], inv[N], ans[N], lg2[N];int c(int n, int m) &#123; return (ll)fac[n] * inv[m] % p * inv[n - m] % p; &#125;int lucas(int n, int m) &#123; return m ? (ll)c(n % p, m % p) * lucas(n / p, m / p) % p : 1; &#125;void main() &#123; read(n), read(p); fac[0] = inv[0] = inv[1] = 1; for (int i = 1; i &lt;= std::min(n, p); i++) fac[i] = (ll)fac[i - 1] * i % p; for (int i = 2; i &lt;= std::min(n, p); i++) inv[i] = (ll)(p - p / i) * inv[p % i] % p; for (int i = 1; i &lt;= std::min(n, p); i++) inv[i] = (ll)inv[i] * inv[i - 1] % p; for (int i = 1; (1 &lt;&lt; i) &lt;= n + 1; i++) lg2[1 &lt;&lt; i] = i; for (int i = 1; i &lt;= n + 1; i++) lg2[i] = lg2[lg2[i] ? i : i - 1]; ans[0] = 1; for (int i = 1; i &lt;= n; i++) &#123; t = lg2[i + 1], l = std::min((1 &lt;&lt; t) - 1, i - (1 &lt;&lt; (t - 1))), r = i - 1 - l; ans[i] = (ll)lucas(i - 1, l) * ans[l] % p * ans[r] % p; &#125; print(ans[n], '\\n');&#125;&#125; signed main() &#123; return ringo::main(), 0; &#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"https://memset0.cn/categories/Solution/"}],"tags":[{"name":"数学，数论","slug":"数学，数论","permalink":"https://memset0.cn/tags/数学，数论/"}]},{"title":"BZOJ4939 - [YNOI2016] 掉进兔子洞","slug":"solution/bzoj/4939","date":"2018-12-08T10:15:32.000Z","updated":"2018-12-09T02:10:40.007Z","comments":true,"path":"solution/bzoj/4939/","link":"","permalink":"https://memset0.cn/solution/bzoj/4939/","excerpt":"bitset 套莫队板子题。 题意是如果第一个区间里有 $ a $ 个 $ x $ ，第二个区间 $ b $ 个，第三个区间 $ c $ 个，只会对答案产生 $ \\min(a, b, c) $ 的贡献；每次询问给你三个区间，问你三个区间里能产生这样的贡献的大小。 考虑 bitset 套莫队。通过一个简单的 trick 似的 bitset 既能反映出每种数又能反映出每种数的个数，每个查询就用三个区间的 bitset 的按位并，取结果的 count 。\u001e 然而 $ 10^5 $ 个 $ 10^5 $ 的 bitset 会 MLE 。我们把莫队分成三次，只需要三分之一的空间，可以卡进。 看起来这样 $ O(n ^ 2) $ 的复杂度过不了 $ n = 10^5 $ ，但是由于使用了 bitset 的关系，常数实际上只有 1 / 32 ，实际跑的飞快。","text":"bitset 套莫队板子题。 题意是如果第一个区间里有 $ a $ 个 $ x $ ，第二个区间 $ b $ 个，第三个区间 $ c $ 个，只会对答案产生 $ \\min(a, b, c) $ 的贡献；每次询问给你三个区间，问你三个区间里能产生这样的贡献的大小。 考虑 bitset 套莫队。通过一个简单的 trick 似的 bitset 既能反映出每种数又能反映出每种数的个数，每个查询就用三个区间的 bitset 的按位并，取结果的 count 。\u001e 然而 $ 10^5 $ 个 $ 10^5 $ 的 bitset 会 MLE 。我们把莫队分成三次，只需要三分之一的空间，可以卡进。 看起来这样 $ O(n ^ 2) $ 的复杂度过不了 $ n = 10^5 $ ，但是由于使用了 bitset 的关系，常数实际上只有 1 / 32 ，实际跑的飞快。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// =================================// author: memset0// date: 2018.12.07 10:39:36// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;namespace ringo &#123;typedef long long ll;template &lt; class T &gt;inline void read(T &amp;x) &#123; x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;&#125;template &lt; class T &gt;inline void print(T x) &#123; if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);&#125;template &lt; class T &gt;inline void print(T x, char c) &#123; print(x), putchar(c);&#125;const int N = 1e5 + 10;int n, m, ul, ur, ql, qr, pos, sqn, sqm, tail;int a[N], b[N], id[N], ans[N], cnt[N];std::bitset &lt; N &gt; now, f[N / 3];struct query &#123; int l1, r1, l2, r2, l3, r3; inline void read_query(int i) &#123; // printf(\"read query %d\\n\", i); read(l1), read(r1), read(l2), read(r2), read(l3), read(r3); ans[i] += r1 - l1 + r2 - l2 + r3 - l3 + 3; &#125;&#125; q[N];struct query_small &#123; int l, r, i; inline bool operator &lt; (const query_small &amp;other) const &#123; if (l / sqn == other.l / sqn) return r &lt; other.r; return l &lt; other.l; &#125;&#125; p[N];inline void add(int x) &#123; ++cnt[x]; now.set(x + cnt[x] - 1);&#125;inline void del(int x) &#123; now.reset(x + cnt[x] - 1); --cnt[x];&#125;void solve(int L, int R) &#123; pos = 0, tail = 0, now.reset(), memset(cnt, 0, sizeof(cnt)); for (int i = L; i &lt;= R; i++) &#123; id[i] = ++pos; p[++tail] = (query_small)&#123;q[i].l1, q[i].r1, i&#125;; p[++tail] = (query_small)&#123;q[i].l2, q[i].r2, i&#125;; p[++tail] = (query_small)&#123;q[i].l3, q[i].r3, i&#125;; &#125; for (int i = 1; i &lt;= pos; i++) f[i].set(); std::sort(p + 1, p + tail + 1); ul = 1, ur = 0; for (int i = 1; i &lt;= tail; i++) &#123; ql = p[i].l, qr = p[i].r; while (ul &gt; ql) add(a[--ul]); while (ur &lt; qr) add(a[++ur]); while (ul &lt; ql) del(a[ul++]); while (ur &gt; qr) del(a[ur--]); f[id[p[i].i]] &amp;= now; &#125; for (int i = L; i &lt;= R; i++) ans[i] -= f[id[i]].count() * 3;&#125;void main() &#123; read(n), read(m), sqn = sqrt(n), sqm = m / 3 + 1; for (int i = 1; i &lt;= n; i++) read(a[i]), b[i] = a[i]; std::sort(b + 1, b + n + 1); for (int i = 1; i &lt;= n; i++) a[i] = std::lower_bound(b + 1, b + n + 1, a[i]) - b; for (int i = 1; i &lt;= m; i++) q[i].read_query(i); for (int i = 1; i &lt;= m; i += sqm) solve(i, std::min(m, i + sqm - 1)); for (int i = 1; i &lt;= m; i++) print(ans[i], '\\n');&#125;&#125; signed main() &#123; return ringo::main(), 0; &#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"https://memset0.cn/categories/Solution/"}],"tags":[{"name":"bitset","slug":"bitset","permalink":"https://memset0.cn/tags/bitset/"},{"name":"莫队","slug":"莫队","permalink":"https://memset0.cn/tags/莫队/"}]},{"title":"多项式系列板子","slug":"algorithm/多项式","date":"2018-12-02T03:47:49.000Z","updated":"2018-12-04T00:39:07.200Z","comments":true,"path":"algorithm/多项式/","link":"","permalink":"https://memset0.cn/algorithm/多项式/","excerpt":"快速傅里叶变换 FFT 数论傅里叶变换 NTT 任意模数 NTT 多项式求逆 未完待续……","text":"快速傅里叶变换 FFT 数论傅里叶变换 NTT 任意模数 NTT 多项式求逆 未完待续…… 快速傅里叶变换 FFT12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;#define il inline#define rg register#define ll long long#define getc getchar#define putc putchar#define rep(i, l, r) for (int i = l; i &lt;= r; ++i)namespace ringo &#123;template &lt; class T &gt; il void read(T &amp;x) &#123; x = 0; rg char c = getc(); rg bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getc(); while (isdigit(c)) x = x * 10 + c - '0', c = getc(); if (f) x = -x;&#125;template &lt; class T &gt; il void print(T x) &#123; if (x &lt; 0) putc('-'), x = -x; if (x &gt; 9) print(x / 10); putc('0' + x % 10);&#125;const int maxn = 4e6 + 10;const double pi = acos(-1);int n, k, n1, n2, rev[maxn];struct complex &#123; double x, y; il complex(const double &amp;a = 0, const double &amp;b = 0) &#123; x = a, y = b; &#125; il complex operator + (const complex &amp;b) const &#123; return complex(x + b.x, y + b.y); &#125; il complex operator - (const complex &amp;b) const &#123; return complex(x - b.x, y - b.y); &#125; il complex operator * (const complex &amp;b) const &#123; return complex(x * b.x - y * b.y, x * b.y + y * b.x); &#125;&#125; a[maxn], b[maxn];void fft(complex *a, int flag) &#123; for (int i = 0; i &lt; n; i++) if (i &lt; rev[i]) std::swap(a[i], a[rev[i]]); for (int len = 1; len &lt; n; len &lt;&lt;= 1) &#123; complex wn(cos(pi / len), flag * sin(pi / len)); for (int i = 0; i &lt; n; i += (len &lt;&lt; 1)) &#123; complex w(1, 0); for (int j = 0; j &lt; len; j++, w = w * wn) &#123; complex x = a[i + j], y = w * a[i + j + len]; a[i + j] = x + y, a[i + j + len] = x - y; &#125; &#125; &#125;&#125;void main() &#123; read(n1), read(n2); for (int i = 0; i &lt;= n1; i++) read(a[i].x); for (int i = 0; i &lt;= n2; i++) read(b[i].x); n = 1; while (n &lt;= (n1 + n2)) n &lt;&lt;= 1, ++k; for (int i = 0; i &lt; n; i++) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (k - 1)); fft(a, 1), fft(b, 1); for (int i = 0; i &lt; n; i++) a[i] = a[i] * b[i]; fft(a, -1); for (int i = 0; i &lt;= n1 + n2; i++) print((int)(a[i].x / n + 0.5)), putc(i == n1 + n2 ? '\\n' : ' ');&#125;&#125; int main() &#123; return ringo::main(), 0; &#125; 数论傅里叶变换 NTT12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;#define il inline#define rg register#define ll long long#define getc getchar#define putc putchar#define rep(i, l, r) for (int i = l; i &lt;= r; ++i)namespace ringo &#123;template &lt; class T &gt; il void read(T &amp;x) &#123; x = 0; rg char c = getc(); rg bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getc(); while (isdigit(c)) x = x * 10 + c - '0', c = getc(); if (f) x = -x;&#125;template &lt; class T &gt; il void print(T x) &#123; if (x &lt; 0) putc('-'), x = -x; if (x &gt; 9) print(x / 10); putc('0' + x % 10);&#125;const int maxn = 4e6 + 10, P = 998244353, G = 3;int n, k, n1, n2, tmp, rev[maxn];ll a[maxn], b[maxn];int inv(int x) &#123; if (x == 0 || x == 1) return 1; return 1ll * (P - P / x) * inv(P % x) % P;&#125;int pow(ll x, int b) &#123; ll s = 1; while (b) &#123; if (b &amp; 1) (s *= x) %= P; (x *= x) %= P, b &gt;&gt;= 1; &#125; return s;&#125;void ntt(ll *a, int G) &#123; for (int i = 0; i &lt; n; i++) if (i &lt; rev[i]) std::swap(a[i], a[rev[i]]); for (int len = 1; len &lt; n; len &lt;&lt;= 1) &#123; ll wn = pow(G, (P - 1) / (len &lt;&lt; 1)); for (int i = 0; i &lt; n; i += (len &lt;&lt; 1)) &#123; ll w = 1; for (int j = 0; j &lt; len; j++, w = w * wn % P) &#123; ll x = a[i + j], y = w * a[i + j + len] % P; a[i + j] = (x + y) % P, a[i + j + len] = (x - y + P) % P; &#125; &#125; &#125;&#125;void main() &#123; read(n1), read(n2); for (int i = 0; i &lt;= n1; i++) read(a[i]), a[i] %= P; for (int i = 0; i &lt;= n2; i++) read(b[i]), b[i] %= P; n = 1; while (n &lt;= (n1 + n2)) n &lt;&lt;= 1, ++k; for (int i = 0; i &lt; n; i++) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (k - 1)); ntt(a, G), ntt(b, G); for (int i = 0; i &lt; n; i++) a[i] = a[i] * b[i] % P; ntt(a, inv(G)), tmp = inv(n); for (int i = 0; i &lt;= n1 + n2; i++) print(a[i] * tmp % P), putc(i == n1 + n2 ? '\\n' : ' ');&#125;&#125; int main() &#123; return ringo::main(), 0; &#125; 任意模数 NTT123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;namespace ringo &#123;typedef long long ll;template &lt; class T &gt;inline void read(T &amp;x) &#123; x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;&#125;template &lt; class T &gt;inline void print(T x) &#123; if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);&#125;template &lt; class T &gt;inline void print(T x, char c) &#123; print(x), putchar(c);&#125;const int N = 4e5 + 10, G = 3, P[3] = &#123;469762049, 998244353, 1004535809&#125;;int n1, n2, k, n, p, p1, p2, M2;int a[N], b[N], f[3][N], g[N], rev[N], ans[N];int inv(int x, int p) &#123; if (x &gt;= p) return inv(x % p, p); return !x || x == 1 ? 1 : (ll)(p - p / x) * inv(p % x, p) % p;&#125;int pow(int a, int b, int p) &#123; int s = 1; while (b) &#123; if (b &amp; 1) s = (ll)s * a % p; b &gt;&gt;= 1, a = (ll)a * a % p; &#125; return s;&#125;void ntt(int *a, int g, int p) &#123; for (int i = 0; i &lt; n; i++) if (i &lt; rev[i]) std::swap(a[i], a[rev[i]]); for (int len = 1; len &lt; n; len &lt;&lt;= 1) &#123; int wn = pow(g, (p - 1) / (len &lt;&lt; 1), p); for (int i = 0; i &lt; n; i += (len &lt;&lt; 1)) &#123; int w = 1; for (int j = 0; j &lt; len; j++, w = (ll)w * wn % p) &#123; int x = a[i + j], y = (ll)w * a[i + j + len] % p; a[i + j] = (x + y) % p, a[i + j + len] = (x - y + p) % p; &#125; &#125; &#125;&#125;int merge(int a1, int a2, int A2) &#123; ll M1 = (ll)p1 * p2; ll A1 = ((ll)inv(p2, p1) * a1 % p1 * p2 + (ll)inv(p1, p2) * a2 % p2 * p1) % M1; ll K = ((A2 - A1) % M2 + M2) % M2 * inv(M1 % M2, M2) % M2; int ans = (A1 + M1 % p * K) % p; return ans;&#125;void main() &#123; read(n1), read(n2), read(p); p1 = P[0], p2 = P[1], M2 = P[2]; for (int i = 0; i &lt;= n1; i++) read(a[i]); for (int i = 0; i &lt;= n2; i++) read(b[i]); n = 1; while (n &lt;= (n1 + n2)) n &lt;&lt;= 1, ++k; for (int i = 0; i &lt; n; i++) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (k - 1)); for (int k = 0; k &lt; 3; k++) &#123; for (int i = 0; i &lt; n; i++) f[k][i] = a[i] % P[k]; for (int i = 0; i &lt; n; i++) g[i] = b[i] % P[k]; ntt(f[k], G, P[k]), ntt(g, G, P[k]); for (int i = 0; i &lt; n; i++) f[k][i] = (ll)f[k][i] * g[i] % P[k]; ntt(f[k], inv(G, P[k]), P[k]); for (int i = 0; i &lt; n; i++) f[k][i] = (ll)f[k][i] * inv(n, P[k]) % P[k]; &#125; for (int i = 0; i &lt;= n1 + n2; i++) ans[i] = merge(f[0][i], f[1][i], f[2][i]); for (int i = 0; i &lt;= n1 + n2; i++) print(ans[i], \" \\n\"[i == n1 + n2]); &#125;&#125; signed main() &#123; return ringo::main(), 0; &#125; 多项式求逆1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// =================================// author: memset0// date: 2018.12.03 12:19:03// website: https://memset0.cn/// =================================#include &lt;bits/stdc++.h&gt;namespace ringo &#123;typedef long long ll;template &lt; class T &gt;inline void read(T &amp;x) &#123; x = 0; register char c = getchar(); register bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (f) x = -x;&#125;template &lt; class T &gt;inline void print(T x) &#123; if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) print(x / 10); putchar('0' + x % 10);&#125;template &lt; class T &gt;inline void print(T x, char c) &#123; print(x), putchar(c);&#125;const int N = 4e5 + 10, p = 998244353;int n, k, i, lim, lim_inv;int a[N], b[N], f[N], g[N], rev[N];int fpow(int a, int b) &#123; int s = 1; while (b) &#123; if (b &amp; 1) s = (ll)s * a % p; b &gt;&gt;= 1, a = (ll)a * a % p; &#125; return s;&#125;void ntt(int *a, int g) &#123; for (int i = 0; i &lt; lim; i++) if (i &lt; rev[i]) std::swap(a[i], a[rev[i]]); for (int len = 1; len &lt; lim; len &lt;&lt;= 1) &#123; int wn = fpow(g, (p - 1) / (len &lt;&lt; 1)); for (int i = 0; i &lt; lim; i += (len &lt;&lt; 1)) &#123; int w = 1; for (int j = 0; j &lt; len; j++, w = (ll)w * wn % p) &#123; int x = a[i + j], y = (ll)w * a[i + j + len] % p; a[i + j] = (x + y) % p, a[i + j + len] = (x - y + p) % p; &#125; &#125; &#125;&#125;void solve(int *a, int *b, int n) &#123; if (n == 1) &#123; b[0] = fpow(a[0], p - 2); return; &#125; solve(a, b, n &gt;&gt; 1); memset(f, 0, sizeof(f)), memset(g, 0, sizeof(g)); for (int i = 0; i &lt; n; i++) f[i] = a[i], g[i] = b[i]; lim = 1, k = 0; while (lim != (n &lt;&lt; 1)) lim &lt;&lt;= 1, ++k; for (int i = 0; i &lt; lim; i++) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (k - 1)); ntt(f, 3), ntt(g, 3); for (int i = 0; i &lt; lim; i++) f[i] = (ll)f[i] * g[i] % p * g[i] % p; ntt(f, fpow(3, p - 2)), lim_inv = fpow(lim, p - 2); for (int i = 0; i &lt; n; i++) b[i] = (2ll * b[i] - (ll)f[i] * lim_inv % p + p) % p;&#125;void main() &#123; for (read(n), i = 0; i &lt; n; i++) read(a[i]); lim = 1; while (lim &lt; n) lim &lt;&lt;= 1; solve(a, b, lim); for (int i = 0; i &lt; n; i++) print(b[i], \" \\n\"[i == n - 1]);&#125;&#125; signed main() &#123; return ringo::main(), 0; &#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://memset0.cn/categories/Algorithm/"}],"tags":[{"name":"FFT","slug":"FFT","permalink":"https://memset0.cn/tags/FFT/"},{"name":"NTT","slug":"NTT","permalink":"https://memset0.cn/tags/NTT/"},{"name":"CRT","slug":"CRT","permalink":"https://memset0.cn/tags/CRT/"}]},{"title":"洛谷5046 - [YNOI2019] Yuno loves sqrt technology I","slug":"solution/luogu/5046","date":"2018-11-24T04:33:01.000Z","updated":"2018-12-09T02:14:19.422Z","comments":true,"path":"solution/luogu/5046/","link":"","permalink":"https://memset0.cn/solution/luogu/5046/","excerpt":"一道卡常题。考虑分块。 如果查询的 $l$ 和 $r$ 不在同一个块内。 12查询区间 =&gt; ┌-----------------------------┐分好的块 =&gt; [.........][........][........][........][........][........] 把查询的区间分成三个部分、A（块前零散部分）、B（整块的）、C（块后零散部分） 先考虑每个部分自身与自身匹配对答案的贡献。我们可以预处理出从每个点出发，到所属块的开始 / 结尾的逆序对个数，分别用 lft[] 和 rit[] 表示，预处理时间复杂度 $O(\\sqrt n \\times \\sqrt n \\times \\log n)$。 123┌-----1.-----┐ 1. 这一部分的逆序对个数表示为 lft[i] ┌-----2.----┐ 2. 这一部分的逆序对个数表示为 rit[i][............i...........] 接下来我们考虑 A -&gt; B ， C -&gt; B 的贡献，类似于蒲公英这题，处理出 cnt[i][j] 数组表示前 $i$ 个块内小于等于 $j$ 的数字个数，查询时枚举 A 和 C 中的每一个数，利用这个前缀和查询对答案的贡献。这个部分也可以不在查询的时候做，而是预处理出结果，做二维前缀和，直接查询。 接下来考虑 A -&gt; C 的贡献，由于 A 和 C 是不重合的两个部分，可以采用类似归并排序的方法，把两个序列合并的同时计算出逆序对个数。 如果查询的 $l$ 和 $r$ 在同一个块内。 首先我们考虑，相邻的两个区间 A 和 B 。A 和 B 总共的逆序对个数，等于 A 内部的逆序对个数 + B 内部的逆序对个数 + A 对 B 贡献的逆序对个数。 好，那么我们再来考虑 $l$ 和 $r$ 在同一个块内： 1234┌------A+B-------┐ 这一部分即之前已经处理出的 lft[r]┌----A----┐ 这一部分即之前已经处理出的 lft[l] ┌--B---┐[.........l......r.......] 现在我们要求 B 的逆序对个数，只需要把 A + B 的逆序对个数减掉 A 内部的逆序对个数，再减掉 A 对 B 的逆序对个数即可。 剩下你只需要时间来卡常。","text":"一道卡常题。考虑分块。 如果查询的 $l$ 和 $r$ 不在同一个块内。 12查询区间 =&gt; ┌-----------------------------┐分好的块 =&gt; [.........][........][........][........][........][........] 把查询的区间分成三个部分、A（块前零散部分）、B（整块的）、C（块后零散部分） 先考虑每个部分自身与自身匹配对答案的贡献。我们可以预处理出从每个点出发，到所属块的开始 / 结尾的逆序对个数，分别用 lft[] 和 rit[] 表示，预处理时间复杂度 $O(\\sqrt n \\times \\sqrt n \\times \\log n)$。 123┌-----1.-----┐ 1. 这一部分的逆序对个数表示为 lft[i] ┌-----2.----┐ 2. 这一部分的逆序对个数表示为 rit[i][............i...........] 接下来我们考虑 A -&gt; B ， C -&gt; B 的贡献，类似于蒲公英这题，处理出 cnt[i][j] 数组表示前 $i$ 个块内小于等于 $j$ 的数字个数，查询时枚举 A 和 C 中的每一个数，利用这个前缀和查询对答案的贡献。这个部分也可以不在查询的时候做，而是预处理出结果，做二维前缀和，直接查询。 接下来考虑 A -&gt; C 的贡献，由于 A 和 C 是不重合的两个部分，可以采用类似归并排序的方法，把两个序列合并的同时计算出逆序对个数。 如果查询的 $l$ 和 $r$ 在同一个块内。 首先我们考虑，相邻的两个区间 A 和 B 。A 和 B 总共的逆序对个数，等于 A 内部的逆序对个数 + B 内部的逆序对个数 + A 对 B 贡献的逆序对个数。 好，那么我们再来考虑 $l$ 和 $r$ 在同一个块内： 1234┌------A+B-------┐ 这一部分即之前已经处理出的 lft[r]┌----A----┐ 这一部分即之前已经处理出的 lft[l] ┌--B---┐[.........l......r.......] 现在我们要求 B 的逆序对个数，只需要把 A + B 的逆序对个数减掉 A 内部的逆序对个数，再减掉 A 对 B 的逆序对个数即可。 剩下你只需要时间来卡常。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#pragma GCC diagnostic error \"-std=c++11\"#pragma GCC target(\"avx\")#pragma GCC optimize(3)#pragma GCC optimize(\"Ofast\")#pragma GCC optimize(\"inline\")#pragma GCC optimize(\"-fgcse\")#pragma GCC optimize(\"-fgcse-lm\")#pragma GCC optimize(\"-fipa-sra\")#pragma GCC optimize(\"-ftree-pre\")#pragma GCC optimize(\"-ftree-vrp\")#pragma GCC optimize(\"-fpeephole2\")#pragma GCC optimize(\"-ffast-math\")#pragma GCC optimize(\"-fsched-spec\")#pragma GCC optimize(\"unroll-loops\")#pragma GCC optimize(\"-falign-jumps\")#pragma GCC optimize(\"-falign-loops\")#pragma GCC optimize(\"-falign-labels\")#pragma GCC optimize(\"-fdevirtualize\")#pragma GCC optimize(\"-fcaller-saves\")#pragma GCC optimize(\"-fcrossjumping\")#pragma GCC optimize(\"-fthread-jumps\")#pragma GCC optimize(\"-funroll-loops\")#pragma GCC optimize(\"-fwhole-program\")#pragma GCC optimize(\"-freorder-blocks\")#pragma GCC optimize(\"-fschedule-insns\")#pragma GCC optimize(\"inline-functions\")#pragma GCC optimize(\"-ftree-tail-merge\")#pragma GCC optimize(\"-fschedule-insns2\")#pragma GCC optimize(\"-fstrict-aliasing\")#pragma GCC optimize(\"-fstrict-overflow\")#pragma GCC optimize(\"-falign-functions\")#pragma GCC optimize(\"-fcse-skip-blocks\")#pragma GCC optimize(\"-fcse-follow-jumps\")#pragma GCC optimize(\"-fsched-interblock\")#pragma GCC optimize(\"-fpartial-inlining\")#pragma GCC optimize(\"no-stack-protector\")#pragma GCC optimize(\"-freorder-functions\")#pragma GCC optimize(\"-findirect-inlining\")#pragma GCC optimize(\"-fhoist-adjacent-loads\")#pragma GCC optimize(\"-frerun-cse-after-loop\")#pragma GCC optimize(\"inline-small-functions\")#pragma GCC optimize(\"-finline-small-functions\")#pragma GCC optimize(\"-ftree-switch-conversion\")#pragma GCC optimize(\"-foptimize-sibling-calls\")#pragma GCC optimize(\"-fexpensive-optimizations\")#pragma GCC optimize(\"-funsafe-loop-optimizations\")#pragma GCC optimize(\"inline-functions-called-once\")#pragma GCC optimize(\"-fdelete-null-pointer-checks\")#include &lt;bits/stdc++.h&gt;#define il inline#define rg register#define ll long long#define getc getchar#define putc putchar#define rep(i, l, r) for (int i = l; i &lt;= r; ++i)namespace ringo &#123;template &lt; class T &gt; il void read(T &amp;x) &#123; x = 0; rg char c = getc(); rg bool f = 0; while (!isdigit(c)) f ^= c == '-', c = getc(); while (isdigit(c)) x = x * 10 + c - '0', c = getc(); if (f) x = -x;&#125;template &lt; class T &gt; il void print(T x) &#123; if (x &lt; 0) putc('-'), x = -x; if (x &gt; 9) print(x / 10); putc('0' + x % 10);&#125;const int N = 1e5 + 5, sqn = 320, M = sqn + 5, P = N / sqn + 5;int n, m, l, r, l1, l2, r1, r2, siz;int a[N], rnk[N], srt[N], bln[N], lft[N], rit[N], s[M], q1[M], q2[M], fst[P], cnt[P][N];ll ans, fur[P], sum[P][P], pre[P][N];bool tag[M];void modify(int k) &#123; for (; k &lt;= siz; k += k &amp; -k) ++s[k]; &#125;int query(int k) &#123; int x = 0; for (; k; k -= k &amp; -k) x += s[k]; return x; &#125;ll get(int a, int b, int c, int d) &#123; return pre[b][d] - pre[b][c - 1] - pre[a - 1][d] + pre[a - 1][c - 1]; &#125;int merge(int ll1, int rr1, int ll2, int rr2) &#123; int l1 = 1, l2 = 1, r1 = 0, r2 = 0, ans = 0; memset(tag, 0, sizeof(tag)); for (rg int i = ll1; i &lt;= rr1; i++) tag[rnk[i]] = 1; for (rg int i = 1; i &lt;= fst[bln[l] + 1] - fst[bln[l]]; ++i) if (tag[i]) q1[++r1] = srt[fst[bln[l]] + i - 1]; memset(tag, 0, sizeof(tag)); for (rg int i = ll2; i &lt;= rr2; i++) tag[rnk[i]] = 1; for (rg int i = 1; i &lt;= fst[bln[r] + 1] - fst[bln[r]]; ++i) if (tag[i]) q2[++r2] = srt[fst[bln[r]] + i - 1]; while (l1 &lt;= r1 &amp;&amp; l2 &lt;= r2) if (q1[l1] &lt; q2[l2]) ++l1; else ++l2, ans += r1 - l1 + 1; return ans;&#125;void main() &#123; read(n), read(m); for (rg int i = 1; i &lt;= n; ++i) read(a[i]), srt[i] = a[i]; for (rg int i = 1; i &lt;= n; ++i) bln[i] = (i - 1) / sqn + 1; for (rg int i = 1; i &lt;= bln[n]; ++i) fst[i] = sqn * (i - 1) + 1; fst[bln[n] + 1] = n + 1; for (rg int i = 1; i &lt;= n; i++) ++cnt[bln[i]][a[i]]; for (rg int i = 1; i &lt;= bln[n]; i++) for (int j = 1; j &lt;= n; j++) cnt[i][j] += cnt[i - 1][j] + cnt[i][j - 1] - cnt[i - 1][j - 1]; for (rg int i = 1; i &lt;= bln[n]; i++) for (int j = 1; j &lt;= n; j++) pre[i][j] = pre[i][j - 1] + cnt[i][a[j] - 1]; for (rg int r = 1; r &lt;= bln[n]; r++) for (int l = 1; l &lt;= r; l++) &#123; for (rg int j = fst[r]; j &lt; fst[r + 1]; j++) sum[l][r] += fst[r] - fst[l] - cnt[r - 1][a[j] - 1] + cnt[l - 1][a[j] - 1]; sum[l][r] += sum[l][r - 1]; &#125; for (rg int i = 1; i &lt;= bln[n]; ++i) &#123; siz = fst[i + 1] - fst[i], std::sort(srt + fst[i], srt + fst[i + 1]); for (rg int j = fst[i]; j &lt; fst[i + 1]; j++) rnk[j] = std::lower_bound(srt + fst[i], srt + fst[i + 1], a[j]) - srt - fst[i] + 1; memset(s, 0, sizeof(s)); for (rg int j = fst[i]; j &lt; fst[i + 1]; j++) lft[j] = (j == fst[i] ? 0 : lft[j - 1]) + j - fst[i] - query(rnk[j]), modify(rnk[j]); memset(s, 0, sizeof(s)); for (rg int j = fst[i + 1] - 1; j &gt;= fst[i]; j--) rit[j] = (j == fst[i + 1] - 1 ? 0 : rit[j + 1]) + query(rnk[j]), modify(rnk[j]); fur[i] = fur[i - 1] + rit[fst[i]]; &#125; for (rg int i = 1, bl, br; i &lt;= m; ++i) &#123; read(l), read(r); l ^= ans, r ^= ans; if (l &gt; r) std::swap(l, r); if (bln[l] == bln[r]) &#123; ans = lft[r] - (l == fst[bln[l]] ? 0 : lft[l - 1]); ans -= merge(fst[bln[l]], l - 1, l, r); &#125; else &#123; bl = bln[l] + 1, br = bln[r] - 1; ans = rit[l] + lft[r] + sum[bl][br] - sum[bl][bl - 1] + fur[br] - fur[bl - 1]; ans += get(bl, br, l, fst[bl] - 1); ans -= get(bl, br, fst[br + 1], r); ans += (r - fst[br + 1] + 1) * (fst[br + 1] - fst[bl]); ans += merge(l, fst[bl] - 1, fst[br + 1], r); &#125; print(ans), putc('\\n'); &#125; std::cerr &lt;&lt; clock() / (double)CLOCKS_PER_SEC &lt;&lt; std::endl;&#125;&#125; int main() &#123; return ringo::main(), 0; &#125; （最近比较喜欢压行） 感谢您的阅读。","categories":[{"name":"Solution","slug":"Solution","permalink":"https://memset0.cn/categories/Solution/"}],"tags":[{"name":"树状数组","slug":"树状数组","permalink":"https://memset0.cn/tags/树状数组/"},{"name":"分块","slug":"分块","permalink":"https://memset0.cn/tags/分块/"}]},{"title":"退役后的做题计划（一）","slug":"plan/plan1","date":"2018-11-12T12:00:02.000Z","updated":"2018-11-16T12:56:07.231Z","comments":true,"path":"plan/plan1/","link":"","permalink":"https://memset0.cn/plan/plan1/","excerpt":"本计划根据 Menci 博客 题解时间顺序排列。CodeVS 和 COGS 的部分题出于某些原因不打算做（主要是没有账号）。部分未完成且正准备做的题目可能会给出链接（优先级：洛谷 &gt; BZOJ &gt; LOJ &gt; UOJ）。","text":"本计划根据 Menci 博客 题解时间顺序排列。CodeVS 和 COGS 的部分题出于某些原因不打算做（主要是没有账号）。部分未完成且正准备做的题目可能会给出链接（优先级：洛谷 &gt; BZOJ &gt; LOJ &gt; UOJ）。 完成情况 题目名称 √ 「NOI2002」银河英雄传说 - 并查集 - 「CodeVS 3269」混合背包 - 背包 DP √ 「HNOI2004」宠物收养所 - set - 「CodeVS 3168 / 31」抄书问题 - 划分 DP / 二分答案 √ 「CTSC1997」选课 - 树形 DP - 「NOIP2000」乘积最大 - 划分 DP - 「CodeVS 2598」编辑距离问题 - 线性 DP - 「Tyvj 3317」火车票 - 划分 DP √ 「NOIP2006」能量项链 - 区间 DP √ 「NOIP2003」数字游戏 - 划分 DP - 「CodeVS 1345」饥饿的奶牛 - 线性 DP - 「CodeVS 3269」混合背包 - 背包 DP + 单调队列 √ 「BZOJ 2442」修剪草坪 - 线性 DP + 单调队列 √ 「NOIP2006」金明的预算方案 - 背包 DP + 树形 DP √ 「BZOJ 1251」序列终结者 - Splay √ 「NOIP2012」同余方程 - 扩展欧几里得 √ 「NOI2015」程序自动分析 - 离散化 + 并查集 √ 「NOI2015」软件包管理器 - 树链剖分 √ 「BZOJ 1477」青蛙的约会 - 扩展欧几里得 √ 「NOI2004」郁闷的出纳员 - Splay √ 「BZOJ 1756」小白逛公园 - 线段树 - 「CodeVS 1563」奶牛的交通 - 网络流 √ 「BZOJ 2683」简单题 - CDQ √ 「COGS 14」搭配飞行员 - 二分图匹配 √ 「COGS 728」最小路径覆盖问题 - 二分图匹配 √ 「COGS 396」魔术球问题 - 贪心 √ 「COGS 729」圆桌聚餐 - 网络流 - 「COGS 731」最长递增子序列 - 线性 DP + 网络流 √ 「COGS 727」太空飞行计划 - 最大权闭合图 √ 「COGS 439」软件补丁 - 记忆化搜索 + 位运算 √ 「COGS 734」方格取数 - 二分图最大独立集 √ 「COGS 738」数字梯形 - 费用流 √ 「COGS 746」骑士共存 - 二分图最大独立集 √ 「NOIP2010」关押罪犯 - 二分图染色 √ 「JSOI2008」最大数 - Splay √ 「COGS 739」运输问题 - 费用流 √ 「COGS 742」深海机器人 - 费用流 「CTSC1999」星际转移 - 网络流 √ 「COGS 740」分配问题 - 二分图最大权匹配 √ 「COGS 741」负载平衡 - 费用流 √ 「SDOI2015」星际战争 - 网络流 √ 「SDOI2010」星际竞速 - 费用流 - 「CodeVS 2822」爱在心中 - 强连通分量 √ 「HAOI2006」受欢迎的牛 - 强连通分量 √ 「SCOI2011」糖果 - 强连通分量 + 拓扑排序 「NOI2003」文本编辑器 - Splay 「SCOI2010」游戏 - 二分图匹配 √ 「AHOI2008」紧急集合 - 最近公共祖先 √ 「SCOI2007」修车 - 费用流 「NOI2006」最大获利 - 最大权闭合图 √ 「APIO2009」抢掠计划 - 强连通分量 - 「POJ 2728」Desert King - 01 分数规划 - 「UVa 11806」Cheerleaders - 组合数 + 容斥原理 - 「UVa 11538」Chess Queen - 计数原理 - 「UVa 11375」Matches - 递推 - 「UVa 11137」Ingenuous Cubrency - 递推 / 背包 DP - 「UVa 11174」Stand in a Line - 计数原理 + 乘法逆元 - 「POJ 1737」Connected Graph - 组合数 + 计数原理 + 递推 - 「UVa 1362」Exploring Pyramids - 区间 DP + 计数原理 - 「UVa 11361」Investigating Div-Sum Property - 数位 DP - 「UVa 10253」Series-Parallel Networks - 整数划分 + 组合数 √ 「SDOI2008」洞穴勘测 - Link-Cut Tree 「省选模拟赛」小奇的集合 - 矩阵乘法 「省选模拟赛」小奇的糖果 - 扫描线 + 链表 「省选模拟赛」染色 - 树链剖分 「SCOI2015」小凸玩矩阵 - 二分图匹配 「SCOI2015」情报传递 - 离线 + Link-Cut Tree 「SCOI2015」国旗计划 - 贪心 + 倍增 「BZOJ 2143」飞飞侠 - 最短路 「SCOI2015」小凸玩密室 - 树形 DP 「SCOI2015」小凸解密码 - set 「省选模拟赛」扔鸡蛋 - DP √ 「BZOJ 2038」小Z的袜子 - 莫队 「BZOJ 2296」随机种子 - 数论基础 √ 「HAOI2015」树上操作 - 树链剖分 + DFS序 截止到第 27 页","categories":[{"name":"Plan","slug":"Plan","permalink":"https://memset0.cn/categories/Plan/"}],"tags":[]},{"title":"BZOJ5017 - [SNOI2017] 炸弹","slug":"solution/bzoj/5017","date":"2018-11-12T11:33:40.000Z","updated":"2018-12-09T02:56:30.559Z","comments":true,"path":"solution/bzoj/5017/","link":"","permalink":"https://memset0.cn/solution/bzoj/5017/","excerpt":"zhouyuheng2003 学长一天打完 CF 后给我做的一道他说是简单题的题，然而炒鸡难！！！ 考虑暴力，每个炸弹向能引爆炸弹的连边，总数是 $n^2$ 级别的。之后跑 tarjan 缩点，并在 DAG 上统计答案。统计是，考虑合并来的点所对应的情况可能会有重点，因此需要开桶去重。这样的时空复杂度都是 $O(n^2)$ 的。 考虑优化，通过观察可以发现，能引爆的炸弹一定是连续的一整段区间。可以用线段树优化建边，统计答案时不需要开桶统计，而是统计能够炸掉的最左端的点和最右端的点。时间复杂度 $O(n \\log n)$ ，空间复杂度 $O(n \\log n)$。 同时 当然这并不是最优的，zhouyuheng2003 学长的博客中给出了一种时空复杂度均为 $O(n)$ 的做法。见 https://blog.csdn.net/zhouyuheng2003/article/details/83278984 。","text":"zhouyuheng2003 学长一天打完 CF 后给我做的一道他说是简单题的题，然而炒鸡难！！！ 考虑暴力，每个炸弹向能引爆炸弹的连边，总数是 $n^2$ 级别的。之后跑 tarjan 缩点，并在 DAG 上统计答案。统计是，考虑合并来的点所对应的情况可能会有重点，因此需要开桶去重。这样的时空复杂度都是 $O(n^2)$ 的。 考虑优化，通过观察可以发现，能引爆的炸弹一定是连续的一整段区间。可以用线段树优化建边，统计答案时不需要开桶统计，而是统计能够炸掉的最左端的点和最右端的点。时间复杂度 $O(n \\log n)$ ，空间复杂度 $O(n \\log n)$。 同时 当然这并不是最优的，zhouyuheng2003 学长的博客中给出了一种时空复杂度均为 $O(n)$ 的做法。见 https://blog.csdn.net/zhouyuheng2003/article/details/83278984 。 代码莫名 RE 调了好久，因此码风有点丑不要介意。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long long#define rep(i,l,r) for (int i = l; i &lt;= r; i++)#define getc(x) getchar(x)#define putc(x) putchar(x)template &lt;typename T&gt; inline void read(T &amp;x) &#123; x = 0; register char ch; register bool fl = 0; while (ch = getc(), ch &lt; 48 || 57 &lt; ch) fl ^= ch == '-'; x = (ch &amp; 15); while (ch = getc(), 47 &lt; ch &amp;&amp; ch &lt; 58) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch &amp; 15); if (fl) x = -x;&#125;template &lt;typename T&gt; inline void readc(T &amp;x) &#123; while (x = getc(), !islower(x) &amp;&amp; !isupper(x));&#125;template &lt;typename T&gt; inline void print(T x, char c = ' ') &#123; static int buf[40]; if (x == 0) &#123; putc('0'); putc(c); return; &#125; if (x &lt; 0) putc('-'), x = -x; for (buf[0] = 0; x; x /= 10) buf[++buf[0]] = x % 10 + 48; while (buf[0]) putc((char) buf[buf[0]--]); putc(c);&#125;#define int long longconst int maxn = 500010;int n, m, u, v, w, x, l, r, tn, ans, cnt, pos;ll b[maxn * 3]; int q[maxn];int col[maxn], ind[maxn], ls[maxn], rs[maxn];int top, dfn[maxn], low[maxn], stk[maxn], ins[maxn];int tot = 2, hed[maxn], nxt[maxn &lt;&lt; 1], to[maxn &lt;&lt; 1];struct node &#123; ll x, l, r;&#125; a[maxn];inline bool operator &lt; (const node &amp;a, const node &amp;b) &#123; return a.x &lt; b.x;&#125;struct edge &#123; int u, v;&#125;;std::vector &lt; edge &gt; e;void add_edge1(int u, int v) &#123; nxt[tot] = hed[u], to[tot] = v, hed[u] = tot++; e.push_back(edge&#123;u, v&#125;);&#125;void add_edge2(int u, int v) &#123; nxt[tot] = hed[u], to[tot] = v, hed[u] = tot++; ind[v]++;&#125;void tarjan(int u) &#123; dfn[u] = low[u] = ++pos; stk[++top] = u, ins[u] = 1; for (int i = hed[u], v = to[i]; i; i = nxt[i], v = to[i]) &#123; if (!dfn[v]) &#123; tarjan(v); low[u] = std::min(low[u], low[v]); &#125; else if (ins[v]) &#123; low[u] = std::min(low[u], dfn[v]); &#125; &#125; if (dfn[u] == low[u]) &#123; ++cnt; ls[cnt] = n + 1; while (top) &#123; int v = stk[top--]; col[v] = cnt; ins[v] = 0; ls[cnt] = std::min(ls[cnt], (int)a[v].l); rs[cnt] = std::max(rs[cnt], (int)a[v].r); if (u == v) break; &#125; &#125;&#125;signed main() &#123; read(n); for (int i = 1; i &lt;= n; i++) &#123; read(x), read(r); a[i].x = x, a[i].r = r; b[++tn] = x; &#125; std::sort(a + 1, a + n + 1); std::sort(b + 1, b + tn + 1); tn = std::unique(b + 1, b + tn + 1) - b - 1; for (int i = 1; i &lt;= n; i++) &#123; a[i].l = std::lower_bound(b + 1, b + tn + 1, a[i].x - a[i].r) - b; a[i].r = std::upper_bound(b + 1, b + tn + 1, a[i].x + a[i].r) - b - 1; a[i].x = std::lower_bound(b + 1, b + tn + 1, a[i].x) - b; &#125; for (int i = 1; i &lt;= n; i++) &#123; while (top &amp;&amp; a[stk[top]].r &lt; a[i].x) top--; if (top &amp;&amp; a[stk[top]].r &gt;= a[i].x) add_edge1(stk[top], i); while (top &amp;&amp; a[stk[top]].r &lt;= a[i].r) top--; stk[++top] = i; &#125; top = 0; for (int i = n; i &gt;= 1; i--) &#123; while (top &amp;&amp; a[stk[top]].l &gt; a[i].x) top--; if (top &amp;&amp; a[stk[top]].l &lt;= a[i].x) add_edge1(stk[top], i); while (top &amp;&amp; a[stk[top]].l &gt;= a[i].l) top--; stk[++top] = i; &#125; for (int i = 1; i &lt;= n; i++) if (!dfn[i]) tarjan(i); tot = 2, memset(hed, 0, sizeof(hed)); for (std::vector &lt; edge &gt; ::iterator it = e.begin(); it != e.end(); it++) &#123; u = it-&gt;v, v = it-&gt;u, u = col[u], v = col[v]; if (u ^ v) &#123; add_edge2(u, v); &#125; &#125; l = 1, r = 0; for (int i = 1; i &lt;= n; i++) if (!ind[i]) &#123; q[++r] = i; &#125; while (l &lt;= r) &#123; u = q[l++]; for (int i = hed[u], v = to[i]; i; i = nxt[i], v = to[i]) &#123; ls[v] = std::min(ls[u], ls[v]); rs[v] = std::max(rs[u], rs[v]); if (!--ind[v]) q[++r] = v; &#125; &#125; for (int i = 1; i &lt;= n; i++) ans = (ans + 1ll * i * (rs[col[i]] - ls[col[i]] + 1)) % 1000000007; print(ans, '\\n'); return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"https://memset0.cn/categories/Solution/"}],"tags":[{"name":"tarjan","slug":"tarjan","permalink":"https://memset0.cn/tags/tarjan/"},{"name":"缩点","slug":"缩点","permalink":"https://memset0.cn/tags/缩点/"},{"name":"线段树优化建边","slug":"线段树优化建边","permalink":"https://memset0.cn/tags/线段树优化建边/"}]},{"title":"NOIP2018 爆零记","slug":"diary/NOIP2018游记","date":"2018-11-10T12:51:19.000Z","updated":"2018-12-02T04:02:06.852Z","comments":true,"path":"diary/NOIP2018游记/","link":"","permalink":"https://memset0.cn/diary/NOIP2018游记/","excerpt":"","text":"Day -1 注意这是 -1 天 上午照常模拟赛，考 NOIP 信心赛。 虽然是信心赛，但是题目好难。T1 洛谷原题，黑题难度 QAQ 。后两题稍微简单一点，但是如果开始刚了 T1 估计就来不及了。 我先开了 T2 ，推出了容斥，期望 $O(t \\log n)$ 的 70 分。然后去开 T3 ，写了个 $O(n \\times m \\log n)$ 加卡常，期望 80 。最后开 T1 ，一遍写对了一个动态开点线段树，特判特殊情况拿到 50 分部分分。 考试成绩出来，诶 T3 怎么 A 了 QAQ 。T2 没有输出 STO yyb ORZ （无解情况）少了 15 分， T1 还是预测得分 50 分。算是涨了不少信心吧。 下午继续写板子，任务列表也清的差不多了。还有一些很难的算法感觉也不会用到懒得写了。 晚上老师讲竞赛时间安排和一些注意事项，同是说明天是 “ Open Day ” ，我们可以光明正大的地颓废放松 233 . 讲完之后感觉压力突然加大，本来以为很遥远的 NOIP 真的近在眼前了。真的，真的，好紧张。找学长哭诉。 lyc 哥哥特别好，特别温暖，给了我许多安慰 qwq。 Day 0上午开始机房集体颓废，打 jokebird.com 爆踩全服。之后开始打球球大作战。也有人 5 人组队 LOL （第一局被对面五杀，第二局吊打对面 233） 下午继续颓废，看了点数论。 在赛百味吃完饭的时候遇见了 zx2003 学长，他给我们讲了一些他的故事，也给了我很大的鼓励。 晚上颓了一会会儿，然后手推 EXGCD 和 EXCRT ，虽说感觉不会考，主要还是熟悉一下推式子的感觉 QAQ 。 接着去楼上机房蹭 RP ，好紧张，又哭了 QAQ 。但是学长的安慰真的很有用（不然可能窝晚上心态就蹦了）。 睡觉的时候还是有点紧张，半夜睡不着。 Day 1但是早上起来精神状态还是很好的。一路赶去学军紫金港路也很顺畅。 早点到校门口集合领准考证，我们有同学的准考证在校园里还没领但是要有准考证才能进场 233 。还好老师送出来了。我们初中几个还拍了合影。 进考场前最后膜拜了一次大佬。坐我左边的是一个超好的（不认识的）高三学长。当时我特别紧张，他安慰了我也给了我鼓励，也让我平静了一下心态。 开题，解压密码 Fei2Xue@Lian$Tian! 。学军体育馆可真冷。 T1 上手一个 $O(n ^ 2)$ 贪心过了大样例，然后用 ST 表优化成 $O(n \\log n)$ 开始拍。 T2 一开始以为是 exgcd ，但又感觉不可能那么难。看了眼 T3 没思路，滚回来手玩了一下样例想到了个背包。一发过了大样例感觉很稳。 T3 先写了部分分，和状压暴力对拍。差不多写满 55 分部分分，正解的思路也有了。此时我可以写二叉树的部分分到 80 ，也可以直接写正解。经过了一番焦灼，还是写了部分分，毕竟写正解也有可能调不出来。 考完和同学 yy T3 ，发现了一个思维漏洞，不过很容易拍出来，而且我也立马想到了补救措施。不过如果这是考场就不一定了。所以感觉当初自己稳一点写了部分分也是挺正确的。 估分 $280 = 100 + 100 + 80$ ，考完听说 Sooke 、mocania 、 LJC00118 、 Isonan 都 AK 了。唉，毕竟技不如人，甘拜下风。 下午继续颓废，帮学长安 Flash Player 但是失败了，同时跟同学继续嘴巴 T3 。 晚上颓废 + 写游记，也不是很紧张了。 明天加油：尽人事，听天命。 Day 2无论如何预感今天的题目会很难。跟同学开玩笑说今天写满暴力就好了，结果还真 tmd 暴力滚粗了。 解压密码和昨天连起来：“飞雪连天射白鹿，笑书神侠倚碧鸳。” CCF 的解压密码倒是一年比一年有创意了233。就是能不能不要出原题QAQ。 开 T1 ，一开始以为是一张图，没想到是一个树和基环树。等等，这一题当两题的画风，让我想到了栗栗的书架啊。先随手写了个树的情况，过了大样例，开始看 T2 。 T2 一眼以为是状压，一脸懵逼。还成功出现了“关于 T2 的题目解释请看 T1 的情况”（那放洛谷上怎么办 233）。本想枚举个数然后直接判断，结果第二个样例输出 144 瞬间懵逼。写了发状压枚举路径判断过了两个小样例。开始跑 $5 \\times 5$ 的但始终过不去（为什么别人的状压可以跑 $7 \\times 7$ QAQ）。发现了每次 $\\times 3$ 的规律。 没办法，开 T3 ，44 分的 $O(n m)$ 暴力很好写，一遍过了大样例。开始想正解却没思路。目前已经有 $60 + 50 + 44 = 154$ 分了，还有两个小时多，先上个厕所冷静一下。 回来想继续优化 T2 ，但脑子里一直把枚举矩阵的 $O(2^{nm})$ 复杂度搞成了 $O(2^{n+m})$ 。结果当然是就算苦苦优化还是过不去大样例，白白浪费了半个小时。 接下去去看 T1 $n = m$ 的情况，由于 $m = n - 1$ 的情况可以 $O(n)$ 完成，我把 $n = 5000$ 的数据范围当成了 $n = 100000$ 最后强行想出来了一个 $O(n)$ 解法但已经又过了半个小时。还有一个小时感觉写不完这个及其麻烦的做法，赶紧苟了个成环的部分分。 只能看 T3 部分分。一条链上的情况考场里一脸懵逼毫无思路，考完出来却豁然开朗（mmp）。其实把 dp 的转移变成一个个矩阵放到线段树上区间查询即可。然而考场上我脑子里一片空白，什么也想不到。 回去检查 T2 ， T2 的大样例好毒啊，不仅给的数据范围小，而且都是 $n = m$ 的，感觉有坑。检查了老半天暴力还有不到半个小时。发现 $n = 1$ 的情况不是每次乘以 $3$ 而是 $2$ 。赶快改过来（差点就没分了），捡回一条狗命。 最后时间照常检查文件，交卷。考完出来要了隔壁同学的 QQ 号，也算是一种缘分吧。 Sooke ， Isonan 照样稳的一比 ， $200+$ 。感觉考场 debuff 太严重了，真的脑子里一片空白。平时模拟赛可以拖一段时间交卷，大胆地去尝试正解，然而考试的时候不仅没拖延的可能，还要单独花时间检查文件等等，一下就丧失了去尝试正解的勇气。 最后期望得分 $189 = 80 + 65 + 44$ Day 3出选手代码了，去洛谷上交了一发竟然 $ 474 = 100 + 100 + 80 + 80 + 70 + 44 $ ，激动的要死。 当然也有同学 D2T1 的 $O(n log n)$ 做法挂了，但还是比我高。 Day ?CCF 官方成绩出了，只有 $ 454 = 100 + 100 + 65 + 80 + 65 + 44 $ ，原来 D1T3 的分支不超过三按照我的那种方法有可能在根节点三叉。 看来 WC 无望了，只能希望可以上 PKUWC 的初中线吧。","categories":[{"name":"Diary","slug":"Diary","permalink":"https://memset0.cn/categories/Diary/"}],"tags":[]},{"title":"Mac 下 Sublime Text 3 配置运行 G++","slug":"geek/sublime-run-g++-with-mac","date":"2018-11-07T08:19:00.000Z","updated":"2018-11-07T08:25:48.036Z","comments":true,"path":"geek/sublime-run-g++-with-mac/","link":"","permalink":"https://memset0.cn/geek/sublime-run-g++-with-mac/","excerpt":"","text":"配置编译系统新建编译系统并粘贴入以下命令，保存为 G++.sublime-build 或其他你喜欢的名称。 123456789101112131415161718192021&#123; &quot;shell_cmd&quot;: &quot;g++ \\&quot;$&#123;file&#125;\\&quot; -o \\&quot;$&#123;file_path&#125;/$&#123;file_base_name&#125;\\&quot; -Wall&quot;, &quot;file_regex&quot;: &quot;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$&quot;, &quot;working_dir&quot;: &quot;$&#123;file_path&#125;&quot;, &quot;selector&quot;: &quot;source.c, source.c++&quot;, &quot;variants&quot;: [ &#123; &quot;name&quot;: &quot;compile&quot;, &quot;shell_cmd&quot;: &quot;g++ \\&quot;$&#123;file&#125;\\&quot; -o \\&quot;/tmp/$&#123;file_base_name&#125;\\&quot; -Wall -O2 &amp;&amp; echo &apos;Compile finished.&apos;&quot; &#125;, &#123; &quot;name&quot;: &quot;run&quot;, &quot;shell_cmd&quot;: &quot;&apos;/tmp/$&#123;file_base_name&#125;&apos; &amp;&amp; echo &apos;=============\\nRun finished.&apos;&quot; &#125;, &#123; &quot;name&quot;: &quot;compile &amp; run&quot;, &quot;shell_cmd&quot;: &quot;g++ \\&quot;$&#123;file&#125;\\&quot; -o \\&quot;/tmp/$&#123;file_base_name&#125;\\&quot; -Wall -O2 &amp;&amp; /tmp/$&#123;file_base_name&#125; &amp;&amp; echo &apos;=============\\nComplie &amp; run finished.&apos;&quot; &#125; ]&#125; 配置编译运行快捷键把以下代码粘贴到你的快捷键配置文件中，表示 F9 编译， F10 运行， F11 编译并运行。 123456789101112131415161718&#123; &quot;keys&quot;: [&quot;f9&quot;], &quot;command&quot;: &quot;build&quot;, &quot;args&quot;: &#123; &quot;variant&quot;: &quot;compile&quot; &#125;&#125;, &#123; &quot;keys&quot;: [&quot;f10&quot;], &quot;command&quot;: &quot;build&quot;, &quot;args&quot;: &#123; &quot;variant&quot;: &quot;run&quot; &#125;&#125;, &#123; &quot;keys&quot;: [&quot;f11&quot;], &quot;command&quot;: &quot;build&quot;, &quot;args&quot;: &#123; &quot;variant&quot;: &quot;compile &amp; run&quot; &#125;&#125; 其他注意事项Mac OS 下默认用 Clang 编译 G++ 代码。因此不支持使用万能头文件（bits/stdc++.h），解决方案： 手动复制 bits/stdc++.h 文件到对应目录中 手动安装 g++4.9 并把上面编译命令中的 g++ 替换为 g++-4.9","categories":[{"name":"Geek","slug":"Geek","permalink":"https://memset0.cn/categories/Geek/"}],"tags":[]},{"title":"洛谷4949 - 最短距离","slug":"solution/luogu/4949","date":"2018-10-26T08:00:00.000Z","updated":"2018-12-09T02:19:14.806Z","comments":true,"path":"solution/luogu/4949/","link":"","permalink":"https://memset0.cn/solution/luogu/4949/","excerpt":"本题大概是一个基环树上带修改边权的最短距离。可以把他看做一棵树，把多的那条边拎出来，树剖维护距离，分类讨论即可。大概是你谷蓝题难度吧。 由于树剖只需要查询 dfs 序上区间最小值，可以考虑树状数组维护常熟较小。目前不卡常的情况下你谷效率 rk1 。","text":"本题大概是一个基环树上带修改边权的最短距离。可以把他看做一棵树，把多的那条边拎出来，树剖维护距离，分类讨论即可。大概是你谷蓝题难度吧。 由于树剖只需要查询 dfs 序上区间最小值，可以考虑树状数组维护常熟较小。目前不卡常的情况下你谷效率 rk1 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long long#define rep(i,l,r) for (int i = l; i &lt;= r; i++)#define getc(x) getchar(x)#define putc(x) putchar(x)template &lt;typename T&gt; inline void read(T &amp;x) &#123; x = 0; register char ch; register bool fl = 0; while (ch = getc(), ch &lt; 48 || 57 &lt; ch) fl ^= ch == '-'; x = (ch &amp; 15); while (ch = getc(), 47 &lt; ch &amp;&amp; ch &lt; 58) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch &amp; 15); if (fl) x = -x;&#125;template &lt;typename T&gt; inline void readc(T &amp;x) &#123; while (x = getc(), !islower(x) &amp;&amp; !isupper(x));&#125;template &lt;typename T&gt; inline void print(T x, char c = ' ') &#123; static int buf[40]; if (x == 0) &#123; putc('0'); putc(c); return; &#125; if (x &lt; 0) putc('-'), x = -x; for (buf[0] = 0; x; x /= 10) buf[++buf[0]] = x % 10 + 48; while (buf[0]) putc((char) buf[buf[0]--]); putc(c);&#125;const int maxn = 100010;int n, m, x, y, u, v, w, tu, tv, tw, opt, ans, pos;int a[maxn], s[maxn], cst[maxn], tmp[maxn];int fa[maxn], id[maxn], top[maxn], son[maxn], wid[maxn], dep[maxn], siz[maxn];bool vis[maxn];int tot = 2, hed[maxn], to[maxn &lt;&lt; 1], val[maxn &lt;&lt; 1], nxt[maxn &lt;&lt; 1];struct edge &#123; int u, v, w;&#125; e[maxn];void dfs1(int u) &#123; vis[u] = siz[u] = 1; for (int i = hed[u], v = to[i]; i; i = nxt[i], v = to[i]) if (!vis[v]) &#123; fa[v] = u, dep[v] = dep[u] + 1, cst[v] = val[i]; dfs1(v); siz[u] += siz[v]; if (siz[v] &gt; siz[son[u]]) son[u] = v; &#125; else if (v != fa[u]) &#123; tu = u, tv = v, tw = val[i]; &#125;&#125;void dfs2(int u, int toppoint) &#123; top[u] = toppoint, id[u] = ++pos, wid[id[u]] = u; if (siz[u] == 1) return; dfs2(son[u], toppoint); for (int i = hed[u], v = to[i]; i; i = nxt[i], v = to[i]) if (v != fa[u] &amp;&amp; v != son[u] &amp;&amp; !(u == tu &amp;&amp; v == tv) &amp;&amp; !(u == tv &amp;&amp; v == tu)) dfs2(v, v);&#125;int lca(int u, int v) &#123; while (top[u] != top[v]) &#123; if (dep[top[u]] &gt; dep[top[v]]) std::swap(u, v); v = fa[top[v]]; &#125; if (dep[u] &gt; dep[v]) std::swap(u, v); return u;&#125;void modify(int k, int w) &#123; for (int i = k; i &lt;= n; i += i &amp; -i) s[i] += w - tmp[k]; tmp[k] = w;&#125;int query(int l, int r) &#123; int ret = 0; for (int i = r; i; i -= i &amp; -i) ret += s[i]; for (int i = l - 1; i; i -= i &amp; -i) ret -= s[i]; return ret;&#125;int query_path_to_root(int u, int v) &#123; int ret = 0; while (top[u] != top[v]) &#123; ret += query(id[top[u]], id[u]); u = fa[top[u]]; &#125; if (u != v) ret += query(id[son[v]], id[u]); return ret;&#125;int query_path(int u, int v) &#123; int ret = 0, t = lca(u, v); ret += query_path_to_root(u, t); ret += query_path_to_root(v, t); return ret;&#125;int main() &#123; read(n), read(m); for (int i = 1; i &lt;= n; i++) &#123; read(u), read(v), read(w); e[i] = edge&#123;u, v, w&#125;; nxt[tot] = hed[u], to[tot] = v, val[tot] = w, hed[u] = tot++; nxt[tot] = hed[v], to[tot] = u, val[tot] = w, hed[v] = tot++; &#125; dfs1(1), dfs2(1, 1); for (int i = 1; i &lt;= n; i++) for (int j = id[i]; j &lt;= n; j += j &amp; -j) s[j] += cst[i]; for (int i = 1; i &lt;= n; i++) tmp[id[i]] = cst[i]; for (int i = 1; i &lt;= m; i++) &#123; read(opt), read(x), read(y); if (opt == 1) &#123; u = e[x].u, v = e[x].v; if ((u == tu &amp;&amp; v == tv) || (u == tv &amp;&amp; v == tu)) &#123; tw = y; &#125; else &#123; u = dep[u] &gt; dep[v] ? u : v; modify(id[u], y); &#125; &#125; else &#123; ans = query_path(x, y); ans = std::min(ans, query_path(x, tu) + query_path(tv, y) + tw); ans = std::min(ans, query_path(y, tu) + query_path(tv, x) + tw); print(ans, '\\n'); &#125; &#125; return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"https://memset0.cn/categories/Solution/"}],"tags":[{"name":"树链剖分","slug":"树链剖分","permalink":"https://memset0.cn/tags/树链剖分/"},{"name":"基环树","slug":"基环树","permalink":"https://memset0.cn/tags/基环树/"}]},{"title":"洛谷3620 - [APIO/CTSC 2007] 数据备份","slug":"solution/luogu/3620","date":"2018-10-17T12:52:00.000Z","updated":"2018-12-09T02:11:07.951Z","comments":true,"path":"solution/luogu/3620/","link":"","permalink":"https://memset0.cn/solution/luogu/3620/","excerpt":"首先我们把原来的距离数组 $p$ 差分为数组 $a$。原题可以等同为在 $a$ 数组中选择 $k$ 个不相邻的数使得总和最小。 假设我们已经选择了 $a_i$ ，那么 $a_{i-1}$ 和 $a_{i+1}$ 要么同时选择，要么同时没有被选择。同时，如果我们同时选择，需要的花费即 $V_{a_{i+1}} + V_{a_{i-1}} - V_{a_i}$ 。我们维护一个堆和双向链表，每次从小根堆选择堆顶，把 $a_i$、 $a_{i-1}$ 和 $a_{i+1}$ 同时删除，再新建一个价值为 $V_{a_{i+1}} + V_{a_{i-1}} - V_{a_i}$ 的节点，扔到堆里，重复 $k$ 次就能得到答案。","text":"首先我们把原来的距离数组 $p$ 差分为数组 $a$。原题可以等同为在 $a$ 数组中选择 $k$ 个不相邻的数使得总和最小。 假设我们已经选择了 $a_i$ ，那么 $a_{i-1}$ 和 $a_{i+1}$ 要么同时选择，要么同时没有被选择。同时，如果我们同时选择，需要的花费即 $V_{a_{i+1}} + V_{a_{i-1}} - V_{a_i}$ 。我们维护一个堆和双向链表，每次从小根堆选择堆顶，把 $a_i$、 $a_{i-1}$ 和 $a_{i+1}$ 同时删除，再新建一个价值为 $V_{a_{i+1}} + V_{a_{i-1}} - V_{a_i}$ 的节点，扔到堆里，重复 $k$ 次就能得到答案。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long long#define rep(i,l,r) for (int i = l; i &lt;= r; i++)#define getc(x) getchar(x)#define putc(x) putchar(x)template &lt;typename T&gt; inline void read(T &amp;x) &#123; x = 0; register char ch; register bool fl = 0; while (ch = getc(), ch &lt; 48 || 57 &lt; ch) fl ^= ch == '-'; x = (ch &amp; 15); while (ch = getc(), 47 &lt; ch &amp;&amp; ch &lt; 58) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch &amp; 15); if (fl) x = -x;&#125;template &lt;typename T&gt; inline void readc(T &amp;x) &#123; while (x = getc(), !islower(x) &amp;&amp; !isupper(x));&#125;template &lt;typename T&gt; inline void print(T x, char c = ' ') &#123; static int buf[40]; if (x == 0) &#123; putc('0'); putc(c); return; &#125; if (x &lt; 0) putc('-'), x = -x; for (buf[0] = 0; x; x /= 10) buf[++buf[0]] = x % 10 + 48; while (buf[0]) putc((char) buf[buf[0]--]); putc(c);&#125;const int maxn = 1000010;int n, m, pos, l[maxn], r[maxn], tmp[maxn];ll ans, val[maxn];bool vis[maxn];struct node &#123; int id; ll val;&#125; u, v;bool operator &lt; (const node &amp;a, const node &amp;b) &#123; return a.val &gt; b.val;&#125;std::priority_queue &lt; node &gt; q;int main() &#123; read(n), read(m), --n; for (int i = 1; i &lt;= n + 1; i++) read(tmp[i]); for (int i = 1; i &lt;= n; i++) val[i] = tmp[i + 1] - tmp[i]; for (int i = 1; i &lt;= n; i++) l[i] = i - 1, r[i] = i + 1; pos = n + 1; for (int i = 1; i &lt;= n; i++) q.push(node&#123;i, val[i]&#125;); val[0] = val[n + 1] = 1e9; for (int i = 1; i &lt;= m; i++) &#123; while (vis[q.top().id] &amp;&amp; q.size()) q.pop(); if (!q.size()) break; u = q.top(), q.pop(); vis[u.id] = vis[l[u.id]] = vis[r[u.id]] = 1; ans += u.val, v.id = ++pos; l[v.id] = l[l[u.id]], r[v.id] = r[r[u.id]]; r[l[v.id]] = v.id, l[r[v.id]] = v.id; val[v.id] = v.val = val[l[u.id]] + val[r[u.id]] - val[u.id]; q.push(v); &#125; print(ans, '\\n'); return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"https://memset0.cn/categories/Solution/"}],"tags":[{"name":"巧妙的思路","slug":"巧妙的思路","permalink":"https://memset0.cn/tags/巧妙的思路/"},{"name":"二叉堆","slug":"二叉堆","permalink":"https://memset0.cn/tags/二叉堆/"}]},{"title":"Dev C++ 资瓷 Hi DPI 方法","slug":"geek/devc高分屏","date":"2018-10-11T04:35:39.000Z","updated":"2018-12-09T02:04:34.163Z","comments":true,"path":"geek/devc高分屏/","link":"","permalink":"https://memset0.cn/geek/devc高分屏/","excerpt":"前提条件，新版 Windows 10 （在有高分屏的机子上装 Win 10 不苛刻吧）。","text":"前提条件，新版 Windows 10 （在有高分屏的机子上装 Win 10 不苛刻吧）。 首先定位到你的 devcpp.exe 文件，一般都在默认的安装目录下，右键他点击属性。 点击 更改高 DPI 设置 点击 替代高 DPI 缩放行为 ，并选择 系统（增强）。 重启 Dev C++ 即可看到效果。 已知问题： 与 Mactype 不兼容。","categories":[{"name":"Geek","slug":"Geek","permalink":"https://memset0.cn/categories/Geek/"}],"tags":[]},{"title":"Git 生成 SSH 公钥","slug":"geek/git-add-ssh","date":"2018-10-10T12:20:32.000Z","updated":"2018-10-10T12:27:57.805Z","comments":true,"path":"geek/git-add-ssh/","link":"","permalink":"https://memset0.cn/geek/git-add-ssh/","excerpt":"由于最近经常折腾虚拟机和新电脑， git 也经常要重新安装 / 配置，因此记录一下 git 添加 SSH 公钥的方式。","text":"由于最近经常折腾虚拟机和新电脑， git 也经常要重新安装 / 配置，因此记录一下 git 添加 SSH 公钥的方式。 步骤进入目录， 1cd ~/.ssh 如果提示目录不存在那么创建一个新目录 12mkdir ~/.sshcd ~/.ssh 输入以下命令生成密钥，会有三个选项调整，直接按回车键使用默认配置即可， 1ssh-keygen （很快的）生成密钥后，输入以下命令提取公钥： 1cat ~/.ssh/id_rsa.pub 前往 Github 把公钥添加进去即可 qwq 。 参考网址https://git-scm.com/book/zh/v1/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-%E7%94%9F%E6%88%90-SSH-%E5%85%AC%E9%92%A5 p.s. MacBook Pro 真好用（逃","categories":[{"name":"Geek","slug":"Geek","permalink":"https://memset0.cn/categories/Geek/"}],"tags":[]},{"title":"CF1059D - Nature Reserve","slug":"solution/codeforces/1059d","date":"2018-10-07T04:19:20.000Z","updated":"2018-12-09T02:11:23.634Z","comments":true,"path":"solution/codeforces/1059d/","link":"","permalink":"https://memset0.cn/solution/codeforces/1059d/","excerpt":"该死的精度问题让我调了一个小时还没有调出来（事实说明我还是太菜了。） 大概意思就是说平面上给了你一些点然后你要构造一个与 x 轴相切的圆把这些圆都包裹进去。 考虑二分圆的半径，这样就知道了圆心的 y 坐标，根据点在圆内的充要条件——点到圆心的距离小于等于半径计算出圆心的 x 坐标的范围。如果存在两个范围不相交，说明无法构造出一个符合条件的圆心。 需要注意浮点数运算的精度问题，比如计算 x 坐标的范围时这么写： 1dis = r * r - (r - y) * (r - y); 就容易被卡，而： 1dis = 2 * r * y - y * y; 就不容易。","text":"该死的精度问题让我调了一个小时还没有调出来（事实说明我还是太菜了。） 大概意思就是说平面上给了你一些点然后你要构造一个与 x 轴相切的圆把这些圆都包裹进去。 考虑二分圆的半径，这样就知道了圆心的 y 坐标，根据点在圆内的充要条件——点到圆心的距离小于等于半径计算出圆心的 x 坐标的范围。如果存在两个范围不相交，说明无法构造出一个符合条件的圆心。 需要注意浮点数运算的精度问题，比如计算 x 坐标的范围时这么写： 1dis = r * r - (r - y) * (r - y); 就容易被卡，而： 1dis = 2 * r * y - y * y; 就不容易。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long long#define rep(i,l,r) for (int i = l; i &lt;= r; i++)#define getc(x) getchar(x)#define putc(x) putchar(x)template &lt;typename T&gt; inline void read(T &amp;x) &#123; x = 0; register char ch; register bool fl = 0; while (ch = getc(), ch &lt; 48 || 57 &lt; ch) fl ^= ch == '-'; x = (ch &amp; 15); while (ch = getc(), 47 &lt; ch &amp;&amp; ch &lt; 58) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch &amp; 15); if (fl) x = -x;&#125;template &lt;typename T&gt; inline void readc(T &amp;x) &#123; while (x = getc(), !islower(x) &amp;&amp; !isupper(x));&#125;template &lt;typename T&gt; inline void print(T x, char c = ' ') &#123; static int buf[40]; if (x == 0) &#123; putc('0'); putc(c); return; &#125; if (x &lt; 0) putc('-'), x = -x; for (buf[0] = 0; x; x /= 10) buf[++buf[0]] = x % 10 + 48; while (buf[0]) putc((char) buf[buf[0]--]); putc(c);&#125;const int maxn = 100010;const long double eps = 1e-7;int n, cnt = 1000;int x[maxn], y[maxn];bool flag1, flag2;long double l, r, mid, ans, tmp;long double dis, min_rx, max_lx;long double lx[maxn], rx[maxn];bool check(long double r) &#123; for (int i = 1; i &lt;= n; i++) &#123; tmp = (2 * r - y[i]) * y[i]; if (tmp &lt; 0) return false; dis = sqrt(tmp); lx[i] = x[i] - dis; rx[i] = x[i] + dis; &#125; min_rx = rx[1]; for (int i = 2; i &lt;= n; i++) min_rx = std::min(min_rx, rx[i]); max_lx = lx[1]; for (int i = 2; i &lt;= n; i++) max_lx = std::max(max_lx, lx[i]); if (max_lx &gt; min_rx) return false; return true;&#125;int main() &#123; read(n); for (int i = 1; i &lt;= n; i++) &#123; read(x[i]); read(y[i]); &#125; for (int i = 1; i &lt;= n; i++) if (y[i] &lt; 0) flag1 = 1; else if (y[i] &gt; 0) flag2 = 1; if (flag1 &amp;&amp; flag2) &#123; print(-1, '\\n'); return 0; &#125; if (flag1) &#123; for (int i = 1; i &lt;= n; i++) y[i] = -y[i]; &#125; l = 0, r = 1000000000000001; while (r - l &gt;= eps &amp;&amp; --cnt) &#123; mid = (l + r) * 0.5; if (check(mid)) &#123; ans = mid; r = mid; &#125; else &#123; l = mid; &#125; &#125; std::cout &lt;&lt; std::fixed; std::cout &lt;&lt; std::setprecision(8) &lt;&lt; ans; std::cout &lt;&lt; std::endl; return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"https://memset0.cn/categories/Solution/"}],"tags":[{"name":"二分答案","slug":"二分答案","permalink":"https://memset0.cn/tags/二分答案/"},{"name":"计算几何","slug":"计算几何","permalink":"https://memset0.cn/tags/计算几何/"},{"name":"浮点数运算","slug":"浮点数运算","permalink":"https://memset0.cn/tags/浮点数运算/"}]},{"title":"CF1059E - Split the Tree","slug":"solution/codeforces/1059e","date":"2018-10-07T03:57:20.000Z","updated":"2018-10-10T12:14:53.317Z","comments":true,"path":"solution/codeforces/1059e/","link":"","permalink":"https://memset0.cn/solution/codeforces/1059e/","excerpt":"一个永远只能在考完后调出 Codeforces 的题的菜鸡厚颜无耻得跑来写题解了。。。 本题要求把树分成的链必须是垂直路径，也就是说不能同时跨越一颗子树的两个根。也就是说每次选中的路径都是到根节点的一串。 所以我们可以通过树上倍增预处理出每个节点 $u$ 如果被选中那么最多可以向上形成长度为 $dp[u]$ 的链。接着跑一遍树上 DP 即可。 预处理时间复杂度 $O(n \\log n)$ ，树上 DP 时间复杂度 $O(n)$ 。 貌似因为 D 题比较难调试，做这题的人比较少？反正我这种菜鸡就算考场有时间写了估计也调不出来吧。","text":"一个永远只能在考完后调出 Codeforces 的题的菜鸡厚颜无耻得跑来写题解了。。。 本题要求把树分成的链必须是垂直路径，也就是说不能同时跨越一颗子树的两个根。也就是说每次选中的路径都是到根节点的一串。 所以我们可以通过树上倍增预处理出每个节点 $u$ 如果被选中那么最多可以向上形成长度为 $dp[u]$ 的链。接着跑一遍树上 DP 即可。 预处理时间复杂度 $O(n \\log n)$ ，树上 DP 时间复杂度 $O(n)$ 。 貌似因为 D 题比较难调试，做这题的人比较少？反正我这种菜鸡就算考场有时间写了估计也调不出来吧。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long long#define rep(i,l,r) for (int i = l; i &lt;= r; i++)#define getc(x) getchar(x)#define putc(x) putchar(x)template &lt;typename T&gt; inline void read(T &amp;x) &#123; x = 0; register char ch; register bool fl = 0; while (ch = getc(), ch &lt; 48 || 57 &lt; ch) fl ^= ch == '-'; x = (ch &amp; 15); while (ch = getc(), 47 &lt; ch &amp;&amp; ch &lt; 58) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch &amp; 15); if (fl) x = -x;&#125;template &lt;typename T&gt; inline void readc(T &amp;x) &#123; while (x = getc(), !islower(x) &amp;&amp; !isupper(x));&#125;template &lt;typename T&gt; inline void print(T x, char c = ' ') &#123; static int buf[40]; if (x == 0) &#123; putc('0'); putc(c); return; &#125; if (x &lt; 0) putc('-'), x = -x; for (buf[0] = 0; x; x /= 10) buf[++buf[0]] = x % 10 + 48; while (buf[0]) putc((char) buf[buf[0]--]); putc(c);&#125;const int maxn = 100010;int n, m, x, ans;int c[maxn], f[maxn][20], cnt[maxn], dp[maxn];ll s, a[maxn], g[maxn][20], sum[maxn];int tot = 2, hed[maxn], to[maxn &lt;&lt; 1], nxt[maxn &lt;&lt; 1];inline void add_edge(int u, int v) &#123; nxt[tot] = hed[u], to[tot] = v, hed[u] = tot++; nxt[tot] = hed[v], to[tot] = u, hed[v] = tot++; &#125;void dfs1(int u) &#123; for (int i = hed[u], v = to[i]; i; i = nxt[i], v = to[i]) if (v ^ f[u][0]) &#123; f[v][0] = u; g[v][0] = a[u]; dfs1(v); &#125;&#125;int dfs2(int u) &#123; int max = 0; for (int i = hed[u], v = to[i]; i; i = nxt[i], v = to[i]) if (v ^ f[u][0]) &#123; max = std::max(max, dfs2(v)); &#125; if (!max) &#123; ans++; max = dp[u]; &#125; return max - 1;&#125;int main() &#123; read(n), read(m), read(s); for (int i = 1; i &lt;= n; i++) &#123; read(a[i]); if (a[i] &gt; s) &#123; puts(\"-1\"); return 0; &#125; &#125; for (int i = 2; i &lt;= n; i++) &#123; read(x); add_edge(x, i); &#125; dfs1(1); for (int i = 1; i &lt; 20; i++) for (int j = 1; j &lt;= n; j++) &#123; f[j][i] = f[f[j][i - 1]][i - 1]; g[j][i] = g[f[j][i - 1]][i - 1] + g[j][i - 1]; &#125; for (int k = 1, u = k; k &lt;= n; k++, u = k) &#123; int stp = 1, sum = a[u]; for (int i = 19; i &gt;= 0; i--) if ((stp + (1 &lt;&lt; i)) &lt;= m &amp;&amp; (sum + g[u][i]) &lt;= s &amp;&amp; f[u][i]) &#123; stp += 1 &lt;&lt; i; sum += g[u][i]; u = f[u][i]; &#125; dp[k] = stp; &#125; dfs2(1); print(ans, '\\n'); return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"https://memset0.cn/categories/Solution/"}],"tags":[{"name":"树上倍增","slug":"树上倍增","permalink":"https://memset0.cn/tags/树上倍增/"},{"name":"树形 DP","slug":"树形-DP","permalink":"https://memset0.cn/tags/树形-DP/"},{"name":"贪心","slug":"贪心","permalink":"https://memset0.cn/tags/贪心/"}]},{"title":"BZOJ3551 - [ONTAK2010]Peaks加强版","slug":"solution/bzoj/3551","date":"2018-09-28T11:53:00.000Z","updated":"2018-12-09T02:04:54.759Z","comments":true,"path":"solution/bzoj/3551/","link":"","permalink":"https://memset0.cn/solution/bzoj/3551/","excerpt":"这题洛谷的数据太…水，克鲁斯卡尔重构树不连通都可水过。 3545: [ONTAK2010]Peaks 3551: [ONTAK2010]Peaks加强版 在线算法：克鲁斯卡尔重构树套主席树。 在克鲁斯卡尔重构树上维护 DFS 序（或树链剖分）再套上主席树，维护第 $k$ 大。 当然非加强版由于你是重构树（被针对了）可能要大力卡常。比如加个 fread 以及离散化一下什么的。","text":"这题洛谷的数据太…水，克鲁斯卡尔重构树不连通都可水过。 3545: [ONTAK2010]Peaks 3551: [ONTAK2010]Peaks加强版 在线算法：克鲁斯卡尔重构树套主席树。 在克鲁斯卡尔重构树上维护 DFS 序（或树链剖分）再套上主席树，维护第 $k$ 大。 当然非加强版由于你是重构树（被针对了）可能要大力卡常。比如加个 fread 以及离散化一下什么的。 代码（ Fast IO 直接用了别人的板子不要在意 qwq）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long long#define il inline#define re register #define DEBUG std::cerr &lt;&lt; std::clock() &lt;&lt; endl#define rep(i,l,r) for (int i = l; i &lt;= r; i++)#define getc(x) getchar(x)#define putc(x) putchar(x)namespace FastIO &#123; const size_t str = 1 &lt;&lt; 20; struct Reader &#123; char buf[str], *s, *t; Reader ( ) : s( ), t( ), buf() &#123; &#125; inline char pick ( ) &#123; return (s == t) ? ( t = buf + fread ( s = buf, 1, str , stdin ), *s++ ) : ( *s++ ); &#125; template &lt; class T &gt; inline Reader&amp; operator &gt;&gt; ( T&amp; x ) &#123; static char ch; static short opt; opt = (ch != 45); while ( !isdigit ( ch = pick () ) &amp;&amp; (ch ^ -1) &amp;&amp; ( ch ^ 45 ) ); if ( ch == -1 ) return *this; if ( ch == 45 ) &#123; opt = 0; ch = pick (); &#125; for ( x = -48 + ch; isdigit ( ch = pick () ); ( x *= 10 ) += ch - 48 ); opt ? 1 : x = -x; return *this; &#125; &#125; cin; struct Writer &#123; char buf[str], *s, *t; Writer () : s ( buf ), t( buf + str ), buf ( ) &#123; &#125; ~Writer () &#123; fwrite( buf, 1, s - buf, stdout ); &#125; inline void echo ( char c ) &#123; ( s == t ) ? ( fwrite ( s = buf, 1, str, stdout ), *s++ = c ) : ( *s++ = c ); &#125; inline Writer&amp; operator &lt;&lt; ( long long x ) &#123; if( !x ) return echo( 48 ), *this; static int t[21], top; if (x &lt; 0) x = -x, echo ( '-' ); while ( x ) t[++top] = x % 10, x /= 10; while ( top ) echo(t[top--] + 48); return *this; &#125; inline Writer&amp; operator &lt;&lt; (const char* s) &#123; while ( *s ) echo( *s++ ) ; return *this; &#125; &#125; cout; const char *endl = \"\\n\";&#125; using FastIO::cin;using FastIO::cout;using FastIO::endl;const int N = 200010, M = 500010, E = N * 30;int n, m, p, u, v, w, t, x, k, tn, cnt, pos, ord, lastans;int b[N], fa[N], id[N], wid[N], val[N], siz[N];int f[N][20], g[N][20];int lc[E], rc[E], sum[E], root[N];bool vis[N];struct edge &#123; int u, v, w;&#125; e[M];bool operator &lt; (const edge &amp;a, const edge &amp;b) &#123; return a.w &lt; b.w;&#125;int tot = 2, hed[N], nxt[N &lt;&lt; 1], to[N &lt;&lt; 1];il void add_edge(int u, int v) &#123; nxt[tot] = hed[u], to[tot] = v, hed[u] = tot++; nxt[tot] = hed[v], to[tot] = u, hed[v] = tot++;&#125;il int find(int u) &#123; if (fa[u] == u) return u; return fa[u] = find(fa[u]);&#125;void dfs(int u) &#123; siz[u] = 1, id[u] = ++pos, wid[id[u]] = u, vis[u] = 1; for (int i = hed[u], v = to[i]; i; i = nxt[i], v = to[i]) if (v ^ f[u][0]) &#123; f[v][0] = u; g[v][0] = (u &lt;= n ? 0 : val[u]); dfs(v); siz[u] += siz[v]; &#125;&#125;void build(int &amp;u, int v, int l, int r, int k) &#123; u = ++ord, lc[u] = lc[v], rc[u] = rc[v], sum[u] = sum[v] + 1; if (l == r) return; int mid = (l + r) &gt;&gt; 1; if (k &lt;= mid) build(lc[u], lc[v], l, mid, k); else build(rc[u], rc[v], mid + 1, r, k);&#125;int query(int u, int v, int l, int r, int k) &#123; if (l == r) return (k &lt;= (sum[v] - sum[u]) ? b[l] : -1); if (l == r) return l; int mid = (l + r) &gt;&gt; 1, tmp; tmp = sum[rc[v]] - sum[rc[u]]; if (k &lt;= tmp) return query(rc[u], rc[v], mid + 1, r, k); else return query(lc[u], lc[v], l, mid, k - tmp);&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; p; for (re int i = 1; i &lt;= n; i++) cin &gt;&gt; val[i]; for (re int i = 1; i &lt;= m; i++) cin &gt;&gt; e[i].u &gt;&gt; e[i].v &gt;&gt; e[i].w; std::sort(e + 1, e + m + 1); for (re int i = 1; i &lt;= (n &lt;&lt; 1); i++) fa[i] = i; cnt = n; for (re int i = 1; i &lt;= n; i++) b[i] = val[i]; std::sort(b + 1, b + n + 1); tn = std::unique(b + 1, b + n + 1) - b - 1; for (re int i = 1; i &lt;= n; i++) val[i] = std::lower_bound(b + 1, b + tn + 1, val[i]) - b; for (re int i = 1; i &lt;= m; i++) &#123; u = e[i].u, v = e[i].v, w = e[i].w; if (find(u) ^ find(v)) &#123; t = ++cnt; u = find(u), v = find(v); fa[u] = fa[v] = t; add_edge(u, t); add_edge(v, t); val[t] = w; &#125; &#125; val[++cnt] = 1e9; for (re int i = 1; i &lt; cnt; i++) if (find(i) != find(cnt)) &#123; add_edge(find(i), cnt); fa[find(i)] = find(cnt); &#125; dfs(cnt); for (re int i = 1; i &lt;= cnt; i++) if (wid[i] &lt;= n) build(root[i], root[i - 1], 1, tn, val[wid[i]]); else root[i] = root[i - 1]; for (re int i = 1; i &lt;= 19; i++) for (re int j = 1; j &lt;= cnt; j++) &#123; f[j][i] = f[f[j][i - 1]][i - 1]; g[j][i] = std::max(g[j][i - 1], g[f[j][i - 1]][i - 1]); &#125; for (re int i = 1; i &lt;= p; i++) &#123; cin &gt;&gt; u &gt;&gt; x &gt;&gt; k; if (~lastans) &#123; u ^= lastans; x ^= lastans; k ^= lastans; &#125; for (re int i = 19; i &gt;= 0; i--) if (x &gt;= g[u][i] &amp;&amp; f[u][i]) &#123; u = f[u][i]; &#125; cout &lt;&lt; (lastans = query(root[id[u] - 1], root[id[u] + siz[u] - 1], 1, tn, k)) &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"https://memset0.cn/categories/Solution/"}],"tags":[{"name":"主席树","slug":"主席树","permalink":"https://memset0.cn/tags/主席树/"},{"name":"强制在线","slug":"强制在线","permalink":"https://memset0.cn/tags/强制在线/"},{"name":"克鲁斯卡尔重构树","slug":"克鲁斯卡尔重构树","permalink":"https://memset0.cn/tags/克鲁斯卡尔重构树/"},{"name":"DFS 序","slug":"DFS-序","permalink":"https://memset0.cn/tags/DFS-序/"},{"name":"树上倍增","slug":"树上倍增","permalink":"https://memset0.cn/tags/树上倍增/"},{"name":"树链剖分","slug":"树链剖分","permalink":"https://memset0.cn/tags/树链剖分/"}]},{"title":"BZOJ1002 - [FJOI2007]轮状病毒","slug":"solution/bzoj/1002","date":"2018-09-28T11:36:00.000Z","updated":"2018-12-09T02:04:54.759Z","comments":true,"path":"solution/bzoj/1002/","link":"","permalink":"https://memset0.cn/solution/bzoj/1002/","excerpt":"这题的规律是很好找的，难的就是需要用高精度进行计算。 于是我…厚颜无耻地逃避了高精度，用 Python 打了个表： 12345678910111213141516def locate(x): a = [1, 3] for i in range(2, x): a.append(a[-1] + a[-2]) # print(a) return a[x - 1]def solve(x): t = locate(x) if x % 2 == 1: return t ** 2 else: return t ** 2 - 4n = int(input())print(solve(n))","text":"这题的规律是很好找的，难的就是需要用高精度进行计算。 于是我…厚颜无耻地逃避了高精度，用 Python 打了个表： 12345678910111213141516def locate(x): a = [1, 3] for i in range(2, x): a.append(a[-1] + a[-2]) # print(a) return a[x - 1]def solve(x): t = locate(x) if x % 2 == 1: return t ** 2 else: return t ** 2 - 4n = int(input())print(solve(n)) C++ 交表： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long long#define rep(i,l,r) for (int i = l; i &lt;= r; i++)#define getc(x) getchar(x)#define putc(x) putchar(x)template &lt;typename T&gt; inline void read(T &amp;x) &#123; x = 0; register char ch; register bool fl = 0; while (ch = getc(), ch &lt; 48 || 57 &lt; ch) fl ^= ch == '-'; x = (ch &amp; 15); while (ch = getc(), 47 &lt; ch &amp;&amp; ch &lt; 58) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch &amp; 15); if (fl) x = -x;&#125;template &lt;typename T&gt; inline void print(T x, char c = ' ') &#123; static int buf[40]; if (x == 0) &#123; putc('0'); putc(c); return; &#125; if (x &lt; 0) putc('-'), x = -x; for (buf[0] = 0; x; x /= 10) buf[++buf[0]] = x % 10 + 48; while (buf[0]) putc((char) buf[buf[0]--]); putc(c);&#125;void init();int n;std::string ans[101];int main() &#123; init(); read(n); std::cout &lt;&lt; ans[n] &lt;&lt; std::endl; return 0;&#125; void init() &#123; ans[1] = \"1\"; ans[2] = \"5\"; ans[3] = \"16\"; ans[4] = \"45\"; ans[5] = \"121\"; ans[6] = \"320\"; ans[7] = \"841\"; ans[8] = \"2205\"; ans[9] = \"5776\"; ans[10] = \"15125\"; ans[11] = \"39601\"; ans[12] = \"103680\"; ans[13] = \"271441\"; ans[14] = \"710645\"; ans[15] = \"1860496\"; ans[16] = \"4870845\"; ans[17] = \"12752041\"; ans[18] = \"33385280\"; ans[19] = \"87403801\"; ans[20] = \"228826125\"; ans[21] = \"599074576\"; ans[22] = \"1568397605\"; ans[23] = \"4106118241\"; ans[24] = \"10749957120\"; ans[25] = \"28143753121\"; ans[26] = \"73681302245\"; ans[27] = \"192900153616\"; ans[28] = \"505019158605\"; ans[29] = \"1322157322201\"; ans[30] = \"3461452808000\"; ans[31] = \"9062201101801\"; ans[32] = \"23725150497405\"; ans[33] = \"62113250390416\"; ans[34] = \"162614600673845\"; ans[35] = \"425730551631121\"; ans[36] = \"1114577054219520\"; ans[37] = \"2918000611027441\"; ans[38] = \"7639424778862805\"; ans[39] = \"20000273725560976\"; ans[40] = \"52361396397820125\"; ans[41] = \"137083915467899401\"; ans[42] = \"358890350005878080\"; ans[43] = \"939587134549734841\"; ans[44] = \"2459871053643326445\"; ans[45] = \"6440026026380244496\"; ans[46] = \"16860207025497407045\"; ans[47] = \"44140595050111976641\"; ans[48] = \"115561578124838522880\"; ans[49] = \"302544139324403592001\"; ans[50] = \"792070839848372253125\"; ans[51] = \"2073668380220713167376\"; ans[52] = \"5428934300813767249005\"; ans[53] = \"14213134522220588579641\"; ans[54] = \"37210469265847998489920\"; ans[55] = \"97418273275323406890121\"; ans[56] = \"255044350560122222180445\"; ans[57] = \"667714778405043259651216\"; ans[58] = \"1748099984655007556773205\"; ans[59] = \"4576585175559979410668401\"; ans[60] = \"11981655542024930675232000\"; ans[61] = \"31368381450514812615027601\"; ans[62] = \"82123488809519507169850805\"; ans[63] = \"215002084978043708894524816\"; ans[64] = \"562882766124611619513723645\"; ans[65] = \"1473646213395791149646646121\"; ans[66] = \"3858055874062761829426214720\"; ans[67] = \"10100521408792494338631998041\"; ans[68] = \"26443508352314721186469779405\"; ans[69] = \"69230003648151669220777340176\"; ans[70] = \"181246502592140286475862241125\"; ans[71] = \"474509504128269190206809383201\"; ans[72] = \"1242282009792667284144565908480\"; ans[73] = \"3252336525249732662226888342241\"; ans[74] = \"8514727565956530702536099118245\"; ans[75] = \"22291846172619859445381409012496\"; ans[76] = \"58360810951903047633608127919245\"; ans[77] = \"152790586683089283455442974745241\"; ans[78] = \"400010949097364802732720796316480\"; ans[79] = \"1047242260609005124742719414204201\"; ans[80] = \"2741715832729650571495437446296125\"; ans[81] = \"7177905237579946589743592924684176\"; ans[82] = \"18791999880010189197735341327756405\"; ans[83] = \"49198094402450621003462431058585041\"; ans[84] = \"128802283327341673812651951847998720\"; ans[85] = \"337208755579574400434493424485411121\"; ans[86] = \"882823983411381527490828321608234645\"; ans[87] = \"2311263194654570182037991540339292816\"; ans[88] = \"6050965600552329018623146299409643805\"; ans[89] = \"15841633607002416873831447357889638601\"; ans[90] = \"41473935220454921602871195774259272000\"; ans[91] = \"108580172054362347934782139964888177401\"; ans[92] = \"284266580942632122201475224120405260205\"; ans[93] = \"744219570773534018669643532396327603216\"; ans[94] = \"1948392131377969933807455373068577549445\"; ans[95] = \"5100956823360375782752722586809405045121\"; ans[96] = \"13354478338703157414450712387359637585920\"; ans[97] = \"34962478192749096460599414575269507712641\"; ans[98] = \"91532956239544131967347531338448885552005\"; ans[99] = \"239636390525883299441443179440077148943376\"; ans[100] = \"627376215338105766356982006981782561278125\";&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"https://memset0.cn/categories/Solution/"}],"tags":[{"name":"数学，数论","slug":"数学，数论","permalink":"https://memset0.cn/tags/数学，数论/"},{"name":"打表","slug":"打表","permalink":"https://memset0.cn/tags/打表/"},{"name":"结论题","slug":"结论题","permalink":"https://memset0.cn/tags/结论题/"},{"name":"高精度","slug":"高精度","permalink":"https://memset0.cn/tags/高精度/"}]},{"title":"BZOJ2956 - 模积和","slug":"solution/bzoj/2956","date":"2018-09-27T03:18:00.000Z","updated":"2018-12-09T02:04:54.798Z","comments":true,"path":"solution/bzoj/2956/","link":"","permalink":"https://memset0.cn/solution/bzoj/2956/","excerpt":"$$\\sum_{i=1}^{n} \\sum_{j=1}^{m} (n \\% i) \\times (m \\% j) \\ \\ \\ (i \\not= j)$$ $$= (\\sum_{i=1}^{n} n \\% i) \\times (\\sum_{j=1}^{m} m \\% j) - \\sum_{i=1}^{\\min(n, m)} (n \\% i) \\times (m \\% j)$$ 可以转化成 $A \\times B - C$ 的形式，分别来求。 其中求 $A$ 和 $B$ 的方式是一样的，可以数论分块，也可以直接打表找规律。鉴于这部分不难，笔者写了后者，而描述起来而笔者又非常懒因此忽略求 $A$ 、 $B$ 直接讲求 $C$ 。当然你也可以通过推 $C$ 的方式自己推一下 $A$ 、 $B$ 。 $$C = \\sum_{i=1}^{\\min(n, m)} (n \\% i) \\times (m \\% i)$$ $$= \\sum_{i=1} ^ {\\min(n, m)} (n - i \\times \\lfloor \\frac {n} {i} \\rfloor) \\times (m - i \\times \\lfloor \\frac {m} {i} \\rfloor )$$ $$= \\sum_{i=1} ^ {\\min(n, m)} n \\times m - m \\times i \\times \\lfloor \\frac {n} {i} \\rfloor - n \\times i \\times \\lfloor \\frac {m} {i} \\rfloor + i ^ 2 \\times \\lfloor \\frac {m} {i} \\rfloor \\lfloor \\frac {m} {i} \\rfloor $$ 数论分块即可。","text":"$$\\sum_{i=1}^{n} \\sum_{j=1}^{m} (n \\% i) \\times (m \\% j) \\ \\ \\ (i \\not= j)$$ $$= (\\sum_{i=1}^{n} n \\% i) \\times (\\sum_{j=1}^{m} m \\% j) - \\sum_{i=1}^{\\min(n, m)} (n \\% i) \\times (m \\% j)$$ 可以转化成 $A \\times B - C$ 的形式，分别来求。 其中求 $A$ 和 $B$ 的方式是一样的，可以数论分块，也可以直接打表找规律。鉴于这部分不难，笔者写了后者，而描述起来而笔者又非常懒因此忽略求 $A$ 、 $B$ 直接讲求 $C$ 。当然你也可以通过推 $C$ 的方式自己推一下 $A$ 、 $B$ 。 $$C = \\sum_{i=1}^{\\min(n, m)} (n \\% i) \\times (m \\% i)$$ $$= \\sum_{i=1} ^ {\\min(n, m)} (n - i \\times \\lfloor \\frac {n} {i} \\rfloor) \\times (m - i \\times \\lfloor \\frac {m} {i} \\rfloor )$$ $$= \\sum_{i=1} ^ {\\min(n, m)} n \\times m - m \\times i \\times \\lfloor \\frac {n} {i} \\rfloor - n \\times i \\times \\lfloor \\frac {m} {i} \\rfloor + i ^ 2 \\times \\lfloor \\frac {m} {i} \\rfloor \\lfloor \\frac {m} {i} \\rfloor $$ 数论分块即可。 鉴于笔者写代码时思路非常混乱，下面仅供对拍： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long long#define rep(i,l,r) for (int i = l; i &lt;= r; i++)#define getc(x) getchar(x)#define putc(x) putchar(x)template &lt;typename T&gt; inline void read(T &amp;x) &#123; x = 0; register char ch; register bool fl = 0; while (ch = getc(), ch &lt; 48 || 57 &lt; ch) fl ^= ch == '-'; x = (ch &amp; 15); while (ch = getc(), 47 &lt; ch &amp;&amp; ch &lt; 58) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch &amp; 15); if (fl) x = -x;&#125;template &lt;typename T&gt; inline void print(T x, char c = '\\n') &#123; static int buf[40]; if (x == 0) &#123; putc('0'); putc(c); return; &#125; if (x &lt; 0) putc('-'), x = -x; for (buf[0] = 0; x; x /= 10) buf[++buf[0]] = x % 10 + 48; while (buf[0]) putc((char) buf[buf[0]--]); putc(c);&#125;const ll p = 19940417;ll n, m;void update(ll &amp;x) &#123; x = (x % p + p) % p;&#125;ll sum(ll n) &#123; ll a = n, b = n - 1; if (a % 2 == 0) a /= 2; else b /= 2; a %= p, b %= p; return a * b % p;&#125;ll sum(ll l, ll r) &#123; ll a = l + r, b = r - l + 1; if (a % 2 == 0) a /= 2; else b /= 2; a %= p, b %= p; return a * b % p;&#125;ll sum2(ll n) &#123; ll a = n, b = n + 1, c = (n &lt;&lt; 1) + 1; if (a % 2 == 0) a /= 2; else if (b % 2 == 0) b /= 2; else c /= 2; if (a % 3 == 0) a /= 3; else if (b % 3 == 0) b /= 3; else c /= 3; a %= p, b %= p, c %= p; return a * b % p * c % p;&#125;ll solve(ll n) &#123; ll m, ans = 0, sqn = sqrt(n), x, i, t; for (i = 2, x = n; x &gt; sqn; i++) &#123; t = m = (n - (n / i)) - (n - x); m %= p; ans += (n % x) % p * (m % p) % p, update(ans); ans += sum(m) % p * ((i - 1) % p) % p, update(ans); x -= t; &#125; for (i = 1; i &lt;= x; i++) ans += (n % i) % p, update(ans); return ans;&#125;ll solve2(ll n, ll m) &#123; if (n &gt; m) std::swap(n, m); ll ans = n * n % p * m % p; for (ll l = 1, r; l &lt;= n; l = r + 1) &#123; r = std::min(n / (n / l), m / (m / l)); ans -= n % p * (m / l % p) % p * sum(l, r) % p, update(ans); ans -= m % p * (n / l % p) % p * sum(l, r) % p, update(ans); ans += (n / l % p) * (m / l % p) % p * ((sum2(r) - sum2(l - 1) + p) % p) % p, update(ans); &#125; return ans;&#125;int main() &#123; read(n), read(m); print((solve(n) * solve(m) % p - solve2(n, m) + p) % p); return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"https://memset0.cn/categories/Solution/"}],"tags":[{"name":"数论分块","slug":"数论分块","permalink":"https://memset0.cn/tags/数论分块/"}]},{"title":"BZOJ2588 - Count on a tree","slug":"solution/bzoj/2588","date":"2018-09-27T03:14:00.000Z","updated":"2018-12-09T02:04:54.759Z","comments":true,"path":"solution/bzoj/2588/","link":"","permalink":"https://memset0.cn/solution/bzoj/2588/","excerpt":"询问树上路径第 $k$ 大：二分答案 + 树上查询。查询时用主席树差分 $tree[now] = tree[u] + tree[v] - tree[lca(u,v)] - tree[father(lca(u,v))]$ 即可。 时间复杂度 $O(n \\log ^2 n)$","text":"询问树上路径第 $k$ 大：二分答案 + 树上查询。查询时用主席树差分 $tree[now] = tree[u] + tree[v] - tree[lca(u,v)] - tree[father(lca(u,v))]$ 即可。 时间复杂度 $O(n \\log ^2 n)$ 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long long#define rep(i,l,r) for (int i = l; i &lt;= r; i++)#define getc(x) getchar(x)#define putc(x) putchar(x)template &lt;typename T&gt; inline void read(T &amp;x) &#123; x = 0; register char ch; register bool fl = 0; while (ch = getc(), ch &lt; 48 || 57 &lt; ch) fl ^= ch == '-'; x = (ch &amp; 15); while (ch = getc(), 47 &lt; ch &amp;&amp; ch &lt; 58) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch &amp; 15); if (fl) x = -x;&#125;template &lt;typename T&gt; inline void print(T x, char c = '\\n') &#123; static int buf[40]; if (x == 0) &#123; putc('0'); putc(c); return; &#125; if (x &lt; 0) putc('-'), x = -x; for (buf[0] = 0; x; x /= 10) buf[++buf[0]] = x % 10 + 48; while (buf[0]) putc((char) buf[buf[0]--]); putc(c);&#125;const int maxn = 100010, maxe = maxn * 40;int n, m, u, v, l, r, k, t, tn, pos, mid, ans, now, lastans;int val[maxn], tmp[maxn], root[maxn], dep[maxn];int f[maxn][20];int sum[maxe], lc[maxe], rc[maxe];int tot = 2, hed[maxn], to[maxn &lt;&lt; 1], nxt[maxn &lt;&lt; 1];inline void add_edge(int u, int v) &#123; nxt[tot] = hed[u], to[tot] = v; hed[u] = tot++;&#125;void build(int &amp;u, int l = 1, int r = tn) &#123; u = ++pos; if (l == r) return; int mid = (l + r) &gt;&gt; 1; build(lc[u], l, mid); build(rc[u], mid + 1, r);&#125;void modify(int &amp;u, int v, int k, int l = 1, int r = tn) &#123; u = ++pos; lc[u] = lc[v], rc[u] = rc[v], sum[u] = sum[v] + 1; if (l == r) return; int mid = (l + r) &gt;&gt; 1; if (k &lt;= mid) modify(lc[u], lc[v], k, l, mid); else modify(rc[u], rc[v], k, mid + 1, r);&#125;int query(int a, int b, int c, int d, int k, int l = 1, int r = tn) &#123; if (l == r) return l; int now = sum[lc[a]] + sum[lc[b]] - sum[lc[c]] - sum[lc[d]]; int mid = (l + r) &gt;&gt; 1; if (k &lt;= now) return query(lc[a], lc[b], lc[c], lc[d], k, l, mid); else return query(rc[a], rc[b], rc[c], rc[d], k - now, mid + 1, r);&#125;void dfs(int u) &#123; modify(root[u], root[f[u][0]], val[u]); for (int i = hed[u], v = to[i]; i; i = nxt[i], v = to[i]) if (v ^ f[u][0]) &#123; f[v][0] = u; dep[v] = dep[u] + 1; dfs(v); &#125;&#125;int lca(int u, int v) &#123; if (dep[u] &gt; dep[v]) std::swap(u, v); for (int i = 19; i &gt;= 0; i--) if (dep[f[v][i]] &gt;= dep[u]) v = f[v][i]; if (u == v) return u; for (int i = 19; i &gt;= 0; i--) if (f[u][i] ^ f[v][i]) u = f[u][i], v = f[v][i]; return f[u][0];&#125;int main() &#123;// freopen(\"INPUT\", \"r\", stdin); read(n), read(m); for (int i = 1; i &lt;= n; i++) &#123; read(val[i]); tmp[i] = val[i]; &#125; std::sort(tmp + 1, tmp + n + 1); tn = std::unique(tmp + 1, tmp + n + 1) - tmp - 1; for (int i = 1; i &lt;= n; i++) val[i] = std::lower_bound(tmp + 1, tmp + tn + 1, val[i]) - tmp;// for (int i = 1; i &lt;= n; i++)// print(val[i], ' ');// putc('\\n');// for (int i = 1; i &lt;= tn; i++)// print(tmp[i], ' ');// putc('\\n'); for (int i = 1; i &lt; n; i++) &#123; read(u), read(v); add_edge(u, v); add_edge(v, u); &#125; build(root[0]); dep[1] = 1, dfs(1); for (int i = 1; i &lt; 20; i++) for (int j = 1; j &lt;= n; j++) f[j][i] = f[f[j][i - 1]][i - 1]; for (int i = 1; i &lt;= m; i++) &#123; read(u), read(v), read(k); u ^= lastans, t = lca(u, v); print(lastans = tmp[query(root[u], root[v], root[t], root[f[t][0]], k)]); &#125; return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"https://memset0.cn/categories/Solution/"}],"tags":[{"name":"主席树","slug":"主席树","permalink":"https://memset0.cn/tags/主席树/"},{"name":"树上差分","slug":"树上差分","permalink":"https://memset0.cn/tags/树上差分/"},{"name":"二分答案","slug":"二分答案","permalink":"https://memset0.cn/tags/二分答案/"}]},{"title":"CF776D - The Door Problem","slug":"solution/codeforces/776d","date":"2018-09-26T00:49:00.000Z","updated":"2018-10-10T12:14:53.317Z","comments":true,"path":"solution/codeforces/776d/","link":"","permalink":"https://memset0.cn/solution/codeforces/776d/","excerpt":"由于每个门只会被两个钥匙控制，那么两个钥匙的选或不选就能建立起一种对应关系。即如果门本来是开着的，那么用了一把必须用另一把，不用一把必须不用另一把；如果们本来是开着的，那么不用一把必须用另一把，用了一把必须不用另一把。 Tarjan 跑 2-SAT 随手切，注意 $n$ 和 $m$ 不要搞反。","text":"由于每个门只会被两个钥匙控制，那么两个钥匙的选或不选就能建立起一种对应关系。即如果门本来是开着的，那么用了一把必须用另一把，不用一把必须不用另一把；如果们本来是开着的，那么不用一把必须用另一把，用了一把必须不用另一把。 Tarjan 跑 2-SAT 随手切，注意 $n$ 和 $m$ 不要搞反。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long long#define rep(i,l,r) for (int i = l; i &lt;= r; i++)#define getc(x) getchar(x)#define putc(x) putchar(x)template &lt;typename T&gt; inline void read(T &amp;x) &#123; x = 0; register char ch; register bool fl = 0; while (ch = getc(), ch &lt; 48 || 57 &lt; ch) fl ^= ch == '-'; x = (ch &amp; 15); while (ch = getc(), 47 &lt; ch &amp;&amp; ch &lt; 58) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch &amp; 15); if (fl) x = -x;&#125;template &lt;typename T&gt; inline void print(T x, char c = '\\n') &#123; static int buf[40]; if (x == 0) &#123; putc('0'); putc(c); return; &#125; if (x &lt; 0) putc('-'), x = -x; for (buf[0] = 0; x; x /= 10) buf[++buf[0]] = x % 10 + 48; while (buf[0]) putc((char) buf[buf[0]--]); putc(c);&#125;const int maxn = 200010, maxm = 400010;int n, m, t, x, cnt, pos, top;int a[maxn], b[maxn][2], low[maxn], dfn[maxn], stk[maxn], ins[maxn], col[maxn];int tot = 2, hed[maxn], nxt[maxm], to[maxm];inline void add_edge(int u, int v) &#123; nxt[tot] = hed[u], to[tot] = v; hed[u] = tot++;&#125;void tarjan(int u) &#123; dfn[u] = low[u] = ++pos; ins[u] = 1, stk[++top] = u; for (int i = hed[u]; i; i = nxt[i]) &#123; int v = to[i]; if (!dfn[v]) &#123; tarjan(v); low[u] = std::min(low[u], low[v]); &#125; else if (ins[v]) &#123; low[u] = std::min(low[u], dfn[v]); &#125; &#125; if (dfn[u] == low[u]) &#123; ++cnt; while (top) &#123; int v = stk[top--]; col[v] = cnt; ins[v] = 0; if (u == v) break; &#125; &#125;&#125;int main() &#123; read(n), read(m); for (int i = 1; i &lt;= n; i++) read(a[i]); for (int i = 1; i &lt;= m; i++) &#123; read(t); for (int j = 1; j &lt;= t; j++) &#123; read(x); b[x][b[x][0] ? 1 : 0] = i; &#125; &#125; for (int i = 1; i &lt;= n; i++) if (a[i]) &#123; add_edge(b[i][0], b[i][1]); add_edge(b[i][1], b[i][0]); add_edge(b[i][0] + m, b[i][1] + m); add_edge(b[i][1] + m, b[i][0] + m); &#125; else &#123; add_edge(b[i][0], b[i][1] + m); add_edge(b[i][1] + m, b[i][0]); add_edge(b[i][1], b[i][0] + m); add_edge(b[i][0] + m, b[i][1]); &#125; for (int i = 1; i &lt;= (m &lt;&lt; 1); i++) if (!dfn[i]) tarjan(i); for (int i = 1; i &lt;= (m &lt;&lt; 1); i++) if (col[i] == col[i + m]) &#123; puts(\"NO\"); return 0; &#125; puts(\"YES\"); return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"https://memset0.cn/categories/Solution/"}],"tags":[{"name":"2-SAT","slug":"2-SAT","permalink":"https://memset0.cn/tags/2-SAT/"}]},{"title":"BZOJ1070 - [SCOI2007]修车","slug":"solution/bzoj/1070","date":"2018-09-25T02:13:00.000Z","updated":"2018-12-09T02:04:54.759Z","comments":true,"path":"solution/bzoj/1070/","link":"","permalink":"https://memset0.cn/solution/bzoj/1070/","excerpt":"最小费用最大流。由于一个工人在给一个顾客服务后还能再给一个顾客服务， 所以把每个顾客和每个工人建点显然不能完成任务。 那么我们考虑把第 $i$ 个工人建成 $n$ 个点，表示为 $P(i,j) (i \\in [1, m], j \\in [1, n])$。把第 $i$ 个顾客表示为 $T(k)$。 把 $T(k)$ 依次向 $P(i,j)$ 连边，流量为 $1$ ，费用为 $w(k,i) \\times j$ 。表示第 $k$ 个顾客被第 $i$ 个工人倒数第 $j$ 个服务对答案产生的贡献（即包括在它之后的人的等待时间，而不是这个人自己的花费）。 最后从源点向每个顾客连流量 $1$ ，费用 $0$ 的边，$n \\times m$ 个工人向汇点连流量 $1$ ，费用为 $0$ 的边，跑最小费用最大流即可。","text":"最小费用最大流。由于一个工人在给一个顾客服务后还能再给一个顾客服务， 所以把每个顾客和每个工人建点显然不能完成任务。 那么我们考虑把第 $i$ 个工人建成 $n$ 个点，表示为 $P(i,j) (i \\in [1, m], j \\in [1, n])$。把第 $i$ 个顾客表示为 $T(k)$。 把 $T(k)$ 依次向 $P(i,j)$ 连边，流量为 $1$ ，费用为 $w(k,i) \\times j$ 。表示第 $k$ 个顾客被第 $i$ 个工人倒数第 $j$ 个服务对答案产生的贡献（即包括在它之后的人的等待时间，而不是这个人自己的花费）。 最后从源点向每个顾客连流量 $1$ ，费用 $0$ 的边，$n \\times m$ 个工人向汇点连流量 $1$ ，费用为 $0$ 的边，跑最小费用最大流即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long long#define rep(i,l,r) for (int i = l; i &lt;= r; i++)#define getc(x) getchar(x)#define putc(x) putchar(x)template &lt;typename T&gt; inline void read(T &amp;x) &#123; x = 0; register char ch; register bool fl = 0; while (ch = getc(), ch &lt; 48 || 57 &lt; ch) fl ^= ch == '-'; x = (ch &amp; 15); while (ch = getc(), 47 &lt; ch &amp;&amp; ch &lt; 58) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch &amp; 15); if (fl) x = -x;&#125;template &lt;typename T&gt; inline void print(T x, char c = '\\n') &#123; static int buf[40]; if (x == 0) &#123; putc('0'); return; &#125; if (x &lt; 0) putc('-'), x = -x; for (buf[0] = 0; x; x /= 10) buf[++buf[0]] = x % 10 + 48; while (buf[0]) putc((char) buf[buf[0]--]); putc(c);&#125;const int maxn = 4010, maxm = 1000010;#define at(i,j) ((i) * m + (j))int n, m, u, v, w, s, e, l, r, ans, flag;int dis[maxn], pre[maxn], inq[maxn], q[maxn];int tot = 2, hed[maxn], nxt[maxm], to[maxm], val[maxm], cst[maxm];inline void add_simple_edge(int u, int v, int w, int c) &#123; nxt[tot] = hed[u], to[tot] = v, val[tot] = w, cst[tot] = c; hed[u] = tot++;&#125;inline void add_edge(int u, int v, int w, int c) &#123; add_simple_edge(u, v, w, c); add_simple_edge(v, u, 0, -c);&#125;bool spfa() &#123; memset(dis, 63, sizeof(dis)); memset(pre, 0, sizeof(pre)); l = r = 1, q[1] = s, inq[s] = 1, dis[s] = 0; while (l &lt;= r) &#123; u = q[(l++) % (e + 2)], inq[u] = 0; for (int i = hed[u], v = to[i]; i; i = nxt[i], v = to[i]) if (val[i] &amp;&amp; dis[v] &gt; dis[u] + cst[i]) &#123; dis[v] = dis[u] + cst[i]; pre[v] = i; if (!inq[v]) &#123; inq[v] = 1; q[(++r) % (e + 2)] = v; &#125; &#125; &#125; return pre[e];&#125;int main() &#123; read(n), read(m); s = n * m + m + 1, e = s + 1; for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; read(w); for (int k = 1; k &lt;= m; k++) add_edge(i, at(j, k), 1, w * k); &#125; &#125; for (int i = 1; i &lt;= m; i++) add_edge(s, i, 1, 0); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) add_edge(at(i, j), e, 1, 0); while (spfa()) &#123; for (int i = pre[e]; i; i = pre[to[i ^ 1]]) val[i] -= 1, val[i ^ 1] += 1; for (int i = pre[e]; i; i = pre[to[i ^ 1]]) ans += cst[i]; &#125; printf(\"%.2lf\\n\", ans / (double)m); return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"https://memset0.cn/categories/Solution/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"https://memset0.cn/tags/网络流/"},{"name":"最小费用最大流","slug":"最小费用最大流","permalink":"https://memset0.cn/tags/最小费用最大流/"}]},{"title":"洛谷1251 - 餐巾计划问题","slug":"solution/luogu/1251","date":"2018-09-24T14:58:00.000Z","updated":"2018-10-10T12:14:53.318Z","comments":true,"path":"solution/luogu/1251/","link":"","permalink":"https://memset0.cn/solution/luogu/1251/","excerpt":"到这题为止网络流 24 题也快刷完了呢，还剩下几道码量特大的等着以后有空去浪费时间（逃 这题一眼最小费用最大流，一开始我想了个类似于 NOI2008 志愿者招募 之类的利用满流的方法，但是一直没有调出来。后来怂了，直接连边，最后因为有个 - 1 没有删干净还是调了老半天。orz ，我还是太菜了。 把每一天分成两个节点，一个接受干净的毛巾，一个输出用过的毛巾。直接在这两个点之间连边显然不现实，我们可以分别把这两个点和源点、汇点连边。然后再按照题目条件一一连上对应边。这样最大流肯定能够跑满，求最小费用的话就是这图的最小费用最大流了。 这告诉我们对于不清楚的知识点不要瞎用。","text":"到这题为止网络流 24 题也快刷完了呢，还剩下几道码量特大的等着以后有空去浪费时间（逃 这题一眼最小费用最大流，一开始我想了个类似于 NOI2008 志愿者招募 之类的利用满流的方法，但是一直没有调出来。后来怂了，直接连边，最后因为有个 - 1 没有删干净还是调了老半天。orz ，我还是太菜了。 把每一天分成两个节点，一个接受干净的毛巾，一个输出用过的毛巾。直接在这两个点之间连边显然不现实，我们可以分别把这两个点和源点、汇点连边。然后再按照题目条件一一连上对应边。这样最大流肯定能够跑满，求最小费用的话就是这图的最小费用最大流了。 这告诉我们对于不清楚的知识点不要瞎用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long long#define rep(i,l,r) for (int i = l; i &lt;= r; i++)#define getc(x) getchar(x)#define putc(x) putchar(x)template &lt;typename T&gt; inline void read(T &amp;x) &#123; x = 0; register char ch; register bool fl = 0; while (ch = getc(), ch &lt; 48 || 57 &lt; ch) fl ^= ch == '-'; x = (ch &amp; 15); while (ch = getc(), 47 &lt; ch &amp;&amp; ch &lt; 58) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch &amp; 15); if (fl) x = -x;&#125;template &lt;typename T&gt; inline void print(T x, char c = '\\n') &#123; static int buf[40]; if (x == 0) &#123; putc('0'); return; &#125; if (x &lt; 0) putc('-'), x = -x; for (buf[0] = 0; x; x /= 10) buf[++buf[0]] = x % 10 + 48; while (buf[0]) putc((char) buf[buf[0]--]); putc(c);&#125;const int maxn = 4010, maxe = 50010;const int inf = 1000000000;int n, m, u, v, l, r, s, e, p;int t1, t2, v1, v2, tmp, flow;int a[maxn], pre[maxn], q[maxn], inq[maxn];ll ans, dis[maxn];int tot = 2, hed[maxn], nxt[maxe], to[maxe], val[maxe], cst[maxe];inline void add_simple_edge(int u, int v, int w, int c) &#123; nxt[tot] = hed[u], to[tot] = v; val[tot] = w, cst[tot] = c; hed[u] = tot++;&#125;inline void add_edge(int u, int v, int w, int c) &#123; add_simple_edge(u, v, w, c); add_simple_edge(v, u, 0, -c);&#125;bool spfa() &#123; memset(dis, 127, sizeof(dis)); memset(pre, 0, sizeof(pre)); l = r = 1, q[1] = s, dis[s] = 0, inq[s] = 1; while (l &lt;= r) &#123; u = q[(l++) % (e + 10)], inq[u] = 0; for (int i = hed[u], v = to[i]; i; i = nxt[i], v = to[i]) if (val[i] &amp;&amp; dis[v] &gt; dis[u] + cst[i]) &#123; dis[v] = dis[u] + cst[i]; pre[v] = i; if (!inq[v]) &#123; inq[v] = 1; q[(++r) % (e + 10)] = v; &#125; &#125; &#125; return pre[e];&#125;int main() &#123; read(n), s = (n &lt;&lt; 1) + 1, e = s + 1; for (int i = 1; i &lt;= n; i++) read(a[i]); read(p), read(t1), read(v1), read(t2), read(v2); for (int i = 1; i &lt;= n; i++) add_edge(s, i + n, a[i], 0); for (int i = 1; i &lt;= n; i++) add_edge(i, e, a[i], 0); for (int i = 1; i &lt;= n; i++) add_edge(s, i, inf, p); for (int i = 1; i + t1 &lt;= n; i++) add_edge(i + n, i + t1, inf, v1); for (int i = 1; i + t2 &lt;= n; i++) add_edge(i + n, i + t2, inf, v2); for (int i = 1; i &lt; n; i++) add_edge(i, i + 1, inf, 0); while (spfa()) &#123; flow = inf; for (int i = pre[e]; i; i = pre[to[i ^ 1]]) flow = std::min(flow, val[i]); for (int i = pre[e]; i; i = pre[to[i ^ 1]]) val[i] -= flow, val[i ^ 1] += flow; for (int i = pre[e]; i; i = pre[to[i ^ 1]]) ans += cst[i] * (ll)flow; &#125; print(ans); return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"https://memset0.cn/categories/Solution/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"https://memset0.cn/tags/网络流/"},{"name":"最小费用最大流","slug":"最小费用最大流","permalink":"https://memset0.cn/tags/最小费用最大流/"}]},{"title":"BZOJ1001 - [BJOI2006]狼抓兔子","slug":"solution/bzoj/1001","date":"2018-09-24T09:02:00.000Z","updated":"2018-12-09T02:12:07.325Z","comments":true,"path":"solution/bzoj/1001/","link":"","permalink":"https://memset0.cn/solution/bzoj/1001/","excerpt":"最大流最小割模板题。 想当年第一次打开 BZOJ 做完 A + B 之后看得一脸懵逼的就是这道题，没想到现如今看起来这么简单 不过还是没有秒切，双向边没看到调了好久 QAQ 好了，关于那个连边。这是本人单向边网络流连边： 12345inline void add_edge(int u, int v, int w) &#123; nxt[tot] = hed[u], to[tot] = v, val[tot] = w, hed[u] = tot++; nxt[tot] = hed[v], to[tot] = u, val[tot] = 0, hed[v] = tot++; return;&#125; 这是本人的双向网络流连边（连两遍也是一样的）： 12345inline void add_edge(int u, int v, int w) &#123; nxt[tot] = hed[u], to[tot] = v, val[tot] = w, hed[u] = tot++; nxt[tot] = hed[v], to[tot] = u, val[tot] = w, hed[v] = tot++; return;&#125; 另外 $最大流 = 最小割$ 不必多说了吧，贴个直观的证明（来自：https://jecvay.com/2014/11/what-is-min-cut.html）： 1.最大流不可能大于最小割, 因为最大流所有的水流都一定经过最小割那些割边, 流过的水流怎么可能比水管容量还大呢? 2.最大流不可能小于最小割, 如果小, 那么说明水管容量没有物尽其用, 可以继续加大水流. 那么 SAP + 当前弧优化 + 断层优化 + 反向 BFS 一遍轻松跑过。","text":"最大流最小割模板题。 想当年第一次打开 BZOJ 做完 A + B 之后看得一脸懵逼的就是这道题，没想到现如今看起来这么简单 不过还是没有秒切，双向边没看到调了好久 QAQ 好了，关于那个连边。这是本人单向边网络流连边： 12345inline void add_edge(int u, int v, int w) &#123; nxt[tot] = hed[u], to[tot] = v, val[tot] = w, hed[u] = tot++; nxt[tot] = hed[v], to[tot] = u, val[tot] = 0, hed[v] = tot++; return;&#125; 这是本人的双向网络流连边（连两遍也是一样的）： 12345inline void add_edge(int u, int v, int w) &#123; nxt[tot] = hed[u], to[tot] = v, val[tot] = w, hed[u] = tot++; nxt[tot] = hed[v], to[tot] = u, val[tot] = w, hed[v] = tot++; return;&#125; 另外 $最大流 = 最小割$ 不必多说了吧，贴个直观的证明（来自：https://jecvay.com/2014/11/what-is-min-cut.html）： 1.最大流不可能大于最小割, 因为最大流所有的水流都一定经过最小割那些割边, 流过的水流怎么可能比水管容量还大呢? 2.最大流不可能小于最小割, 如果小, 那么说明水管容量没有物尽其用, 可以继续加大水流. 那么 SAP + 当前弧优化 + 断层优化 + 反向 BFS 一遍轻松跑过。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long long#define rep(i,l,r) for (int i = l; i &lt;= r; i++)#define getc(x) getchar(x)#define putc(x) putchar(x) template &lt;typename T&gt; inline void read(T &amp;x) &#123; x = 0; register char ch; register bool fl = 0; while (ch = getc(), ch &lt; 48 || 57 &lt; ch) fl ^= ch == '-'; x = (ch &amp; 15); while (ch = getc(), 47 &lt; ch &amp;&amp; ch &lt; 58) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch &amp; 15); if (fl) x = -x;&#125;template &lt;typename T&gt; inline void print(T x, char c = '\\n') &#123; static int buf[40]; if (x == 0) &#123; putc('0'); return; &#125; if (x &lt; 0) putc('-'), x = -x; for (buf[0] = 0; x; x /= 10) buf[++buf[0]] = x % 10 + 48; while (buf[0]) putc((char) buf[buf[0]--]); putc(c);&#125; const int maxn = 1000010, maxm = maxn * 6, inf = 1e9; int n, m, x, u, l, r, ans, flow, flag;int pre[maxn], dep[maxn], gap[maxn], cur[maxn], q[maxn];int tot = 2, hed[maxn], to[maxm], val[maxm], nxt[maxm]; #define at(i,j) (((i) - 1) * m + (j)) inline void add_edge(int u, int v, int w) &#123; nxt[tot] = hed[u], to[tot] = v, val[tot] = w, hed[u] = tot++; nxt[tot] = hed[v], to[tot] = u, val[tot] = w, hed[v] = tot++; return;&#125; void bfs() &#123; for (int i = 1; i &lt;= n * m; i++) cur[i] = hed[i]; l = r = 1, q[1] = n * m, gap[1] = 1, dep[n * m] = 1; while (l &lt;= r) &#123; u = q[l++]; for (int i = hed[u], v = to[i]; i; i = nxt[i], v = to[i]) &#123; if (!dep[v]) &#123; dep[v] = dep[u] + 1; gap[dep[v]]++; q[++r] = v; &#125; &#125; &#125;&#125; void isap(int s, int e) &#123; u = s; while (dep[s] &lt;= e) &#123; flag = 0; for (int &amp;i = cur[u], v = to[i]; i; i = nxt[i], v = to[i]) if (val[i] &amp;&amp; dep[v] + 1 == dep[u]) &#123; u = v; pre[v] = i; flag = 1; break; &#125; if (!flag) &#123; if (!--gap[dep[u]]) break; dep[u] = e; for (int i = hed[u], v = to[i]; i; i = nxt[i], v = to[i]) if (val[i] &amp;&amp; dep[v] + 1 &lt; dep[u]) &#123; dep[u] = dep[v] + 1; cur[u] = i; &#125; ++gap[dep[u]]; if (u ^ s) u = to[pre[u] ^ 1]; &#125; if (u == e) &#123; flow = inf; for (int i = pre[e]; i; i = pre[to[i ^ 1]]) flow = std::min(flow, val[i]); for (int i = pre[e]; i; i = pre[to[i ^ 1]]) val[i] -= flow, val[i ^ 1] += flow; ans += flow, u = s; &#125; &#125;&#125; int main() &#123; read(n), read(m); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt; m; j++) read(x), add_edge(at(i, j), at(i, j + 1), x); for (int i = 1; i &lt; n; i++) for (int j = 1; j &lt;= m; j++) read(x), add_edge(at(i, j), at(i + 1, j), x); for (int i = 1; i &lt; n; i++) for (int j = 1; j &lt; m; j++) read(x), add_edge(at(i, j), at(i + 1, j + 1), x); bfs(); isap(1, n * m); print(ans); return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"https://memset0.cn/categories/Solution/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"https://memset0.cn/tags/网络流/"},{"name":"最大流","slug":"最大流","permalink":"https://memset0.cn/tags/最大流/"}]},{"title":"C++ 函数传递二维数组","slug":"geek/函数传递二维数组","date":"2018-09-23T04:47:00.000Z","updated":"2018-12-09T02:03:45.459Z","comments":true,"path":"geek/函数传递二维数组/","link":"","permalink":"https://memset0.cn/geek/函数传递二维数组/","excerpt":"QAQ 写树套树的时候忽然用到。。。","text":"QAQ 写树套树的时候忽然用到。。。 我们可以这样引用一维数组： 1234567891011121314151617181920int a[10];void function1(int *array) &#123; /* some code */&#125;void function2(int array[]) &#123; /* some code */&#125;void function3(int *array) &#123; /* some code */&#125;int main() &#123; function1(a); function2(a); function3(a); return 0;&#125; 但是二维数组就有所不同，对于第二维和更高维的部分，必须给出大小，像下面一样。 123456789101112131415int a[10][20];void function1(int array[10][20]) &#123; /* some code */&#125;void function2(int array[][20]) &#123; /* some code */&#125;int main() &#123; function1(a); function2(a); return 0;&#125;","categories":[{"name":"Geek","slug":"Geek","permalink":"https://memset0.cn/categories/Geek/"}],"tags":[]},{"title":"洛谷4396 - [AHOI2013]作业","slug":"solution/luogu/4396","date":"2018-09-22T14:23:00.000Z","updated":"2018-10-10T12:14:53.320Z","comments":true,"path":"solution/luogu/4396/","link":"","permalink":"https://memset0.cn/solution/luogu/4396/","excerpt":"最近忽然发现 BZOJ 的权限题还是很多的（可能是因为以前搜不到就不搜了现在上 DARKBZOJ ），看来还是得众筹买个权限号了（雾 这是一道傻逼数据结构题，由于数据范围小，各种奇葩算法随便过。本菜鸡就写了个普通的树状数组套莫队，各位大佬不要见笑。","text":"最近忽然发现 BZOJ 的权限题还是很多的（可能是因为以前搜不到就不搜了现在上 DARKBZOJ ），看来还是得众筹买个权限号了（雾 这是一道傻逼数据结构题，由于数据范围小，各种奇葩算法随便过。本菜鸡就写了个普通的树状数组套莫队，各位大佬不要见笑。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long long#define rep(i,l,r) for (int i = l; i &lt;= r; i++)int read() &#123; int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;&#125;const int maxn = 100010, maxm = 100010;#define lowbit(x) ((x)&amp;(-(x)))int n, m, l, r, x, y, tn, ql, qr, sqn;int a[maxn], b[maxn], bln[maxn], cnt[maxn], s[2][maxn], ans[2][maxm];struct query &#123; int l, r, x, y, i;&#125; q[maxm];bool cmp(query x, query y) &#123; if (bln[x.l] ^ bln[y.l]) return x.l &lt; y.l; return x.r &lt; y.r;&#125;inline void modify(int i, int x, int k) &#123; i++; for (; i &lt;= n + 1; i += lowbit(i)) s[k][i] += x;&#125;inline int query(int i, int k) &#123; int ret = 0; i++; for (; i &gt;= 2; i -= lowbit(i)) ret += s[k][i]; return ret;&#125;inline void add(int x) &#123; if (!cnt[x]) &#123; modify(x, 1, 1); &#125; modify(x, 1, 0); cnt[x]++;&#125;inline void del(int x) &#123; modify(x, -1, 0); cnt[x]--; if (!cnt[x]) &#123; modify(x, -1, 1); &#125;&#125;int main() &#123; n = read(), m = read(), sqn = n / sqrt(m * 2.0 / 3); if (sqn == 0) sqn++; for (int i = 1; i &lt;= n; i++) bln[i] = i / sqn; for (int i = 1; i &lt;= n; i++) a[i] = read(); for (int i = 1; i &lt;= n; i++) b[i] = a[i]; std::sort(b + 1, b + n + 1); tn = std::unique(b + 1, b + n + 1) - b - 1; for (int i = 1; i &lt;= n; i++) a[i] = std::lower_bound(b + 1, b + tn + 1, a[i]) - b; for (int i = 1; i &lt;= m; i++) &#123; q[i].l = read(), q[i].r = read(); q[i].x = read(), q[i].y = read(); q[i].i = i; &#125; std::sort(q + 1, q + m + 1, cmp); ql = 1, qr = 0; for (int i = 1; i &lt;= m; i++) &#123; l = q[i].l, r = q[i].r; x = q[i].x, y = q[i].y; x = std::lower_bound(b + 1, b + tn + 1, x) - b - 1; y = std::upper_bound(b + 1, b + tn + 1, y) - b - 1; while (ql &lt; l) del(a[ql++]); while (ql &gt; l) add(a[--ql]); while (qr &gt; r) del(a[qr--]); while (qr &lt; r) add(a[++qr]); ans[0][q[i].i] = query(y, 0) - query(x, 0); ans[1][q[i].i] = query(y, 1) - query(x, 1); &#125; for (int i = 1; i &lt;= m; i++) printf(\"%d %d\\n\", ans[0][i], ans[1][i]); return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"https://memset0.cn/categories/Solution/"}],"tags":[{"name":"树状数组","slug":"树状数组","permalink":"https://memset0.cn/tags/树状数组/"},{"name":"莫队","slug":"莫队","permalink":"https://memset0.cn/tags/莫队/"}]},{"title":"CF706E - Working routine","slug":"solution/codeforces/706e","date":"2018-09-21T12:55:00.000Z","updated":"2018-10-10T12:14:53.317Z","comments":true,"path":"solution/codeforces/706e/","link":"","permalink":"https://memset0.cn/solution/codeforces/706e/","excerpt":"题意： 给你个 $1000 \\times 1000$ 的矩阵，每次交换任意两个不重合的子矩阵，求最后的结果 如果你是一位数据结构学傻的选手（像我），那么第一感觉肯定是用平衡树做，复杂度 $O(m \\times n \\log n)$ ，不过不幸的是，由于常数巨大，最后得分甚至可能不如暴力的 memcpy 。 如果你是一个不会高级数据结构的普及选手你说不定就能想到链表。维护一个矩形的链表，然后每次交换就分别把两块矩阵取出再拼接上去。","text":"题意： 给你个 $1000 \\times 1000$ 的矩阵，每次交换任意两个不重合的子矩阵，求最后的结果 如果你是一位数据结构学傻的选手（像我），那么第一感觉肯定是用平衡树做，复杂度 $O(m \\times n \\log n)$ ，不过不幸的是，由于常数巨大，最后得分甚至可能不如暴力的 memcpy 。 如果你是一个不会高级数据结构的普及选手你说不定就能想到链表。维护一个矩形的链表，然后每次交换就分别把两块矩阵取出再拼接上去。 彩蛋——在摸你赛中的题面： 之所以续走的那些香港记者，是因为他们掌握了长者钦点董先生的关键证据，现在这份证据落到了你的手里。这份文件是一个 $n \\times m$ 的矩形，矩形内每一个元素是一个字符串。这份文件经过了 $q$ 次加密，每次加密是交换两个长宽分别相等的矩形，由于长者有点老花眼，所以他加密的时候两个矩形间任意一对元素曼哈顿距离大于 $1$。由于好奇，你开始解密这份文件，方便起见，加密操作已经倒序给你，你只要按顺序操作一遍便能解密。当你破解完这个文件，你会发现你的生命少了做这道题的时间。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longint read() &#123; int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;&#125;const int maxn = 1010, maxm = 1000010;int n, m, q, ax, ay, bx, by, l, c, lst, tmp;int al[maxn][maxn], ar[maxn][maxn];char s[10000010];void reads(int &amp;l, int &amp;r) &#123; char c = getchar(); while (c == ' ' || c == '\\n') c = getchar(); l = ++lst, r = l - 1; while (c != ' ' &amp;&amp; c != '\\n') &#123; s[++r] = c; c = getchar(); &#125; lst = r;&#125;void prints(int l, int r) &#123; for (int i = l; i &lt;= r; i++) putchar(s[i]);&#125;struct node &#123; int x, y; node () &#123;&#125; node (int a, int b) &#123; x = a, y = b; &#125;&#125;;node au, bu, as, bs;node ex[maxn][maxn], ey[maxn][maxn];struct pair &#123; node a, b; pair () &#123;&#125; pair (node x, node y) &#123; a = x, b = y; &#125;&#125;;std::vector &lt; pair &gt; todo_ex, todo_ey;node lead_to(int x, int y) &#123; node u = node(0, 0); while (x--) u = ex[u.x][u.y]; while (y--) u = ey[u.x][u.y]; return u;&#125;void print() &#123; node u(0, 0); for (int i = 1; i &lt;= n; i++) &#123; node v = u = ex[u.x][u.y]; for (int j = 1; j &lt;= m; j++) &#123; v = ey[v.x][v.y]; prints(al[v.x][v.y], ar[v.x][v.y]); putchar(' '); &#125; putchar('\\n'); &#125;&#125;void swap_ex(node a, node b) &#123; todo_ex.push_back(pair(a, b));&#125;void swap_ey(node a, node b) &#123; todo_ey.push_back(pair(a, b));&#125;int main() &#123; n = read(), m = read(), q = read(); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) &#123; reads(al[i][j], ar[i][j]); &#125; for (int i = 0; i &lt;= n; i++) for (int j = 0; j &lt;= m; j++) &#123; ex[i][j] = node(i + 1, j); ey[i][j] = node(i, j + 1); &#125; for (int t = 1; t &lt;= q; t++) &#123; ax = read(), ay = read(); bx = read(), by = read(); l = read(), c = read(); as = lead_to(ax - 1, ay - 1); bs = lead_to(bx - 1, by - 1); au = as, bu = bs; for (int i = 1; i &lt;= l; i++) &#123; au = ex[au.x][au.y]; bu = ex[bu.x][bu.y]; swap_ey(au, bu); &#125; au = as, bu = bs; for (int i = 1; i &lt;= c; i++) &#123; au = ey[au.x][au.y]; bu = ey[bu.x][bu.y]; swap_ex(au, bu); &#125; au = as, bu = bs; for (int i = 1; i &lt;= l; i++) &#123; au = ex[au.x][au.y]; bu = ex[bu.x][bu.y]; &#125; for (int i = 1; i &lt;= c; i++) &#123; au = ey[au.x][au.y]; bu = ey[bu.x][bu.y]; swap_ex(au, bu); &#125; au = as, bu = bs; for (int i = 1; i &lt;= c; i++) &#123; au = ey[au.x][au.y]; bu = ey[bu.x][bu.y]; &#125; for (int i = 1; i &lt;= l; i++) &#123; au = ex[au.x][au.y]; bu = ex[bu.x][bu.y]; swap_ey(au, bu); &#125; for (std::vector &lt; pair &gt; ::iterator it = todo_ex.begin(); it != todo_ex.end(); it++) std::swap(ex[it-&gt;a.x][it-&gt;a.y], ex[it-&gt;b.x][it-&gt;b.y]); for (std::vector &lt; pair &gt; ::iterator it = todo_ey.begin(); it != todo_ey.end(); it++) std::swap(ey[it-&gt;a.x][it-&gt;a.y], ey[it-&gt;b.x][it-&gt;b.y]); todo_ex.clear(); todo_ey.clear(); &#125; print(); return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"https://memset0.cn/categories/Solution/"}],"tags":[{"name":"巧妙的思路","slug":"巧妙的思路","permalink":"https://memset0.cn/tags/巧妙的思路/"},{"name":"链表","slug":"链表","permalink":"https://memset0.cn/tags/链表/"}]},{"title":"洛谷4168 - [Violet]蒲公英","slug":"solution/luogu/4168","date":"2018-09-21T07:56:00.000Z","updated":"2018-10-10T12:14:53.320Z","comments":true,"path":"solution/luogu/4168/","link":"","permalink":"https://memset0.cn/solution/luogu/4168/","excerpt":"这道黑题为什么那么水 QAQ这道题在 BZOJ 上为什么又又又又又是权限题 本题求区间众数，强制在线。 对于每次查询，必定可以分为整块的和非整块的，我们先预处理出第 $i$ 块到第 $j$ 块的众数（ $max[i][j]$ ）和某个数 $i$ 在前 $j$ 个块内的前缀和（ $sum[i][j]$ ）。对于非整块的部分 $O(\\sqrt n)$ 暴力加到桶里，加上整块中的个数判断能否更新答案。然后判断 $l$ 与 $r$ 之间的块的众数是否能否更新答案。 预处理的话 $max$ 和 $sum$ 数组全都暴力扫一遍更新，时间复杂度 $O(n \\sqrt n)$，详见代码。 时间复杂度：$O(n \\sqrt n + m \\sqrt m)$","text":"这道黑题为什么那么水 QAQ这道题在 BZOJ 上为什么又又又又又是权限题 本题求区间众数，强制在线。 对于每次查询，必定可以分为整块的和非整块的，我们先预处理出第 $i$ 块到第 $j$ 块的众数（ $max[i][j]$ ）和某个数 $i$ 在前 $j$ 个块内的前缀和（ $sum[i][j]$ ）。对于非整块的部分 $O(\\sqrt n)$ 暴力加到桶里，加上整块中的个数判断能否更新答案。然后判断 $l$ 与 $r$ 之间的块的众数是否能否更新答案。 预处理的话 $max$ 和 $sum$ 数组全都暴力扫一遍更新，时间复杂度 $O(n \\sqrt n)$，详见代码。 时间复杂度：$O(n \\sqrt n + m \\sqrt m)$ 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long long#define rep(i,l,r) for (int i = l; i &lt;= r; i++)int read() &#123; int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;&#125;const int maxn = 40010, maxm = 210;int n, m, l, r, bl, br, tn, sqn, ans, now;int a[maxn], b[maxn], bln[maxn], fst[maxm], tmp[maxn];int cnt[maxn][maxm], sum[maxn][maxm], max[maxm][maxm];bool better(int x, int y, int a, int b) &#123; return (x &gt; y) || (x == y &amp;&amp; a &lt; b);&#125;int query(int l, int r) &#123; ans = 0; if (bln[l] == bln[r]) &#123; for (int i = l; i &lt;= r; i++) if (better(++tmp[a[i]], tmp[ans], a[i], ans)) ans = a[i]; for (int i = l; i &lt;= r; i++) --tmp[a[i]]; &#125; else &#123; br = bln[r] - 1, bl = bln[l]; for (int i = l; i &lt; fst[bln[l] + 1]; i++) if (better(++tmp[a[i]] + sum[a[i]][br] - sum[a[i]][bl], tmp[ans] + sum[ans][br] - sum[ans][bl], a[i], ans)) ans = a[i]; for (int i = fst[bln[r]]; i &lt;= r; i++) if (better(++tmp[a[i]] + sum[a[i]][br] - sum[a[i]][bl], tmp[ans] + sum[ans][br] - sum[ans][bl], a[i], ans)) ans = a[i]; if (better(tmp[max[bl + 1][br]] + sum[max[bl + 1][br]][br] - sum[max[bl + 1][br]][bl], tmp[ans] + sum[ans][br] - sum[ans][bl], max[bl + 1][br], ans)) ans = max[bl + 1][br]; for (int i = l; i &lt; fst[bln[l] + 1]; i++) --tmp[a[i]]; for (int i = fst[bln[r]]; i &lt;= r; i++) --tmp[a[i]]; &#125; return ans;&#125;int main() &#123; n = read(), m = read(); for (int i = 1; i &lt;= n; i++) b[i] = a[i] = read(); std::sort(b + 1, b + n + 1); tn = std::unique(b + 1, b + n + 1) - b - 1; for (int i = 1; i &lt;= n; i++) a[i] = std::lower_bound(b + 1, b + tn + 1, a[i]) - b; sqn = sqrt(n) + 1; if (sqn * sqn &lt; n) sqn++; bln[sqn + 1] = n + 1; for (int i = 1; i &lt;= n; i++) &#123; bln[i] = (i - 1) / sqn + 1; if (!fst[bln[i]]) fst[bln[i]] = i; &#125; for (int i = 1; i &lt;= n; i++) cnt[a[i]][bln[i]]++; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= sqn; j++) sum[i][j] = sum[i][j - 1] + cnt[i][j]; for (int i = 1; i &lt;= sqn; i++) &#123; memset(tmp, 0, sizeof(tmp)), now = 0; for (int j = i; j &lt;= sqn; j++) &#123; for (int k = fst[j]; k &lt; fst[j + 1]; k++) if (better(++tmp[a[k]], tmp[now], a[k], now)) now = a[k]; max[i][j] = now; &#125; &#125; for (int i = 1; i &lt;= m; i++) &#123; l = (read() + ans - 1) % n + 1; r = (read() + ans - 1) % n + 1; if (l &gt; r) std::swap(l, r); printf(\"%d\\n\", ans = b[query(l, r)]); &#125; return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"https://memset0.cn/categories/Solution/"}],"tags":[{"name":"强制在线","slug":"强制在线","permalink":"https://memset0.cn/tags/强制在线/"},{"name":"分块","slug":"分块","permalink":"https://memset0.cn/tags/分块/"}]},{"title":"洛谷2787 - 语文1（chin1）- 理理思维","slug":"solution/luogu/2787","date":"2018-09-20T11:22:00.000Z","updated":"2018-10-10T12:14:53.319Z","comments":true,"path":"solution/luogu/2787/","link":"","permalink":"https://memset0.cn/solution/luogu/2787/","excerpt":"为什么这题的名字这么奇怪？为什么这题的题解都是分块？ 好，我们讲怎么用线段树做：首先先把 $1$ 和 $2$ 两个操作用线段树维护出来（这很简单），至于排序我们直接统计区间内每个字母的数量（用操作 $1$ ），然后再直接放回去即可（用操作 $2$ ）。 以及这题大小写字母都会出现，无视即可。 时间复杂度 $O(n \\log n \\times 26)$","text":"为什么这题的名字这么奇怪？为什么这题的题解都是分块？ 好，我们讲怎么用线段树做：首先先把 $1$ 和 $2$ 两个操作用线段树维护出来（这很简单），至于排序我们直接统计区间内每个字母的数量（用操作 $1$ ），然后再直接放回去即可（用操作 $2$ ）。 以及这题大小写字母都会出现，无视即可。 时间复杂度 $O(n \\log n \\times 26)$ 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longint read() &#123; int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;&#125;int readc() &#123; char c = getchar(); while (!isupper(c) &amp;&amp; !islower(c)) c = getchar(); if (isupper(c)) return c - 'A'; return c - 'a';&#125;const int maxn = 50010;int n, m, l, r, x, opt;int a[maxn], sum[26];struct seg_node &#123; int l, r, mid; int cnt[26], tag;&#125; p[maxn &lt;&lt; 2];inline void update(int u) &#123; for (int i = 0; i &lt; 26; i++) p[u].cnt[i] = p[u &lt;&lt; 1].cnt[i] + p[u &lt;&lt; 1 | 1].cnt[i];&#125;inline void pushup(int u, int x) &#123; memset(p[u].cnt, 0, sizeof(p[u].cnt)); p[u].cnt[x] = p[u].r - p[u].l + 1; p[u].tag = x;&#125;inline void pushdown(int u) &#123; if (~p[u].tag) &#123; if (p[u].l ^ p[u].r) &#123; pushup(u &lt;&lt; 1, p[u].tag); pushup(u &lt;&lt; 1 | 1, p[u].tag); &#125; p[u].tag = -1; &#125;&#125;void build(int u, int l, int r) &#123; p[u].l = l, p[u].r = r, p[u].mid = (l + r) &gt;&gt; 1; p[u].tag = -1; if (l == r) &#123; p[u].cnt[a[l]]++; return; &#125; build(u &lt;&lt; 1, l, p[u].mid); build(u &lt;&lt; 1 | 1, p[u].mid + 1, r); update(u);&#125;void modify(int u, int l, int r, int x) &#123; pushdown(u); if (p[u].l == l &amp;&amp; p[u].r == r) &#123; pushup(u, x); return; &#125; if (r &lt;= p[u].mid) modify(u &lt;&lt; 1, l, r, x); else if (l &gt; p[u].mid) modify(u &lt;&lt; 1 | 1, l, r, x); else modify(u &lt;&lt; 1, l, p[u].mid, x), modify(u &lt;&lt; 1 | 1, p[u].mid + 1, r, x); update(u);&#125;int query(int u, int l, int r, int x) &#123; pushdown(u); if (p[u].l == l &amp;&amp; p[u].r == r) return p[u].cnt[x]; if (r &lt;= p[u].mid) return query(u &lt;&lt; 1, l, r, x); else if (l &gt; p[u].mid) return query(u &lt;&lt; 1 | 1, l, r, x); else return query(u &lt;&lt; 1, l, p[u].mid, x) + query(u &lt;&lt; 1 | 1, p[u].mid + 1, r, x);&#125;void sort(int l, int r) &#123; for (int i = 0; i &lt; 26; i++) sum[i] = query(1, l, r, i); int u = l; for (int i = 0; i &lt; 26; i++) &#123; if (sum[i]) modify(1, u, u + sum[i] - 1, i); u = u + sum[i]; &#125;&#125;int main() &#123; n = read(), m = read(); for (int i = 1; i &lt;= n; i++) a[i] = readc(); build(1, 1, n); for (int i = 1; i &lt;= m; i++) &#123; opt = read(), l = read(), r = read(); if (opt == 1) &#123; x = readc(), printf(\"%d\\n\", query(1, l, r, x)); continue; &#125; if (opt == 2) &#123; x = readc(), modify(1, l, r, x); continue; &#125; if (opt == 3) &#123; sort(l, r); continue; &#125; &#125; return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"https://memset0.cn/categories/Solution/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"https://memset0.cn/tags/线段树/"}]},{"title":"洛谷2051 - [AHOI2009]中国象棋","slug":"solution/luogu/2051","date":"2018-09-20T10:46:00.000Z","updated":"2018-10-10T12:14:53.318Z","comments":true,"path":"solution/luogu/2051/","link":"","permalink":"https://memset0.cn/solution/luogu/2051/","excerpt":"逐行 DP ，一行一行扫下去，显然之前选择的是那几列不重要，重要的是有多少列已经放了一个棋子，多少列已经放了两个棋子。 用 $f[k][i][j]$ 表示到第 $k$ 行为止，有 $i$ 行放了一个棋子， $j$ 行放了两个棋子的方案数，没放棋子的行数可以由此推出。","text":"逐行 DP ，一行一行扫下去，显然之前选择的是那几列不重要，重要的是有多少列已经放了一个棋子，多少列已经放了两个棋子。 用 $f[k][i][j]$ 表示到第 $k$ 行为止，有 $i$ 行放了一个棋子， $j$ 行放了两个棋子的方案数，没放棋子的行数可以由此推出。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;int read() &#123; int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;&#125;const int maxn = 110;const int p = 9999973;int n, m, ans;int f[maxn][maxn][maxn];ll inv2;int C(int x) &#123; return inv2 * x % p * (x - 1) % p; &#125;ll inv(ll x) &#123; if (x == 0 || x == 1) return 1; return (p - p / x) * inv(p % x) % p;&#125;int main() &#123; inv2 = inv(2); n = read(), m = read(); f[0][0][0] = 1; for (int k = 0; k &lt;= n; k++) for (int i = 0; i &lt;= m; i++) for (int j = 0; i + j &lt;= m; j++) &#123; (f[k + 1][i][j] += f[k][i][j]) %= p; (f[k + 1][i + 1][j] += 1LL * f[k][i][j] * (m - i - j) % p) %= p; (f[k + 1][i + 2][j] += 1LL * f[k][i][j] * C(m - i - j) % p) %= p; (f[k + 1][i][j + 1] += 1LL * f[k][i][j] * (m - i - j) % p * i % p) %= p; (f[k + 1][i - 1][j + 1] += 1LL * f[k][i][j] * i % p) %= p; (f[k + 1][i - 2][j + 2] += 1LL * f[k][i][j] * C(i) % p) %= p; &#125; for (int i = 0; i &lt;= m; i++) for (int j = 0; i + j &lt;= m; j++) (ans += f[n][i][j]) %= p; printf(\"%d\\n\", ans); return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"https://memset0.cn/categories/Solution/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://memset0.cn/tags/DP/"}]},{"title":"洛谷2325 - [SCOI2005]王室联邦","slug":"solution/luogu/2325","date":"2018-09-20T10:44:00.000Z","updated":"2018-10-10T12:14:53.319Z","comments":true,"path":"solution/luogu/2325/","link":"","permalink":"https://memset0.cn/solution/luogu/2325/","excerpt":"给树分块即可，为树上分块 / 树上莫队做铺垫。","text":"给树分块即可，为树上分块 / 树上莫队做铺垫。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longint read() &#123; int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;&#125;const int maxn = 1010;int n, m, u, v, pos, top;int ans[maxn], stk[maxn], center[maxn];int tot = 2, hed[maxn], nxt[maxn &lt;&lt; 1], to[maxn &lt;&lt; 1];void add_edge(int u, int v) &#123; nxt[tot] = hed[u], to[tot] = v, hed[u] = tot++; &#125;void dfs(int u, int father) &#123; int bottom = top; for (int i = hed[u], v = to[i]; i; i = nxt[i], v = to[i]) if (v != father) &#123; dfs(v, u); if (top - bottom &gt;= m) &#123; ++pos, center[pos] = u; while (top &gt; bottom) &#123; int v = stk[top--]; ans[v] = pos; &#125; &#125; &#125; stk[++top] = u;&#125;int main() &#123; n = read(), m = read(); for (int i = 1; i &lt; n; i++) &#123; u = read(), v = read(); add_edge(u, v); add_edge(v, u); &#125; dfs(1, 0); if (top) &#123; while (top) &#123; int v = stk[top--]; ans[v] = pos; &#125; &#125; printf(\"%d\\n\", pos); for (int i = 1; i &lt;= n; i++) printf(\"%d \", ans[i]); puts(\"\"); for (int i = 1; i &lt;= pos; i++) printf(\"%d \", center[i]); puts(\"\"); return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"https://memset0.cn/categories/Solution/"}],"tags":[{"name":"树分块","slug":"树分块","permalink":"https://memset0.cn/tags/树分块/"}]},{"title":"LOJ6029 - 「雅礼集训 2017 Day1」市场","slug":"solution/libreoj/6029","date":"2018-09-20T03:22:00.000Z","updated":"2018-10-10T12:14:53.318Z","comments":true,"path":"solution/libreoj/6029/","link":"","permalink":"https://memset0.cn/solution/libreoj/6029/","excerpt":"给定一个序列，要求兹滋： 区间加数、区间除以数、区间求和、区间求最小值。 其他都很简单，关键在于怎么解决区间除法。 一开始很容易想到之前的 “花神游历各国” ，但是这题并不能这样做（有区间加数），感觉线段树不可做想分块然而分块照样没法解决除法的问题。 正解则是将除法转换为减法，如果当前区间的最大值和最小值与除以除数的数的差值相同，那么把除数变成减数。 复杂度为 $O(n \\log^2 n)$ 据称可以用势能分析，但是本蒟蒻太菜了不会，因此略过 QAQ。","text":"给定一个序列，要求兹滋： 区间加数、区间除以数、区间求和、区间求最小值。 其他都很简单，关键在于怎么解决区间除法。 一开始很容易想到之前的 “花神游历各国” ，但是这题并不能这样做（有区间加数），感觉线段树不可做想分块然而分块照样没法解决除法的问题。 正解则是将除法转换为减法，如果当前区间的最大值和最小值与除以除数的数的差值相同，那么把除数变成减数。 复杂度为 $O(n \\log^2 n)$ 据称可以用势能分析，但是本蒟蒻太菜了不会，因此略过 QAQ。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longint read() &#123; int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;&#125;const int maxn = 100010;int n, m, l, r, x, opt;int a[maxn];struct seg_node &#123; int l, r, mid; ll sum, min, max, tag;&#125; p[maxn &lt;&lt; 2];inline ll divide(ll a, ll b) &#123; if (a &gt;= 0) return a / b; return (a - b + 1) / b;&#125;inline void update(int u) &#123; p[u].sum = p[u &lt;&lt; 1].sum + p[u &lt;&lt; 1 | 1].sum; p[u].max = std::max(p[u &lt;&lt; 1].max, p[u &lt;&lt; 1 | 1].max); p[u].min = std::min(p[u &lt;&lt; 1].min, p[u &lt;&lt; 1 | 1].min);&#125;inline void pushup(int u, ll x) &#123; p[u].tag += x, p[u].min += x, p[u].max += x; p[u].sum += x * (p[u].r - p[u].l + 1);&#125;inline void pushdown(int u) &#123; if (p[u].tag) &#123; if (p[u].l ^ p[u].r) &#123; pushup(u &lt;&lt; 1, p[u].tag); pushup(u &lt;&lt; 1 | 1, p[u].tag); &#125; p[u].tag = 0; &#125;&#125;void build(int u, int l, int r) &#123; p[u].l = l, p[u].r = r, p[u].mid = (l + r) &gt;&gt; 1; if (l == r) &#123; p[u].sum = p[u].min = p[u].max = a[l]; return; &#125; build(u &lt;&lt; 1, l, p[u].mid); build(u &lt;&lt; 1 | 1, p[u].mid + 1, r); update(u);&#125;void modify_sum(int u, int l, int r, ll x) &#123; pushdown(u); if (p[u].l == l &amp;&amp; p[u].r == r) &#123; pushup(u, x); return; &#125; if (r &lt;= p[u].mid) modify_sum(u &lt;&lt; 1, l, r, x); else if (l &gt; p[u].mid) modify_sum(u &lt;&lt; 1 | 1, l, r, x); else modify_sum(u &lt;&lt; 1, l, p[u].mid, x), modify_sum(u &lt;&lt; 1 | 1, p[u].mid + 1, r, x); update(u);&#125;void modify_div(int u, int l, int r, ll x) &#123; pushdown(u); if ((!p[u].min || !~p[u].min) &amp;&amp; (!p[u].max || !~p[u].max)) return; if (p[u].l == l &amp;&amp; p[u].r == r) &#123; int new_min = divide(p[u].min, x), new_max = divide(p[u].max, x); if (p[u].min - new_min == p[u].max - new_max) &#123; pushup(u, new_min - p[u].min); return; &#125; &#125; if (r &lt;= p[u].mid) modify_div(u &lt;&lt; 1, l, r, x); else if (l &gt; p[u].mid) modify_div(u &lt;&lt; 1 | 1, l, r, x); else modify_div(u &lt;&lt; 1, l, p[u].mid, x), modify_div(u &lt;&lt; 1 | 1, p[u].mid + 1, r, x); update(u);&#125;ll query_sum(int u, int l, int r) &#123; pushdown(u); if (p[u].l == l &amp;&amp; p[u].r == r) return p[u].sum; if (r &lt;= p[u].mid) return query_sum(u &lt;&lt; 1, l, r); else if (l &gt; p[u].mid) return query_sum(u &lt;&lt; 1 | 1, l, r); else return query_sum(u &lt;&lt; 1, l, p[u].mid) + query_sum(u &lt;&lt; 1 | 1, p[u].mid + 1, r);&#125;ll query_min(int u, int l, int r) &#123; pushdown(u); if (p[u].l == l &amp;&amp; p[u].r == r) return p[u].min; if (r &lt;= p[u].mid) return query_min(u &lt;&lt; 1, l, r); else if (l &gt; p[u].mid) return query_min(u &lt;&lt; 1 | 1, l, r); else return std::min(query_min(u &lt;&lt; 1, l, p[u].mid), query_min(u &lt;&lt; 1 | 1, p[u].mid + 1, r));&#125;int main() &#123; n = read(), m = read(); for (int i = 1; i &lt;= n; i++) a[i] = read(); build(1, 1, n); for (int i = 1; i &lt;= m; i++) &#123; opt = read(); if (opt == 1) &#123; l = read() + 1, r = read() + 1, x = read(); modify_sum(1, l, r, x); &#125; else if (opt == 2) &#123; l = read() + 1, r = read() + 1, x = read(); modify_div(1, l, r, x); &#125; else if (opt == 3) &#123; l = read() + 1, r = read() + 1; printf(\"%lld\\n\", query_min(1, l, r)); &#125; else &#123; l = read() + 1, r = read() + 1; printf(\"%lld\\n\", query_sum(1, l, r)); &#125; &#125; return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"https://memset0.cn/categories/Solution/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"https://memset0.cn/tags/线段树/"},{"name":"巧妙的思路","slug":"巧妙的思路","permalink":"https://memset0.cn/tags/巧妙的思路/"}]},{"title":"可持久化并查集（洛谷3402）","slug":"algorithm/可持久化并查集","date":"2018-09-18T10:33:00.000Z","updated":"2018-10-10T12:14:53.313Z","comments":true,"path":"algorithm/可持久化并查集/","link":"","permalink":"https://memset0.cn/algorithm/可持久化并查集/","excerpt":"在主席树的基础上做可持久化数组，在可持久化数组的基础上做可持久化并查集。 然而路径压缩的话数组的修改次数可能会很大，但是每次修改是 $O(\\log n)$ 的，可能会炸。所以我们要用一种类似启发式合并的方法，把小的往大的合并，这样总的复杂度是 $O(n \\log n)$ 的。 可以把并查集中的联通块看成一颗多叉树，合并时，把最深点的深度小的往大的合并，后者把树的大小小的往大的合并。笔者采用的是后者，其实原理基本是一样的。","text":"在主席树的基础上做可持久化数组，在可持久化数组的基础上做可持久化并查集。 然而路径压缩的话数组的修改次数可能会很大，但是每次修改是 $O(\\log n)$ 的，可能会炸。所以我们要用一种类似启发式合并的方法，把小的往大的合并，这样总的复杂度是 $O(n \\log n)$ 的。 可以把并查集中的联通块看成一颗多叉树，合并时，把最深点的深度小的往大的合并，后者把树的大小小的往大的合并。笔者采用的是后者，其实原理基本是一样的。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longint read() &#123; int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;&#125;const int maxn = 100010, maxm = 200010, maxl = 2200010;int n, m, u, v, k, i, pos, opt;struct pair &#123; int fa, siz; pair() &#123;&#125; pair(int a, int b) &#123; fa = a, siz = b; &#125;&#125; x, y;struct SEG &#123; int pos; int root[maxm], lc[maxl], rc[maxl], val[maxl]; bool flag; void build(int &amp;u, int l, int r) &#123; u = ++pos; if (l == r) &#123; val[u] = flag ? l : 1; return; &#125; int mid = (l + r) &gt;&gt; 1; build(lc[u], l, mid); build(rc[u], mid + 1, r); &#125; int query(int u, int l, int r, int k) &#123; if (l == r) return val[u]; int mid = (l + r) &gt;&gt; 1; if (k &lt;= mid) return query(lc[u], l, mid, k); else return query(rc[u], mid + 1, r, k); &#125; void modify(int &amp;u, int v, int l, int r, int k, int c) &#123; u = ++pos, lc[u] = lc[v], rc[u] = rc[v]; if (l == r) &#123; val[u] = c; return; &#125; int mid = (l + r) &gt;&gt; 1; if (k &lt;= mid) modify(lc[u], lc[v], l, mid, k, c); else modify(rc[u], rc[v], mid + 1, r, k, c); &#125;&#125; fa, siz;pair find(int root1, int root2, int u) &#123; int f = fa.query(root1, 1, n, u); if (u == f) return pair(f, siz.query(root2, 1, n, u)); return find(root1, root2, f);&#125;int main() &#123; n = read(), m = read(); fa.flag = 1, siz.flag = 0; fa.build(fa.root[0], 1, n); siz.build(siz.root[0], 1, n); for (i = 1; i &lt;= m; i++) &#123; fa.root[i] = fa.root[i - 1], siz.root[i] = siz.root[i - 1]; opt = read(); if (opt == 1) &#123; u = read(), v = read(); x = find(fa.root[i], siz.root[i], u); y = find(fa.root[i], siz.root[i], v); if (x.fa != y.fa) &#123; if (x.siz &gt; y.siz) std::swap(x, y); fa.modify(fa.root[i], fa.root[i - 1], 1, n, x.fa, y.fa); siz.modify(siz.root[i], siz.root[i - 1], 1, n, y.fa, x.siz + y.siz); &#125; &#125; else if (opt == 2) &#123; k = read(); fa.root[i] = fa.root[k]; siz.root[i] = siz.root[k]; &#125; else &#123; u = read(), v = read(); x = find(fa.root[i], siz.root[i], u); y = find(fa.root[i], siz.root[i], v); if (x.fa == y.fa) puts(\"1\"); else puts(\"0\"); &#125; &#125; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://memset0.cn/categories/Algorithm/"}],"tags":[{"name":"可持久化并查集","slug":"可持久化并查集","permalink":"https://memset0.cn/tags/可持久化并查集/"}]},{"title":"洛谷4768 -  [NOI2018]归程","slug":"solution/luogu/4768","date":"2018-09-18T10:26:00.000Z","updated":"2018-10-10T12:14:53.321Z","comments":true,"path":"solution/luogu/4768/","link":"","permalink":"https://memset0.cn/solution/luogu/4768/","excerpt":"真是纳闷，为什么这题在 BZOJ 上是权限题？？？ 首先你需要了解一下 这种算法，然后你在重构树上树形 DP 处理出子树中距离的最小值，最后对于每次询问倍增找出最高点回答即可。 过程就不详细说啦，相信在坐的各位大佬早就会啦。。。 不过也有 sqq 这种巨佬写了可持久化并查集 AC 了的 QAQ ，下次写写。","text":"真是纳闷，为什么这题在 BZOJ 上是权限题？？？ 首先你需要了解一下 这种算法，然后你在重构树上树形 DP 处理出子树中距离的最小值，最后对于每次询问倍增找出最高点回答即可。 过程就不详细说啦，相信在坐的各位大佬早就会啦。。。 不过也有 sqq 这种巨佬写了可持久化并查集 AC 了的 QAQ ，下次写写。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;int read() &#123; int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;&#125;const int N = 200010, N2 = 400010, N3 = 800010;int T, n, m, u, v, w, c, p, l, k, s;int fu, fv, pos, lastans;int fa[N2], f[N2][20], g[N2][20], dis[N2], lim[N2];bool vis[N];int tot, hed[N2], nxt[N3], to[N3], val[N3];struct edge &#123; int u, v, w, c; edge () &#123;&#125; edge (int _u, int _v, int _w, int _c) &#123; u = _u, v = _v, w = _w, c = _c; &#125;&#125; e[N2];bool operator &lt; (const edge &amp;a, const edge &amp;b) &#123; return a.c &gt; b.c;&#125;struct status &#123; int u, w; status () &#123;&#125; status (int _u, int _w) &#123; u = _u, w = _w; &#125;&#125;;bool operator &lt; (const status &amp;a, const status &amp;b) &#123; return a.w &gt; b.w;&#125;priority_queue &lt; status &gt; q;int find(int x) &#123; if (fa[x] == x) return x; return fa[x] = find(fa[x]);&#125;void add_edge(int u, int v, int w = 0) &#123; nxt[tot] = hed[u], to[tot] = v, val[tot] = w; hed[u] = tot++;&#125;void dfs(int u) &#123; for (int i = hed[u], v = to[i]; i; i = nxt[i], v = to[i]) if (v != f[u][0]) &#123; f[v][0] = u; g[v][0] = lim[u]; dfs(v); dis[u] = ~dis[u] &amp;&amp; dis[u] &lt; dis[v] ? dis[u] : dis[v]; &#125;&#125;void solve() &#123; n = read(), m = read(); for (int i = 1; i &lt;= m; i++) &#123; u = read(), v = read(), w = read(), c = read(); add_edge(u, v, w), add_edge(v, u, w); e[i] = edge(u, v, w, c); &#125; q.push(status(1, 0)), dis[1] = 0; while (q.size()) &#123; u = q.top().u, q.pop(); if (vis[u]) continue; vis[u] = 1; for (int i = hed[u], v = to[i]; i; i = nxt[i], v = to[i]) if (!~dis[v] || dis[u] + val[i] &lt; dis[v]) &#123; dis[v] = dis[u] + val[i]; q.push(status(v, dis[v])); &#125; &#125; sort(e + 1, e + m + 1); tot = 2, memset(hed, 0, sizeof(hed)); for (int i = 1; i &lt;= n &lt;&lt; 1; i++) fa[i] = i; for (int i = 1; i &lt;= m; i++) &#123; u = e[i].u, v = e[i].v, w = e[i].w, c = e[i].c; if ((fu = find(u)) == (fv = find(v))) continue; lim[n + (++pos)] = c, fa[fu] = fa[fv] = n + pos; add_edge(fu, n + pos), add_edge(n + pos, fu); add_edge(fv, n + pos), add_edge(n + pos, fv); &#125; dfs(n + pos); for (int i = 1; i &lt;= 19; i++) for (int j = 1; j &lt;= n &lt;&lt; 1; j++) &#123; f[j][i] = f[f[j][i - 1]][i - 1]; g[j][i] = g[f[j][i - 1]][i - 1]; &#125; p = read(), k = read(), s = read(); for (int i = 1; i &lt;= p; i++) &#123; u = (read() + k * lastans - 1) % n + 1; l = (read() + k * lastans) % (s + 1); for (int i = 19; i &gt;= 0; i--) if (f[u][i] &amp;&amp; l &lt; g[u][i]) &#123; u = f[u][i]; &#125; printf(\"%d\\n\", lastans = (~dis[u] ? dis[u] : -1)); &#125;&#125;void init() &#123; tot = 2, pos = lastans = 0; while (q.size()) q.pop(); memset(f, 0, sizeof(f)); memset(g, 0, sizeof(g)); memset(hed, 0, sizeof(hed)); memset(vis, 0, sizeof(vis)); memset(dis, -1, sizeof(dis));&#125;int main() &#123; T = read(); while (T--) &#123; init(); solve(); &#125; return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"https://memset0.cn/categories/Solution/"}],"tags":[{"name":"强制在线","slug":"强制在线","permalink":"https://memset0.cn/tags/强制在线/"},{"name":"倍增","slug":"倍增","permalink":"https://memset0.cn/tags/倍增/"},{"name":"Kruskal重构树","slug":"Kruskal重构树","permalink":"https://memset0.cn/tags/Kruskal重构树/"},{"name":"并查集","slug":"并查集","permalink":"https://memset0.cn/tags/并查集/"}]},{"title":"BZOJ4945 - [NOI2017] 游戏","slug":"solution/bzoj/4945","date":"2018-09-18T05:29:00.000Z","updated":"2018-12-09T02:10:22.586Z","comments":true,"path":"solution/bzoj/4945/","link":"","permalink":"https://memset0.cn/solution/bzoj/4945/","excerpt":"洛谷 SPJ 坏了，一个月了没修好。怎么回事啊？ UPD: QQ 群里 @ 了一下 chen_zhe 竟然很快修好了 回到正题：本题是 2-SAT 裸题，做之前可以参考一下洛谷的模板题，下面假装你已经看过并 AC 了那道题。 对于 $a$ 、 $b$ 、 $c$ 三种地图，都是不允许一辆车，而允许另外两辆。对于 $x$ 地图，显然不能交给 2-SAT 算法解决，暴力枚举他是 $a$ 地图还是 $b$ 地图（如果 $a$ 和 $b$ 都不行那么 $c$ 也不行）。 关于连边，用 $u$ 表示第 $i$ 场游戏使用赛车 $h_i$ 所对应的点，$v$ 表示 第 $j$ 场游戏赛车 $h_j$ 所对应的点，$u’$ 和 $v’$ 则表示对应地图可以使用的另一辆赛车所对应的点。 如果 $h_i$ 不符合第 $i$ 张地图的限制条件，那么这种约束肯定不会遇到，跳过即可。 如果 $h_j$ 不符合第 $j$ 张地图的限制条件，那么说明 $i$ 的这种情况肯定不能取到，就从 $u$ 向 $u’$ 连一条边。 否则说明如果取了 $h_i$ 就一定要取 $h_j$ ，连接边 $u$ 到 $v$ 和 $u’$ 到 $v’$ 即可。 另外，由于 2-SAT 要跑很多遍，所以请注意清空数组（我不会告诉你我没有清空 dfn 拿到了 $90$ 分的好成绩）。","text":"洛谷 SPJ 坏了，一个月了没修好。怎么回事啊？ UPD: QQ 群里 @ 了一下 chen_zhe 竟然很快修好了 回到正题：本题是 2-SAT 裸题，做之前可以参考一下洛谷的模板题，下面假装你已经看过并 AC 了那道题。 对于 $a$ 、 $b$ 、 $c$ 三种地图，都是不允许一辆车，而允许另外两辆。对于 $x$ 地图，显然不能交给 2-SAT 算法解决，暴力枚举他是 $a$ 地图还是 $b$ 地图（如果 $a$ 和 $b$ 都不行那么 $c$ 也不行）。 关于连边，用 $u$ 表示第 $i$ 场游戏使用赛车 $h_i$ 所对应的点，$v$ 表示 第 $j$ 场游戏赛车 $h_j$ 所对应的点，$u’$ 和 $v’$ 则表示对应地图可以使用的另一辆赛车所对应的点。 如果 $h_i$ 不符合第 $i$ 张地图的限制条件，那么这种约束肯定不会遇到，跳过即可。 如果 $h_j$ 不符合第 $j$ 张地图的限制条件，那么说明 $i$ 的这种情况肯定不能取到，就从 $u$ 向 $u’$ 连一条边。 否则说明如果取了 $h_i$ 就一定要取 $h_j$ ，连接边 $u$ 到 $v$ 和 $u’$ 到 $v’$ 即可。 另外，由于 2-SAT 要跑很多遍，所以请注意清空数组（我不会告诉你我没有清空 dfn 拿到了 $90$ 分的好成绩）。 照例上代码啦： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;int read() &#123; int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;&#125;char readc() &#123; char c = getchar(); while (c != 'A' &amp;&amp; c != 'B' &amp;&amp; c != 'C') c = getchar(); return c;&#125;const int maxn = 50010, maxm = 200010;int n, m, l, u, v, w, w1, w2, tim, top, pos;int a[maxm], b[maxm], c[maxm], d[maxm];int low[maxn &lt;&lt; 1], dfn[maxn &lt;&lt; 1], stk[maxn &lt;&lt; 1], col[maxn &lt;&lt; 1], t[10];char s[maxn];bool ins[maxn &lt;&lt; 1];int tot = 2, hed[maxn &lt;&lt; 1], to[maxm &lt;&lt; 1], nxt[maxm &lt;&lt; 1];void add_edge(int u, int v) &#123; nxt[tot] = hed[u], to[tot] = v; hed[u] = tot++;&#125;void tarjan(int u) &#123; dfn[u] = low[u] = ++tim; ins[u] = 1, stk[++top] = u; for (int i = hed[u], v = to[i]; i; i = nxt[i], v = to[i]) &#123; if (!dfn[v]) &#123; tarjan(v); low[u] = min(low[u], low[v]); &#125; else if (ins[v]) &#123; low[u] = min(low[u], dfn[v]); &#125; &#125; if (low[u] == dfn[u]) &#123; ++pos; while (top) &#123; int v = stk[top--]; ins[v] = 0; col[v] = pos; if (u == v) break; &#125; &#125;&#125;void solve() &#123; tot = 2; memset(hed, 0, sizeof(hed)); memset(dfn, 0, sizeof(dfn)); for (int i = 1; i &lt;= m; i++) &#123; u = a[i], w1 = c[i], v = b[i], w2 = d[i]; if (w1 == s[u] || (u == v &amp;&amp; w1 == w2)) continue; if (w2 == s[v] || (u == v &amp;&amp; w1 != w2)) &#123; switch (s[u]) &#123; case 'a': w1 = w1 == 'b' ? 0 : 1; break; case 'b': w1 = w1 == 'a' ? 0 : 1; break; case 'c': w1 = w1 == 'a' ? 0 : 1; break; &#125; add_edge(w1 ? u + n : u, w1 ? u : u + n); continue; &#125; switch (s[u]) &#123; case 'a': w1 = w1 == 'b' ? 0 : 1; break; case 'b': w1 = w1 == 'a' ? 0 : 1; break; case 'c': w1 = w1 == 'a' ? 0 : 1; break; &#125; switch (s[v]) &#123; case 'a': w2 = w2 == 'b' ? 0 : 1; break; case 'b': w2 = w2 == 'a' ? 0 : 1; break; case 'c': w2 = w2 == 'a' ? 0 : 1; break; &#125; add_edge(w1 ? u + n : u, w2 ? v + n : v); add_edge(w2 ? v : v + n, w1 ? u : u + n); &#125; for (int i = 1; i &lt;= (n &lt;&lt; 1); i++) if (!dfn[i]) tarjan(i); for (int i = 1; i &lt;= n; i++) if (col[i] == col[i + n]) return; for (int i = 1; i &lt;= n; i++) &#123; w = col[i] &lt; col[i + n]; switch (s[i]) &#123; case 'a': putchar(w ? 'B' : 'C'); break; case 'b': putchar(w ? 'A' : 'C'); break; case 'c': putchar(w ? 'A' : 'B'); break; &#125; &#125; putchar('\\n'); exit(0);&#125;void dfs(int k) &#123; if (k &gt; l) &#123; solve(); return; &#125; s[t[k]] = 'a', dfs(k + 1); s[t[k]] = 'b', dfs(k + 1);&#125;int main() &#123; n = read(), l = read(), scanf(\"%s\", s + 1), m = read(); for (int i = 1; i &lt;= m; i++) &#123; a[i] = read(), c[i] = readc() - 'A' + 'a'; b[i] = read(), d[i] = readc() - 'A' + 'a'; &#125; for (int i = 1; i &lt;= n; i++) if (s[i] == 'x') t[++t[0]] = i; dfs(1); printf(\"-1\\n\"); return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"https://memset0.cn/categories/Solution/"}],"tags":[{"name":"2-SAT","slug":"2-SAT","permalink":"https://memset0.cn/tags/2-SAT/"},{"name":"暴力枚举","slug":"暴力枚举","permalink":"https://memset0.cn/tags/暴力枚举/"}]},{"title":"洛谷1979 - 华容道","slug":"solution/luogu/1979","date":"2018-09-16T02:34:00.000Z","updated":"2018-10-10T12:14:53.318Z","comments":true,"path":"solution/luogu/1979/","link":"","permalink":"https://memset0.cn/solution/luogu/1979/","excerpt":"一道经典的搜索题。由于棋子没必要也不可能和非空格的棋子交换，目标棋子也只可能通过与空格交换位置达到目标位置，因此我们只需要存储空格和目标棋子的位置即可。这样爆搜即可拿到 $80$ 分。 接着考虑能否继续优化：每次目标棋子改变位置空格必须在他旁边，因此存储除了初始状态和终止状态外的空格不在目标棋子旁边的状态没有意义。因此我们可以用 BFS 处理出状态之间转移的代价，然后用 SPFA 等最短路算法跑一遍即可。本题由于状态个数和状态之间的边不多，正常常数的 SPFA 不会被卡掉。 需要注意的是：在使用 BFS 搜索空格转移代价时不能经过目标棋子。算法时间复杂度：$O(n^4)$","text":"一道经典的搜索题。由于棋子没必要也不可能和非空格的棋子交换，目标棋子也只可能通过与空格交换位置达到目标位置，因此我们只需要存储空格和目标棋子的位置即可。这样爆搜即可拿到 $80$ 分。 接着考虑能否继续优化：每次目标棋子改变位置空格必须在他旁边，因此存储除了初始状态和终止状态外的空格不在目标棋子旁边的状态没有意义。因此我们可以用 BFS 处理出状态之间转移的代价，然后用 SPFA 等最短路算法跑一遍即可。本题由于状态个数和状态之间的边不多，正常常数的 SPFA 不会被卡掉。 需要注意的是：在使用 BFS 搜索空格转移代价时不能经过目标棋子。算法时间复杂度：$O(n^4)$ 代码（出于某些原因我写的比较长，其实很短的 QAQ）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;int read() &#123; int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;&#125;namespace wyl &#123; const int maxn = 32; const int mov[4][2] = &#123; &#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;, &#125;; int n, m, p, u, v, l, r; int x, y, x1, x2, y1, y2; int s, e, sx, sy, ex, ey, tx, ty; int pos; int a[35][35], id[35][35][35][35], dis[1000000]; int q[10000000]; bool inq[1000000], vis[35][35]; struct status &#123; int x, y, stp; status () &#123;&#125; status (int a, int b, int c) &#123; x = a, y = b, stp = c; &#125; &#125; q0[10000000]; int tot = 2, tmptot, hed[1000000], tmphed[1000000], to[8000000], nxt[8000000], val[8000000]; void add_edge(int u, int v, int w) &#123; if (!~w) return; nxt[tot] = hed[u], to[tot] = v, val[tot] = w; hed[u] = tot++; &#125; int bfs(int sx, int sy, int ex, int ey, int kx, int ky) &#123; if (sx == ex &amp;&amp; sy == ey) return 0; status u, v; memset(vis, 0, sizeof(vis)); l = r = 1; q0[1] = status(sx, sy, 0); vis[sx][sy] = vis[kx][ky] = 1; while (l &lt;= r) &#123; u = q0[l++]; for (int t = 0; t &lt; 4; t++) &#123; v.x = u.x + mov[t][0]; v.y = u.y + mov[t][1]; v.stp = u.stp + 1; if ((!a[v.x][v.y]) &amp;&amp; !vis[v.x][v.y]) &#123; if (v.x == ex &amp;&amp; v.y == ey) &#123; return v.stp; &#125; vis[v.x][v.y] = 1; q0[++r] = v; &#125; &#125; &#125; return -1; &#125; int spfa(int s, int e) &#123; memset(dis, -1, sizeof(dis)); l = r = 1, q[1] = s, dis[s] = 0, inq[s] = 1; while (l &lt;= r) &#123; u = q[l++], inq[u] = 0; for (int i = hed[u]; i; i = nxt[i]) &#123; int v = to[i]; if (!~dis[v] || dis[v] &gt; dis[u] + val[i]) &#123; dis[v] = dis[u] + val[i]; if (!inq[v]) &#123; q[++r] = v; inq[v] = 1; &#125; &#125; &#125; &#125; return dis[e]; &#125; int main() &#123; n = read(), m = read(), p = read(); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) a[i][j] = read() ^ 1; for (int i = 0; i &lt;= n + 1; i++) a[i][0] = a[i][m + 1] = 1; for (int i = 0; i &lt;= m + 1; i++) a[0][i] = a[n + 1][i] = 1; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) if (!a[i][j]) &#123; for (int t = 0; t &lt; 4; t++) &#123; x = i + mov[t][0]; y = j + mov[t][1]; if (!a[x][y]) &#123; id[i][j][x][y] = ++pos; &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) if (!a[i][j]) &#123; for (int t = 0; t &lt; 4; t++) &#123; x = i + mov[t][0]; y = j + mov[t][1]; if (!a[x][y]) add_edge(id[i][j][x][y], id[x][y][i][j], 1); &#125; for (int t1 = 0; t1 &lt; 4; t1++) &#123; x1 = i + mov[t1][0]; y1 = j + mov[t1][1]; if (!a[x1][y1]) for (int t2 = 0; t2 &lt; 4; t2++) if (t1 ^ t2) &#123; x2 = i + mov[t2][0]; y2 = j + mov[t2][1]; if (!a[x2][y2]) add_edge(id[i][j][x1][y1], id[i][j][x2][y2], bfs(x1, y1, x2, y2, i, j)); &#125; &#125; &#125; tmptot = tot; memcpy(tmphed, hed, sizeof(hed)); while (p--) &#123; tot = tmptot; memcpy(hed, tmphed, sizeof(hed)); tx = read(), ty = read(), sx = read(), sy = read(), ex = read(), ey = read(); s = ++pos, e = ++pos; if (sx == ex &amp;&amp; sy == ey) &#123; puts(\"0\"); continue; &#125; for (int t = 0; t &lt; 4; t++) &#123; x = sx + mov[t][0]; y = sy + mov[t][1]; if (id[sx][sy][x][y]) &#123; add_edge(s, id[sx][sy][x][y], bfs(tx, ty, x, y, sx, sy)); &#125; &#125; for (int t = 0; t &lt; 4; t++) &#123; x = ex + mov[t][0]; y = ey + mov[t][1]; if (id[ex][ey][x][y]) &#123; add_edge(id[ex][ey][x][y], e, 0); &#125; &#125; printf(\"%d\\n\", spfa(s, e)); pos -= 2; &#125; return 0; &#125;&#125; int main() &#123; return wyl::main();&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"https://memset0.cn/categories/Solution/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"https://memset0.cn/tags/搜索/"}]},{"title":"洛谷2783 - 有机化学之神偶尔会做作弊","slug":"solution/luogu/2783","date":"2018-09-16T00:21:00.000Z","updated":"2018-10-10T12:14:53.319Z","comments":true,"path":"solution/luogu/2783/","link":"","permalink":"https://memset0.cn/solution/luogu/2783/","excerpt":"又是一道非常水的黑题。给你一个双向图，你需要代替炎魔之王拉格纳罗斯（？？？）会净化图中的所有环，也就是除了链以外的强连通分量，成为一颗无根树。然后询问树上距离。","text":"又是一道非常水的黑题。给你一个双向图，你需要代替炎魔之王拉格纳罗斯（？？？）会净化图中的所有环，也就是除了链以外的强连通分量，成为一颗无根树。然后询问树上距离。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;int read() &#123; int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;&#125;const int maxn = 10010, maxm = 50010;int n, m, q, u, v;int tim, pos, top;int dfn[maxn], low[maxn], id[maxn], stk[maxn], f[maxn][20], dep[maxn];bool ins[maxn];int tot = 2, hed[maxn], nxt[maxm &lt;&lt; 1], to[maxm &lt;&lt; 1];struct edge &#123; int u, v; edge () &#123;&#125; edge (int a, int b) &#123; u = a, v = b; &#125;&#125; e[maxm];void tarjan(int u, int fa) &#123; dfn[u] = low[u] = ++tim; stk[++top] = u, ins[u] = 1; for (int i = hed[u]; i; i = nxt[i]) &#123; int v = to[i]; if (v == fa) continue; if (!dfn[v]) &#123; tarjan(v, u); low[u] = min(low[u], low[v]); &#125; else if (ins[v]) &#123; low[u] = min(low[u], dfn[v]); &#125; &#125; if (dfn[u] == low[u]) &#123; ++pos; while (top) &#123; int v = stk[top--]; id[v] = pos; if (u == v) break; &#125; &#125;&#125;void dfs(int u) &#123; for (int i = hed[u]; i; i = nxt[i]) &#123; int v = to[i]; if (v != f[u][0] &amp;&amp; !dep[v]) &#123; f[v][0] = u; dep[v] = dep[u] + 1; dfs(v); &#125; &#125;&#125;int lca(int u, int v) &#123; if (dep[u] &gt; dep[v]) swap(u, v); for (int i = 19; i &gt;= 0; i--) if (dep[f[v][i]] &gt;= dep[u] &amp;&amp; f[v][i]) v = f[v][i]; if (u == v) return u; for (int i = 19; i &gt;= 0; i--) if (f[u][i] != f[v][i] &amp;&amp; f[u][i] &amp;&amp; f[v][i]) u = f[u][i], v = f[v][i]; return f[u][0];&#125;void print(int x) &#123; if (x &gt; 1) print(x &gt;&gt; 1); putchar((x &amp; 1) + '0');&#125;int main() &#123; n = read(), m = read(); for (int i = 1; i &lt;= m; i++) &#123; u = read(), v = read(); e[i] = edge(u, v); nxt[tot] = hed[u], to[tot] = v, hed[u] = tot++; nxt[tot] = hed[v], to[tot] = u, hed[v] = tot++; &#125; for (int i = 1; i &lt;= n; i++) if (!dfn[i]) tarjan(i, -1); tot = 2, memset(hed, 0, sizeof(hed)); for (int i = 1; i &lt;= m; i++) &#123; u = id[e[i].u], v = id[e[i].v]; if (u ^ v) &#123; nxt[tot] = hed[u], to[tot] = v, hed[u] = tot++; nxt[tot] = hed[v], to[tot] = u, hed[v] = tot++; &#125; &#125; dep[1] = 1, dfs(1); for (int i = 1; i &lt; 20; i++) for (int j = 1; j &lt;= pos; j++) f[j][i] = f[f[j][i - 1]][i - 1]; q = read(); for (int i = 1; i &lt;= q; i++) &#123; u = id[read()], v = id[read()]; print(dep[u] + dep[v] - (dep[lca(u, v)] &lt;&lt; 1) + 1); putchar('\\n'); &#125; return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"https://memset0.cn/categories/Solution/"}],"tags":[{"name":"缩点","slug":"缩点","permalink":"https://memset0.cn/tags/缩点/"},{"name":"Tarjan","slug":"Tarjan","permalink":"https://memset0.cn/tags/Tarjan/"}]},{"title":"BZOJ3211 - 花神游历各国","slug":"solution/bzoj/3211","date":"2018-09-15T14:46:00.000Z","updated":"2018-12-09T02:04:54.759Z","comments":true,"path":"solution/bzoj/3211/","link":"","permalink":"https://memset0.cn/solution/bzoj/3211/","excerpt":"已知每个数最多能被开方而减小的次数是有限的，当当前的数是 $0$ 或 $1$ 时就没有必要操作。 所以我们可以用线段树维护区间最大值，如果当前的最大值已经等于 $0$ 或 $1$ ，就无需操作，否则逐个修改。 复杂度 $O(n \\sqrt {10^9} \\log n)$ ，可过。 区间取模操作同理。 理论上来说资瓷区间开方 / 取模和单点修改，算是优美的暴力吧。 多倍经验（数据范围和要求略有不同）： BZOJ3211 - 花神游历各国 洛谷4145 - 上帝造题的七分钟2 / 花神游历各国 SPOJ2713 - GSS4 - Can you answer these queries IV","text":"已知每个数最多能被开方而减小的次数是有限的，当当前的数是 $0$ 或 $1$ 时就没有必要操作。 所以我们可以用线段树维护区间最大值，如果当前的最大值已经等于 $0$ 或 $1$ ，就无需操作，否则逐个修改。 复杂度 $O(n \\sqrt {10^9} \\log n)$ ，可过。 区间取模操作同理。 理论上来说资瓷区间开方 / 取模和单点修改，算是优美的暴力吧。 多倍经验（数据范围和要求略有不同）： BZOJ3211 - 花神游历各国 洛谷4145 - 上帝造题的七分钟2 / 花神游历各国 SPOJ2713 - GSS4 - Can you answer these queries IV 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std; ll read() &#123; ll x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;&#125; const int maxn = 100010;int n, m, l, r, opt;ll a[maxn]; struct node &#123; int l, r, mid; ll sum, max;&#125; p[maxn &lt;&lt; 2]; void build(int l, int r, int u = 1) &#123; p[u].l = l, p[u].r = r, p[u].mid = (l + r) &gt;&gt; 1; if (l == r) &#123; if (a[l] == 0) &#123; p[u].max = 1, p[u].sum = 0; &#125; else p[u].max = p[u].sum = a[l]; return; &#125; build(l, p[u].mid, u &lt;&lt; 1); build(p[u].mid + 1, r, u &lt;&lt; 1 | 1); p[u].sum = p[u &lt;&lt; 1].sum + p[u &lt;&lt; 1 | 1].sum; p[u].max = max(p[u &lt;&lt; 1].max, p[u &lt;&lt; 1 | 1].max);&#125; void modify(int l, int r, int u = 1) &#123; if (p[u].max == 1) &#123; return; &#125; if (p[u].l == p[u].r) &#123; p[u].sum = p[u].max = sqrt(p[u].sum); return; &#125; if (r &lt;= p[u].mid) modify(l, r, u &lt;&lt; 1); else if (l &gt; p[u].mid) modify(l, r, u &lt;&lt; 1 | 1); else modify(l, p[u].mid, u &lt;&lt; 1), modify(p[u].mid + 1, r, u &lt;&lt; 1 | 1); p[u].sum = p[u &lt;&lt; 1].sum + p[u &lt;&lt; 1 | 1].sum; p[u].max = max(p[u &lt;&lt; 1].max, p[u &lt;&lt; 1 | 1].max);&#125; ll query(int l, int r, int u = 1) &#123; if (p[u].l == l &amp;&amp; p[u].r == r) &#123; return p[u].sum; &#125; if (r &lt;= p[u].mid) return query(l, r, u &lt;&lt; 1); else if (l &gt; p[u].mid) return query(l, r, u &lt;&lt; 1 | 1); else return query(l, p[u].mid, u &lt;&lt; 1) + query(p[u].mid + 1, r, u &lt;&lt; 1 | 1);&#125; int main() &#123; n = read(); for (int i = 1; i &lt;= n; i++) a[i] = read(); build(1, n); m = read(); for (int i = 1; i &lt;= m; i++) &#123; opt = read(), l = read(), r = read(); if (l &gt; r) swap(l, r); if (opt == 2) &#123; modify(l, r); &#125; else &#123; printf(\"%lld\\n\", query(l, r)); &#125; &#125; return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"https://memset0.cn/categories/Solution/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"https://memset0.cn/tags/线段树/"},{"name":"巧妙的思路","slug":"巧妙的思路","permalink":"https://memset0.cn/tags/巧妙的思路/"}]},{"title":"洛谷也能 Material 化？","slug":"geek/luogu-material","date":"2018-09-11T09:51:57.000Z","updated":"2018-10-10T12:14:53.315Z","comments":true,"path":"geek/luogu-material/","link":"","permalink":"https://memset0.cn/geek/luogu-material/","excerpt":"","text":"大佬 abc2237512422 的洛谷美化脚本推荐： 使用方式： 搜索安装 Stylus （或 Stylish ）的浏览器插件。 打开 https://userstyles.org/styles/157651/material-luogu-material 并安装。 还可在上面的网页进行个性化设置打造自己最喜欢的洛谷样式 qwq.","categories":[{"name":"Geek","slug":"Geek","permalink":"https://memset0.cn/categories/Geek/"}],"tags":[{"name":"美化","slug":"美化","permalink":"https://memset0.cn/tags/美化/"}]},{"title":"SPOJ2666 - QTREE4 - Query on a tree IV","slug":"solution/spoj/2666","date":"2018-09-11T09:31:23.000Z","updated":"2018-10-10T12:14:53.321Z","comments":true,"path":"solution/spoj/2666/","link":"","permalink":"https://memset0.cn/solution/spoj/2666/","excerpt":"我在学习点分治时，一直卡在这道题，今天我一鼓作气想尽办法终于把她 AC 了。 将要讲述的方法是动态点分治，有另一种链分治的方法个人感觉较为麻烦且不自然就不在此赘述。 首先静态点分治一遍建立点分树，并算出初始答案，存储每个节点作为重心时到上一个节点的边。当动态修改时从底层向上逐层修改直到抵达根节点。 对于每个节点，我们存储每个子树中距离最远的点（用 son 维护）和距离当前节点距离最远的点（用 hep 维护），最后再维护一个答案堆 ans 供查询。这个堆要资瓷添加和删除操作，可以用经典的建两个堆的方法，一个插入，一个删除即可。 其他当前子树中没有白色时应该返回 $-inf$ ，否则与当前子树的根节点是白色节点时等价的 qwq。","text":"我在学习点分治时，一直卡在这道题，今天我一鼓作气想尽办法终于把她 AC 了。 将要讲述的方法是动态点分治，有另一种链分治的方法个人感觉较为麻烦且不自然就不在此赘述。 首先静态点分治一遍建立点分树，并算出初始答案，存储每个节点作为重心时到上一个节点的边。当动态修改时从底层向上逐层修改直到抵达根节点。 对于每个节点，我们存储每个子树中距离最远的点（用 son 维护）和距离当前节点距离最远的点（用 hep 维护），最后再维护一个答案堆 ans 供查询。这个堆要资瓷添加和删除操作，可以用经典的建两个堆的方法，一个插入，一个删除即可。 其他当前子树中没有白色时应该返回 $-inf$ ，否则与当前子树的根节点是白色节点时等价的 qwq。 如上，下面上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longint read() &#123; int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;&#125;char readc() &#123; char c = getchar(); while (c != 'A' &amp;&amp; c != 'C') c = getchar(); return c;&#125;const int maxn = 100010, maxm = 200010;const int inf = 1e9;int n, m, u, v, k, w, cnt, a[maxn];int core, root, from, full;int max[maxn], siz[maxn], vis[maxn], pre[maxn], old[maxm];std::vector &lt; int &gt; vec[maxn], dis[maxn];struct Heap &#123; std::priority_queue &lt; int &gt; ins, del; void update() &#123; while (ins.size() &amp;&amp; del.size()) if (ins.top() == del.top()) &#123; ins.pop(), del.pop(); &#125; else break; &#125; void push(int x) &#123; ins.push(x); &#125; void pop(int x) &#123; del.push(x); update(); &#125; int top() &#123; update(); return ins.size() ? ins.top() : -inf; &#125; int size() &#123; return ins.size() - del.size(); &#125; int query() &#123; if (size() &lt; 2) return 0; int tmp1 = top(); pop(tmp1); int tmp2 = top(); push(tmp1); return std::max(tmp1 + tmp2, 0); &#125;&#125; ans, hep[maxn], son[maxm];int tot = 2, hed[maxn], nxt[maxm], to[maxm], val[maxm];void add_edge(int u, int v, int w) &#123; nxt[tot] = hed[u], to[tot] = v, val[tot] = w; hed[u] = tot++;&#125;void dfs(int u, int father, int udis) &#123; max[u] = 0, siz[u] = 1; if (~from) &#123; vec[u].push_back(from); dis[u].push_back(udis); son[from].push(udis); &#125; for (int i = hed[u], v = to[i]; i; i = nxt[i], v = to[i]) if (v != father &amp;&amp; !vis[v]) &#123; dfs(v, u, udis + val[i]); siz[u] += siz[v]; max[u] = std::max(max[u], siz[v]); &#125; max[u] = std::max(max[u], full - siz[u]); if (max[core] &gt; max[u]) core = u;&#125;void solve(int u, int father) &#123; vis[u] = true; for (int i = hed[u], v = to[i]; i; i = nxt[i], v = to[i]) if (v != father &amp;&amp; !vis[v]) &#123; core = 0, full = siz[v], from = i, max[core] = inf; dfs(v, u, 0); pre[core] = i; solve(core, u); hep[u].push(son[i].top() + val[i]); old[i] = son[i].top(); &#125; hep[u].push(0); ans.push(hep[u].query());&#125;void insert(int u) &#123; ans.pop(hep[u].query()); hep[u].push(0); ans.push(hep[u].query()); for (int i = 0; i &lt; (int)vec[u].size(); i++) son[vec[u][i]].push(dis[u][i]); for (int i = pre[u]; ~i; i = pre[u]) &#123; u = to[i ^ 1]; if (old[i] ^ son[i].top()) &#123; ans.pop(hep[u].query()); hep[u].pop(old[i] + val[i]); hep[u].push(son[i].top() + val[i]); ans.push(hep[u].query()); old[i] = son[i].top(); &#125; &#125;&#125;void erase(int u) &#123; ans.pop(hep[u].query()); hep[u].pop(0); ans.push(hep[u].query()); for (int i = 0; i &lt; (int)vec[u].size(); i++) son[vec[u][i]].pop(dis[u][i]); for (int i = pre[u]; ~i; i = pre[u]) &#123; u = to[i ^ 1]; if (old[i] ^ son[i].top()) &#123; ans.pop(hep[u].query()); hep[u].pop(old[i] + val[i]); hep[u].push(son[i].top() + val[i]); ans.push(hep[u].query()); old[i] = son[i].top(); &#125; &#125; &#125;int main() &#123; n = read(); for (int i = 1; i &lt; n; i++) &#123; u = read(), v = read(), w = read(); add_edge(u, v, w); add_edge(v, u, w); &#125; max[0] = inf, full = n, from = -1; dfs(1, 0, 0); pre[core] = -1; solve(core, 0); m = read(); cnt = n; for (int i = 1; i &lt;= m; i++) &#123; if (readc() == 'A') &#123; if (cnt) printf(\"%d\\n\", (cnt - 1) &amp;&amp; ans.size() ? ans.top() : 0); else printf(\"They have disappeared.\\n\"); &#125; else &#123; k = read(); if (a[k]) &#123; cnt++, a[k] = 0; insert(k); &#125; else &#123; cnt--, a[k] = 1; erase(k); &#125; &#125; &#125; return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"https://memset0.cn/categories/Solution/"}],"tags":[{"name":"点分治","slug":"点分治","permalink":"https://memset0.cn/tags/点分治/"},{"name":"动态点分治","slug":"动态点分治","permalink":"https://memset0.cn/tags/动态点分治/"}]},{"title":"洛谷4826 - [USACO15FEB]Superbull 超级牛","slug":"solution/luogu/4826","date":"2018-09-10T05:49:11.000Z","updated":"2018-10-10T12:14:53.321Z","comments":true,"path":"solution/luogu/4826/","link":"","permalink":"https://memset0.cn/solution/luogu/4826/","excerpt":"把淘汰赛问题转换为一棵生成树，每一条边相当于一个二选一淘汰的过程。","text":"把淘汰赛问题转换为一棵生成树，每一条边相当于一个二选一淘汰的过程。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;ll read() &#123; ll x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;&#125;const int maxn = 2010;ll n, cnt, ans;ll a[maxn], fa[maxn];struct edge &#123; ll u, v, w; edge () &#123;&#125; edge (ll a, ll b, ll c) &#123; u = a, v = b, w = c; &#125;&#125; e[2000010];bool operator &lt; (edge a, edge b) &#123; return a.w &gt; b.w;&#125;ll find(ll x) &#123; if (fa[x] == x) return x; return fa[x] = find(fa[x]);&#125;int main() &#123; n = read(); for (int i = 1; i &lt;= n; i++) a[i] = read(); for (int i = 1; i &lt;= n; i++) for (int j = i + 1; j &lt;= n; j++) e[++cnt] = edge(i, j, a[i] ^ a[j]); sort(e + 1, e + cnt + 1); for (int i = 1; i &lt;= n; i++) fa[i] = i; for (int i = 1; i &lt;= cnt; i++) if (find(e[i].u) != find(e[i].v)) &#123; fa[find(e[i].u)] = find(e[i].v); ans += e[i].w; &#125; printf(\"%lld\\n\", ans); return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"https://memset0.cn/categories/Solution/"}],"tags":[{"name":"巧妙的思路","slug":"巧妙的思路","permalink":"https://memset0.cn/tags/巧妙的思路/"},{"name":"最小生成树","slug":"最小生成树","permalink":"https://memset0.cn/tags/最小生成树/"}]},{"title":"洛谷3810 - 【模板】三维偏序（陌上花开）","slug":"solution/luogu/3810","date":"2018-09-10T05:13:41.000Z","updated":"2018-10-10T12:14:53.320Z","comments":true,"path":"solution/luogu/3810/","link":"","permalink":"https://memset0.cn/solution/luogu/3810/","excerpt":"三维偏序，一维一维解决：第一维排序，第二维 CDQ ，第三维树状数组（或 CDQ ）。 先按照 $a$ 进行排序，考虑 CDQ ，先分治左右两边，使得左右两边的节点都按 $b$ 排序，于是依次从两边取（优先 $b$ ， $b$ 相等优先 $c$），左边的取出时在树状数组中更新，右边的取出时从树状数组中查询，考虑贡献。 需要注意的是，$a$ 、 $b$ 、 $c$ 的值都相同的节点有可能互相产生贡献，很难用 CDQ 解决，于是可以将这些点缩为一个，并单独计算他们内部互相产生的贡献。","text":"三维偏序，一维一维解决：第一维排序，第二维 CDQ ，第三维树状数组（或 CDQ ）。 先按照 $a$ 进行排序，考虑 CDQ ，先分治左右两边，使得左右两边的节点都按 $b$ 排序，于是依次从两边取（优先 $b$ ， $b$ 相等优先 $c$），左边的取出时在树状数组中更新，右边的取出时从树状数组中查询，考虑贡献。 需要注意的是，$a$ 、 $b$ 、 $c$ 的值都相同的节点有可能互相产生贡献，很难用 CDQ 解决，于是可以将这些点缩为一个，并单独计算他们内部互相产生的贡献。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;int read() &#123; int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;&#125;const int maxn = 100010;int n, m, p;int ans[maxn], sum[maxn &lt;&lt; 1], cnt[maxn];struct node &#123; int a, b, c, i, s;&#125; e[maxn], t[maxn];bool operator == (node a, node b) &#123; return a.a == b.a &amp;&amp; a.b == b.b &amp;&amp; a.c == b.c;&#125;bool cmp1(node a, node b) &#123; if (a.a != b.a) return a.a &lt; b.a; if (a.b != b.b) return a.b &lt; b.b; return a.c &lt; b.c;&#125;#define lowbit(x) ((x)&amp;(-(x)))void add(int k, int x) &#123; for (int i = k; i &lt;= m; i += lowbit(i)) sum[i] += x;&#125;int ask(int k) &#123; int ans = 0; for (int i = k; i &gt;= 1; i -= lowbit(i)) ans += sum[i]; return ans;&#125;void solve(int l, int r) &#123; int mid = (l + r) &gt;&gt; 1; if (l == r) return; solve(l, mid); // 先分治解决左右两边 solve(mid + 1, r); // 在计算左边对右边的贡献 int L = l, R = mid + 1, T = 0; while (L &lt;= mid &amp;&amp; R &lt;= r) &#123; if (e[L].b &lt; e[R].b || (e[L].b == e[R].b &amp;&amp; e[L].c &lt;= e[R].c)) &#123; add(e[L].c, e[L].s); t[++T] = e[L++]; &#125; else &#123; ans[e[R].i] += ask(e[R].c); t[++T] = e[R++]; &#125; &#125; while (L &lt;= mid) t[++T] = e[L++]; while (R &lt;= r) &#123; ans[e[R].i] += ask(e[R].c); t[++T] = e[R++]; &#125; L = l, R = mid + 1; while (L &lt;= mid &amp;&amp; R &lt;= r) &#123; if (e[L].b &lt; e[R].b || (e[L].b == e[R].b &amp;&amp; e[L].c &lt;= e[R].c)) &#123; add(e[L].c, -e[L].s); L++; &#125; else R++; &#125; for (int i = 1; i &lt;= T; i++) e[l + i - 1] = t[i];&#125;int main() &#123; n = read(), m = read(); for (int i = 1; i &lt;= n; i++) e[i].a = read(), e[i].b = read(), e[i].c = read(), e[i].i = i, e[i].s = 1; sort(e + 1, e + n + 1, cmp1); p = 1; for (int i = 2; i &lt;= n; i++) if (e[i] == e[i - 1]) e[p].s++; else e[++p] = e[i]; swap(n, p); solve(1, n); // 进行 CDQ for (int i = 1; i &lt;= n; i++) ans[e[i].i] += e[i].s - 1; for (int i = 1; i &lt;= n; i++) cnt[ans[e[i].i]] += e[i].s; for (int i = 0; i &lt; p; i++) printf(\"%d\\n\", cnt[i]); return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"https://memset0.cn/categories/Solution/"}],"tags":[{"name":"CDQ 分治","slug":"CDQ-分治","permalink":"https://memset0.cn/tags/CDQ-分治/"}]},{"title":"洛谷3980 - [NOI2008]志愿者招募","slug":"solution/luogu/3980","date":"2018-09-10T05:09:00.000Z","updated":"2018-10-10T12:14:53.320Z","comments":true,"path":"solution/luogu/3980/","link":"","permalink":"https://memset0.cn/solution/luogu/3980/","excerpt":"巧妙的使用满流的特性解决问题。 对每一天，连一条容量为 $INF - 需求人数$ 的边，对于补充的人连一条容量为 $INF$ ，花费为价格的边。 对这个图跑最小费用最大流，其中最大流一定是 $INF$ ，最小费用即答案。","text":"巧妙的使用满流的特性解决问题。 对每一天，连一条容量为 $INF - 需求人数$ 的边，对于补充的人连一条容量为 $INF$ ，花费为价格的边。 对这个图跑最小费用最大流，其中最大流一定是 $INF$ ，最小费用即答案。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;int read() &#123; int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;&#125;const int maxn = 11010, maxm = 45010, inf = 1e9;int n, m, u, v, l, r, x, e, s;int flow, cost, max_flow, min_cost;int pre[maxn], dis[maxn], q[maxn * maxn], inq[maxn];int tot = 2, hed[maxn], nxt[maxm], to[maxm], val[maxm], cst[maxm];void add_simple_edge(int u, int v, int w, int c) &#123; nxt[tot] = hed[u], to[tot] = v, val[tot] = w, cst[tot] = c; hed[u] = tot++;&#125;void add_edge(int u, int v, int w, int c) &#123; add_simple_edge(u, v, w, c); add_simple_edge(v, u, 0, -c);&#125;bool spfa() &#123; memset(dis, -1, sizeof(dis)); memset(pre, 0, sizeof(pre)); l = r = 1, q[1] = s, dis[s] = 0, inq[s] = 1; while (l &lt;= r) &#123; u = q[l++], inq[u] = 0; for (int i = hed[u]; i; i = nxt[i]) if (val[i]) &#123; v = to[i]; if (dis[v] == -1 || dis[u] + cst[i] &lt; dis[v]) &#123; dis[v] = dis[u] + cst[i]; pre[v] = i; if (!inq[v]) &#123; inq[v] = 1; q[++r] = v; &#125; &#125; &#125; &#125; return pre[e];&#125;int main() &#123; n = read(), m = read(); for (int i = 1; i &lt;= n; i++) &#123; x = read(); add_edge(i, i + 1, inf - x, 0); &#125; for (int i = 1; i &lt;= m; i++) &#123; l = read(), r = read(), x = read(); add_edge(l, r + 1, inf, x); &#125; s = n + 2, e = n + 3; add_edge(s, 1, inf, 0); add_edge(n + 1, e, inf, 0); while (spfa()) &#123; flow = inf, cost = 0; for (int i = pre[e]; i; i = pre[to[i ^ 1]]) flow = min(flow, val[i]); for (int i = pre[e]; i; i = pre[to[i ^ 1]]) val[i] -= flow, val[i ^ 1] += flow; for (int i = pre[e]; i; i = pre[to[i ^ 1]]) cost += cst[i] * flow; max_flow += flow, min_cost += cost; &#125; printf(\"%d\\n\", min_cost); return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"https://memset0.cn/categories/Solution/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"https://memset0.cn/tags/网络流/"},{"name":"最小费用最大流","slug":"最小费用最大流","permalink":"https://memset0.cn/tags/最小费用最大流/"},{"name":"满流","slug":"满流","permalink":"https://memset0.cn/tags/满流/"}]},{"title":"洛谷1631 - 序列合并（及这一类题目）","slug":"solution/luogu/1631","date":"2018-09-07T12:49:54.000Z","updated":"2018-10-10T12:14:53.318Z","comments":true,"path":"solution/luogu/1631/","link":"","permalink":"https://memset0.cn/solution/luogu/1631/","excerpt":"先把 $A$ 的第一个数与 $B$ 的每一个相加放堆去，保留所选的数的下标。 此时堆中有 $(1, 1)$ ~ $(n, 1)$。 循环 $n$ 次： 取最小的并输出，假设下标为 $(i, j)$，这个一定和题意 放入 $(i + 1, j)$ 即可。","text":"先把 $A$ 的第一个数与 $B$ 的每一个相加放堆去，保留所选的数的下标。 此时堆中有 $(1, 1)$ ~ $(n, 1)$。 循环 $n$ 次： 取最小的并输出，假设下标为 $(i, j)$，这个一定和题意 放入 $(i + 1, j)$ 即可。 没有代码。 有一道相关题目 https://www.luogu.org/recordnew/show/10515004 。","categories":[{"name":"Solution","slug":"Solution","permalink":"https://memset0.cn/categories/Solution/"}],"tags":[{"name":"堆","slug":"堆","permalink":"https://memset0.cn/tags/堆/"}]},{"title":"开学啦","slug":"diary/开学啦","date":"2018-09-07T12:16:43.000Z","updated":"2018-10-10T12:14:53.315Z","comments":true,"path":"diary/开学啦/","link":"","permalink":"https://memset0.cn/diary/开学啦/","excerpt":"呃，好像开学了。。。 不要问为什么迟了一周来写，开学考暑假作业什么的搞起来真的很累啊！！！","text":"呃，好像开学了。。。 不要问为什么迟了一周来写，开学考暑假作业什么的搞起来真的很累啊！！！ 考试暑假作业啥都没做，回来基本就考试。 其他同学比我多复习一周（那周我在集训），一回来就是一种“怀旧空吟闻笛赋，到乡翻似烂柯人”的感觉。 据称理论上来说考试内容基于暑假作业： 好啊于是我物理啥都不会（生化没学的都没怎么考物理全是没学的 于是只能蒙公式：是的我连公式都没看过 好像蒙出来了几个然而并没什么用。 数学还是好的，就是感觉有点简单了。 有个地方粗心了，还有个地方感觉老师批卷标准很迷？？？ 勉强混了个年级 rank 1 滚粗。 语文不知道什么鬼 我复习了那么多遍古诗，古文默了三四遍（全篇） 然而总共六道古诗题，名著阅读挂了一堆 呵呵。。。 英语，呵呵。。。 文综，批卷标准有点神奇？ 有的太宽有的太严 以及我们文综老师说：“xxx（判断题）按照高中知识来说应该是判错的，然而。。。” qaq我判错为什么要扣我分 作业重新分班了，老师全换了 新的老师都很好，作业很少很少很少 基本第一节晚自修之前都能做完 然后就去信奥机房浪 老师有时很想念原来的班主任 某天还哭了（逃 同学出于某些原因，要和同学们暂时分别了 还是有点伤心的吧，很惦记一些同学 分别之前没什么，分别之后真的很伤心的 哎~ 信奥现在基本一半时间花在冲 NOIP 上吧 题目 AC 数争取超过 chen_zhe 啊！","categories":[{"name":"Diary","slug":"Diary","permalink":"https://memset0.cn/categories/Diary/"}],"tags":[{"name":"日记","slug":"日记","permalink":"https://memset0.cn/tags/日记/"}]},{"title":"洛谷2387 - [NOI2014]魔法森林","slug":"solution/luogu/2387","date":"2018-08-30T10:04:24.000Z","updated":"2018-10-10T12:14:53.319Z","comments":true,"path":"solution/luogu/2387/","link":"","permalink":"https://memset0.cn/solution/luogu/2387/","excerpt":"题意可以理解为找到一条 $1$ 到 $n$ 的路径，使得其中 $a$ 的最大值和 $b$ 的最大值之和最小。 我们可以先按照 $a$ 的值排序，然后使用 LCT 维护关于 $b$ 的最小生成树；算法的正确性很容易证明：对于每一个 $a$ 的最大值我们都取到了 $b$ 的最大值的最小值。 维护动态最小生成树：对于新加的边 $(u, v)$ ，如果已经连接，则需要断掉其中最大的一条（当前的 $b$ 值比最大的 $b$ 值还大就不用加了），否则无脑 link 。所以我们的 LCT 还要存储下最大的边以及对应的编号。 由于 LCT 只能维护点不能维护边，我们可以考虑化边为点，总共有 $n$ 个 LCT 中的点表示实际意义的点，以及 $m$ 的 LCT 中的点表示实际意义的边。这样子瞎搞即可。 注意一定要当 $1$ 和 $n$ 已经联通时才能用当前的状态尝试更新答案哦！","text":"题意可以理解为找到一条 $1$ 到 $n$ 的路径，使得其中 $a$ 的最大值和 $b$ 的最大值之和最小。 我们可以先按照 $a$ 的值排序，然后使用 LCT 维护关于 $b$ 的最小生成树；算法的正确性很容易证明：对于每一个 $a$ 的最大值我们都取到了 $b$ 的最大值的最小值。 维护动态最小生成树：对于新加的边 $(u, v)$ ，如果已经连接，则需要断掉其中最大的一条（当前的 $b$ 值比最大的 $b$ 值还大就不用加了），否则无脑 link 。所以我们的 LCT 还要存储下最大的边以及对应的编号。 由于 LCT 只能维护点不能维护边，我们可以考虑化边为点，总共有 $n$ 个 LCT 中的点表示实际意义的点，以及 $m$ 的 LCT 中的点表示实际意义的边。这样子瞎搞即可。 注意一定要当 $1$ 和 $n$ 已经联通时才能用当前的状态尝试更新答案哦！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longint read() &#123; int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;&#125;const int maxn = 50010, maxm = 100010, maxp = 150010;int n, m, u, v, a, b, t, ans = 1e9;int fa[maxp], ch[maxp][2], max[maxp], pto[maxp], lazy[maxp], val[maxp];struct edge &#123; int u, v, a, b;&#125; g[maxm];bool cmp(edge a, edge b) &#123; return a.a &lt; b.a;&#125;bool is_root(int x) &#123; return ch[fa[x]][0] != x &amp;&amp; ch[fa[x]][1] != x; &#125;bool get_son(int x) &#123; return ch[fa[x]][1] == x; &#125;void update(int x) &#123; max[x] = val[x], pto[x] = x; if (ch[x][0] &amp;&amp; max[pto[ch[x][0]]] &gt; max[pto[x]]) pto[x] = pto[ch[x][0]]; if (ch[x][1] &amp;&amp; max[pto[ch[x][1]]] &gt; max[pto[x]]) pto[x] = pto[ch[x][1]];&#125;void rotate(int x) &#123; if (!x || !fa[x]) return; int f = fa[x], fson = get_son(x); int ff = fa[f], ffson = get_son(f); int y = ch[x][fson ^ 1]; if (!is_root(f)) ch[ff][ffson] = x; fa[y] = f, fa[f] = x, fa[x] = ff; ch[f][fson] = y, ch[x][fson ^ 1] = f; update(f), update(x);&#125;void clean_up(int x) &#123; if (!is_root(x)) clean_up(fa[x]); if (lazy[x]) &#123; std::swap(ch[x][0], ch[x][1]); lazy[ch[x][0]] ^= 1; lazy[ch[x][1]] ^= 1; lazy[x] = 0; &#125;&#125;void splay(int x) &#123; clean_up(x); while (!is_root(x)) &#123; int f = fa[x]; if (!is_root(f)) &#123; if (get_son(x) ^ get_son(f)) rotate(x); else rotate(f); &#125; rotate(x); &#125; update(x);&#125;void access(int x) &#123; for (int y = 0; x; y = x, x = fa[x]) splay(x), ch[x][1] = y, update(x);&#125;void mroot(int x) &#123; access(x), splay(x); lazy[x] ^= 1;&#125;void select(int u, int v) &#123; mroot(u), access(v), splay(v);&#125;int get_root(int x) &#123; access(x), splay(x); while (ch[x][0]) x = ch[x][0]; return x;&#125;void link(int u, int v) &#123; mroot(u); fa[u] = v;&#125;void cut(int u, int v) &#123; select(u, v); fa[u] = ch[v][0] = 0; update(v);&#125;int main() &#123; n = read(), m = read(); for (int i = 1; i &lt;= m; i++) &#123; g[i].u = read(), g[i].v = read(); g[i].a = read(), g[i].b = read(); &#125; std::sort(g + 1, g + m + 1, cmp); for (int i = 1; i &lt;= m; i++) val[n + i] = g[i].b; for (int i = 1; i &lt;= m; i++) &#123; u = g[i].u, v = g[i].v; a = g[i].a, b = g[i].b; if (get_root(u) == get_root(v)) &#123; select(u, v), t = pto[v]; if (max[t] &gt; b) &#123; cut(g[t - n].u, t); cut(t, g[t - n].v); link(u, i + n); link(i + n, v); &#125; &#125; else &#123; link(u, i + n); link(i + n, v); &#125; if (get_root(1) == get_root(n)) &#123; select(1, n); ans = std::min(ans, a + max[pto[n]]); &#125; &#125; printf(\"%d\\n\", ans == 1e9 ? -1 : ans); return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"https://memset0.cn/categories/Solution/"}],"tags":[{"name":"LCT","slug":"LCT","permalink":"https://memset0.cn/tags/LCT/"},{"name":"最小生成树","slug":"最小生成树","permalink":"https://memset0.cn/tags/最小生成树/"}]},{"title":"洛谷3285 - [SCOI2014]方伯伯的OJ","slug":"solution/luogu/3285","date":"2018-08-30T09:56:45.000Z","updated":"2018-10-10T12:14:53.320Z","comments":true,"path":"solution/luogu/3285/","link":"","permalink":"https://memset0.cn/solution/luogu/3285/","excerpt":"本题的 $n$ 特别大，如果直接开那么大的空间，想必会直接超时。所以我们可以先把所有“用户”合并成一个点，需要访问到哪个就进行分裂。这样的话 $m$ 次操作每次都只会分裂一次，时间复杂度就能保证在 $O(m\\log m)$ ，空间也不会炸。 另外本题只有提到最前面和提到最后面两种操作，使用平衡树的必要不大，用动态开点线段树就好了。 p.s. 感觉 Leafy Tree 和这个好像啊 (=’w’​=)","text":"本题的 $n$ 特别大，如果直接开那么大的空间，想必会直接超时。所以我们可以先把所有“用户”合并成一个点，需要访问到哪个就进行分裂。这样的话 $m$ 次操作每次都只会分裂一次，时间复杂度就能保证在 $O(m\\log m)$ ，空间也不会炸。 另外本题只有提到最前面和提到最后面两种操作，使用平衡树的必要不大，用动态开点线段树就好了。 p.s. 感觉 Leafy Tree 和这个好像啊 (=’w’​=) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longint read() &#123; int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;&#125;const int maxn = 100010;int n, m, x, y, k, u, cnt, opt, tmp, last, left_side, right_side;std::map &lt; int, int &gt; mp;struct node &#123; int value, size; node *l, *r; node() &#123; value = size = 0; l = r = NULL; &#125; node (int a, int b, node *c, node *d) &#123; value = a, size = b; l = c, r = d; &#125;&#125; *root, *null, *st[maxn &lt;&lt; 6], t[maxn &lt;&lt; 6];int get_size(int l, int r) &#123; return std::max(std::min(r, n) - std::max(1, l) + 1, 0);&#125;node *newnode(int l, int r) &#123; cnt++; if (l == r) t[cnt] = node(l, (1 &lt;= l &amp;&amp; l &lt;= n ? 1 : 0), null, null); else t[cnt] = node(0, get_size(l, r), null, null); return st[cnt] = &amp;t[cnt];&#125;int query(int k, int l, int r, node *&amp;u) &#123; if (u == null) u = newnode(l, r); if (l == r) return u-&gt;value; int mid = (l + r) &gt;&gt; 1; int left_size = (u-&gt;l == null) ? get_size(l, mid) : u-&gt;l-&gt;size; if (k &lt;= left_size) return query(k, l, mid, u-&gt;l); return query(k - left_size, mid + 1, r, u-&gt;r);&#125;int rank(int x, int l, int r, node *&amp;u) &#123; if (u == null) u = newnode(l, r); if (l == r) return 1; int mid = (l + r) &gt;&gt; 1; if (x &lt;= mid) return rank(x, l, mid, u-&gt;l); return rank(x, mid + 1, r, u-&gt;r) + ((u-&gt;l == null) ? get_size(l, mid) : u-&gt;l-&gt;size);&#125;void modify(int x, int y, int l, int r, node *&amp;u) &#123; if (u == null) u = newnode(l, r); if (l == r) &#123; u-&gt;value = y; return; &#125; int mid = (l + r) &gt;&gt; 1; if (x &lt;= mid) modify(x, y, l, mid, u-&gt;l); else modify(x, y, mid + 1, r, u-&gt;r);&#125;void update(int x, int y, int z, int l, int r, node *&amp;u) &#123; if (u == null) u = newnode(l, r); u-&gt;size += y; if (l == r) &#123; u-&gt;value = z; return; &#125; int mid = (l + r) &gt;&gt; 1; if (x &lt;= mid) update(x, y, z, l, mid, u-&gt;l); else update(x, y, z, mid + 1, r, u-&gt;r);&#125;int main() &#123; n = read(), m = read(); for (int i = 0; i &lt; (maxn &lt;&lt; 6); i++) st[i] = &amp;t[i]; null = new node(0, 0, null, null); root = new node(0, n, null, null); left_side = 1, right_side = n; for (int i = 1; i &lt;= m; i++) &#123; opt = read(); if (opt == 1) &#123; x = read() - last, y = read() - last; k = mp.find(x) != mp.end() ? mp[x] : x; printf(\"%d\\n\", last = rank(k, -m, n + m, root)); modify(k, y, -m, n + m, root); mp.erase(x), mp[y] = k; &#125; else if (opt == 2) &#123; x = read() - last, k = mp.find(x) != mp.end() ? mp[x] : x; printf(\"%d\\n\", last = rank(k, -m, n + m, root)); update(k, -1, -1, -m, n + m, root); update(mp[x] = --left_side, 1, x, -m, n + m, root); &#125; else if (opt == 3) &#123; x = read() - last, k = mp.find(x) != mp.end() ? mp[x] : x; printf(\"%d\\n\", last = rank(k, -m, n + m, root)); update(k, -1, -1, -m, n + m, root); update(mp[x] = ++right_side, 1, x, -m, n + m, root); &#125; else if (opt == 4) &#123; k = read() - last; printf(\"%d\\n\", last = query(k, -m, n + m, root)); &#125; &#125; return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"https://memset0.cn/categories/Solution/"}],"tags":[{"name":"平衡树","slug":"平衡树","permalink":"https://memset0.cn/tags/平衡树/"},{"name":"线段树","slug":"线段树","permalink":"https://memset0.cn/tags/线段树/"},{"name":"动态开点线段树","slug":"动态开点线段树","permalink":"https://memset0.cn/tags/动态开点线段树/"}]},{"title":"洛谷4767 - [IOI2000]邮局","slug":"solution/luogu/4767","date":"2018-08-26T14:35:55.000Z","updated":"2018-10-10T12:14:53.321Z","comments":true,"path":"solution/luogu/4767/","link":"","permalink":"https://memset0.cn/solution/luogu/4767/","excerpt":"非常简单的四边形不等式优化模板题。 （一）首先考虑 $O(n^2 \\times m)$ 的做法，先将 $a$ 数组排序，假设 $f[i][j]$ 表示前 $i$ 个村庄中设立 $j$ 个邮局，可以列出转移方程： $$f[i][j] = min(f[i][j], f[k][j - 1] + dis(k + 1, i))$$ 其中 $dis(l, r)$ 表示在 $l$ 到 $r$ 的区间中建立一个邮局所对答案产生的贡献，利用人类智慧可知把邮局建在中间花费最少。 （二）在进行四边形不等式优化之前，我们先考虑如何在 $O(1)$ 的时间复杂度内求出 $dis(l, r)$： 在暴力做法中，我们需要枚举 $l$ 到 $r$ 之间的数，去其与中间的村庄的距离差的绝对值，代码大概如下： 12for (int i = l; i &lt;= r; i++) ans += abs(a[i] - a[mid]); 由于 $a$ 数组是有序的，我们可知在 $mid$ 左面的村庄 $abs(a_i - a_{mid}) = a_{mid} - a_i$，右边的村庄 $abs(a_i - a_{mid}) = a_i - a_{mid}$ 。那么通过前缀和即可在 $O(1)$ 的时间复杂度内求出。 （三）四边形不等式优化必须满足： $$f[a][c]+f[b][d]&lt;=f[b][c]+f[a][d]$$ 且决策单调。 本题可以通过打表等方法证明成立，那么 $f[i][j]$ 的状态只能从 $f[i][j - 1]$ 到 $f[i + 1][j]$ 的决策中选择一个进行转移。","text":"非常简单的四边形不等式优化模板题。 （一）首先考虑 $O(n^2 \\times m)$ 的做法，先将 $a$ 数组排序，假设 $f[i][j]$ 表示前 $i$ 个村庄中设立 $j$ 个邮局，可以列出转移方程： $$f[i][j] = min(f[i][j], f[k][j - 1] + dis(k + 1, i))$$ 其中 $dis(l, r)$ 表示在 $l$ 到 $r$ 的区间中建立一个邮局所对答案产生的贡献，利用人类智慧可知把邮局建在中间花费最少。 （二）在进行四边形不等式优化之前，我们先考虑如何在 $O(1)$ 的时间复杂度内求出 $dis(l, r)$： 在暴力做法中，我们需要枚举 $l$ 到 $r$ 之间的数，去其与中间的村庄的距离差的绝对值，代码大概如下： 12for (int i = l; i &lt;= r; i++) ans += abs(a[i] - a[mid]); 由于 $a$ 数组是有序的，我们可知在 $mid$ 左面的村庄 $abs(a_i - a_{mid}) = a_{mid} - a_i$，右边的村庄 $abs(a_i - a_{mid}) = a_i - a_{mid}$ 。那么通过前缀和即可在 $O(1)$ 的时间复杂度内求出。 （三）四边形不等式优化必须满足： $$f[a][c]+f[b][d]&lt;=f[b][c]+f[a][d]$$ 且决策单调。 本题可以通过打表等方法证明成立，那么 $f[i][j]$ 的状态只能从 $f[i][j - 1]$ 到 $f[i + 1][j]$ 的决策中选择一个进行转移。 （四）代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;int read() &#123; int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;&#125;const int maxn = 3010, maxm = 310;int n, m;int a[maxn];int s[maxn][maxn];int f[maxn][maxn];int dis[maxn][maxn];int tran[maxn][maxn];int main() &#123; memset(f, 0x3f, sizeof(f)); n = read(), m = read(); for (int i = 1; i &lt;= n; i++) a[i] = read(); sort(a + 1, a + n + 1); for (int i = 1; i &lt;= n; i++) for (int j = i; j &lt;= n; j++) s[i][j] = s[i][j - 1] + a[j]; for (int l = 1; l &lt;= n; l++) for (int r = l; r &lt;= n; r++) &#123; int mid = (l + r) &gt;&gt; 1; dis[l][r] += (mid - l) * a[mid] - s[l][mid - 1]; dis[l][r] += s[mid + 1][r] - (r - mid) * a[mid]; &#125; for (int i = 1; i &lt;= n; i++) f[i][1] = dis[1][i]; for (int j = 2; j &lt;= m; j++) &#123; tran[n + 1][j] = n; for (int i = n; i &gt;= 1; i--) &#123; for (int k = tran[i][j - 1]; k &lt;= tran[i + 1][j]; k++) if (f[k][j - 1] + dis[k + 1][i] &lt; f[i][j]) &#123; f[i][j] = f[k][j - 1] + dis[k + 1][i]; tran[i][j] = k; &#125; &#125; &#125; printf(\"%d\\n\", f[n][m]); return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"https://memset0.cn/categories/Solution/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://memset0.cn/tags/DP/"},{"name":"四边形不等式优化","slug":"四边形不等式优化","permalink":"https://memset0.cn/tags/四边形不等式优化/"}]},{"title":"洛谷2600 - [ZJOI2008]瞭望塔","slug":"solution/luogu/2600","date":"2018-08-21T13:59:53.000Z","updated":"2018-10-10T12:14:53.319Z","comments":true,"path":"solution/luogu/2600/","link":"","permalink":"https://memset0.cn/solution/luogu/2600/","excerpt":"三分即可。calc(x, y)函数求在点 $(x, y)$ 建造灯塔的最低高度。 时间复杂度 $O(n ^ 2 \\times \\texttt{某个大常数})$ 。","text":"三分即可。calc(x, y)函数求在点 $(x, y)$ 建造灯塔的最低高度。 时间复杂度 $O(n ^ 2 \\times \\texttt{某个大常数})$ 。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;int read() &#123; int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;&#125;const int maxn = 310;int n;double mid, ans = 1e200, lbound, rbound, lmid, rmid;double x[maxn], y[maxn], k[maxn], b[maxn];double calc(double x, double y) &#123; double ans = 0; for (int i = 1; i &lt; n; i++) ans = max(ans, x * k[i] + b[i] - y); return ans;&#125;int main() &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) scanf(\"%lf\", &amp;x[i]); for (int i = 1; i &lt;= n; i++) scanf(\"%lf\", &amp;y[i]); for (int i = 1; i &lt; n; i++) &#123; k[i] = (y[i + 1] - y[i]) / (x[i + 1] - x[i]); b[i] = y[i] - x[i] * k[i]; &#125; for (int i = 1; i &lt; n; i++) &#123; lbound = x[i]; rbound = x[i + 1]; for (int t = 100; t; t--) &#123; lmid = lbound + (rbound - lbound) / 3; rmid = rbound - (rbound - lbound) / 3; if (calc(lmid, lmid * k[i] + b[i]) &lt; calc(rmid, rmid * k[i] + b[i])) rbound = rmid; else lbound = lmid; &#125; mid = (lbound + rbound) / 2; ans = min(ans, calc(mid, mid * k[i] + b[i])); &#125; printf(\"%.3lf\\n\", ans); return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"https://memset0.cn/categories/Solution/"}],"tags":[{"name":"三分法","slug":"三分法","permalink":"https://memset0.cn/tags/三分法/"}]},{"title":"CF702E - Analysis of Pathes in Functional Graph","slug":"solution/codeforces/702e","date":"2018-08-21T03:41:09.000Z","updated":"2018-10-10T12:14:53.317Z","comments":true,"path":"solution/codeforces/702e/","link":"","permalink":"https://memset0.cn/solution/codeforces/702e/","excerpt":"倍增，处理出每个点往后 $2^i$ 的点、和、最大值，然后倍增乱搞即可。复杂度 $O(n log k)$ ，可过。 需要注意的是 $k$ 是 $10^{10}$ ，需要开 long long。","text":"倍增，处理出每个点往后 $2^i$ 的点、和、最大值，然后倍增乱搞即可。复杂度 $O(n log k)$ ，可过。 需要注意的是 $k$ 是 $10^{10}$ ，需要开 long long。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;int read() &#123; int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;&#125;ll readll() &#123; ll x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;&#125;const int maxn = 100010;const ll inf = 3e18;int n, u;ll k, stp, ans1, ans2;ll mi2[40], f[maxn][35], f1[maxn][35], f2[maxn][35];int main() &#123; n = read(), k = readll(); for (int i = 1; i &lt;= n; i++) f[i][0] = (read() + 1); for (int i = 1; i &lt;= n; i++) f1[i][0] = f2[i][0] = read(); mi2[0] = 1; for (int i = 1; i &lt; 35; i++) mi2[i] = mi2[i - 1] &lt;&lt; 1; for (int i = 1; i &lt; 35; i++) for (int j = 1; j &lt;= n; j++) &#123; f[j][i] = f[f[j][i - 1]][i - 1]; f1[j][i] = f1[f[j][i - 1]][i - 1] + f1[j][i - 1]; f2[j][i] = min(f2[f[j][i - 1]][i - 1], f2[j][i - 1]); &#125; for (int now = 1; now &lt;= n; now++) &#123; u = now, stp = k, ans1 = 0, ans2 = inf; for (int i = 34; i &gt;= 0; i--) if (stp - mi2[i] &gt;= 0) &#123; stp -= mi2[i]; ans1 = ans1 + f1[u][i]; ans2 = min(ans2, f2[u][i]); u = f[u][i]; &#125; printf(\"%lld %lld\\n\", ans1, ans2); &#125; return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"https://memset0.cn/categories/Solution/"}],"tags":[{"name":"倍增","slug":"倍增","permalink":"https://memset0.cn/tags/倍增/"}]},{"title":"洛谷4514 - 上帝造题的七分钟","slug":"solution/luogu/4514","date":"2018-08-20T12:12:36.000Z","updated":"2018-10-10T12:14:53.321Z","comments":true,"path":"solution/luogu/4514/","link":"","permalink":"https://memset0.cn/solution/luogu/4514/","excerpt":"丢一发友链就跑 https://www.cnblogs.com/xuanyi/p/9010816.html qaq。","text":"丢一发友链就跑 https://www.cnblogs.com/xuanyi/p/9010816.html qaq。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;int read() &#123; int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;&#125;char readc() &#123; char c = getchar(); while (!isupper(c) &amp;&amp; !islower(c) &amp;&amp; c != EOF) c = getchar(); return c;&#125;#define lowbit(x) ((x)&amp;(-(x)))const int maxn = 3010;int n, m, a, b, c, d, x, ans;int s[4][maxn][maxn];char opt;void modify(int a, int b, int x) &#123; for (int i = a; i &lt;= n; i += lowbit(i)) for (int j = b; j &lt;= m; j += lowbit(j)) &#123; s[0][i][j] += x; s[1][i][j] += x * a; s[2][i][j] += x * b; s[3][i][j] += x * a * b; &#125;&#125;int query(int a, int b) &#123; int ans = 0; for (int i = a; i; i -= lowbit(i)) for (int j = b; j; j -= lowbit(j)) &#123; ans += s[0][i][j] * a * b; ans -= s[1][i][j] * b; ans -= s[2][i][j] * a; ans += s[3][i][j]; &#125; return ans;&#125;int main() &#123; n = read(), m = read(); while ((opt = readc()) != EOF) &#123; if (opt == 'L') &#123; a = read(), b = read(), c = read(), d = read(), x = read(); modify(a, b, x); modify(a, d + 1, -x); modify(c + 1, b, -x); modify(c + 1, d + 1, x); &#125; else &#123; a = read(), b = read(), c = read(), d = read(), ans = 0; ans += query(a, b); ans -= query(a, d + 1); ans -= query(c + 1, b); ans += query(c + 1, d + 1); printf(\"%d\\n\", ans); &#125; &#125; return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"https://memset0.cn/categories/Solution/"}],"tags":[{"name":"树状数组","slug":"树状数组","permalink":"https://memset0.cn/tags/树状数组/"}]},{"title":"UVA1220 - Party at Hali-Bula","slug":"solution/uva/1220","date":"2018-08-20T09:56:04.000Z","updated":"2018-10-10T12:14:53.321Z","comments":true,"path":"solution/uva/1220/","link":"","permalink":"https://memset0.cn/solution/uva/1220/","excerpt":"用 $f[i][0]$ 表示 $i$ 不选所能取到的最大值， $f[i][1]$ 表示选 $i$ 能取到的最大值。 假设当前节点为 $u$ ，孩子节点为 $v$ ，则： $f[u][0] = \\sum max(f[v][0], f[v][1])$ $f[u][1] = \\sum f[v][0]$ 关于判断是否有多种情况：我们无需存种树，只要存是否即可，用数组 $d$ 表示，则： 如果当前节点 $u$ 更新状态选中的来自 $v$ 的某个状态存在多种，那么 $u$ 的这个状态也存在多种。 如果 $u$ 节点的某个孩子 $v$ 满足 $f[v][0] == f[v][1]$ ，那么 $f[u][0]$ 存在多种。","text":"用 $f[i][0]$ 表示 $i$ 不选所能取到的最大值， $f[i][1]$ 表示选 $i$ 能取到的最大值。 假设当前节点为 $u$ ，孩子节点为 $v$ ，则： $f[u][0] = \\sum max(f[v][0], f[v][1])$ $f[u][1] = \\sum f[v][0]$ 关于判断是否有多种情况：我们无需存种树，只要存是否即可，用数组 $d$ 表示，则： 如果当前节点 $u$ 更新状态选中的来自 $v$ 的某个状态存在多种，那么 $u$ 的这个状态也存在多种。 如果 $u$ 节点的某个孩子 $v$ 满足 $f[v][0] == f[v][1]$ ，那么 $f[u][0]$ 存在多种。 代码注意读入方式！！！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int maxn = 210;int n, id, f[maxn][2], d[maxn][2];int tot, hed[maxn], nxt[maxn &lt;&lt; 1], to[maxn &lt;&lt; 1];string a, b;bool more_ans;map &lt; string, int &gt; p;int init() &#123; id = 0; tot = 2; more_ans = false; memset(hed, 0, sizeof(hed)); memset(f, 0, sizeof(f)); memset(d, 0, sizeof(d)); p.clear(); cin &gt;&gt; n; return n;&#125;void add_edge(int u, int v) &#123; nxt[tot] = hed[u], to[tot] = v, hed[u] = tot++; nxt[tot] = hed[v], to[tot] = u, hed[v] = tot++;&#125;void dfs(int u, int father) &#123; f[u][0] = 0, f[u][1] = 1; for (int i = hed[u], v = to[i]; i; i = nxt[i], v = to[i]) if (v != father) &#123; dfs(v, u); f[u][0] += max(f[v][0], f[v][1]); if ((f[v][0] &gt; f[v][1] &amp;&amp; d[v][0]) || (f[v][0] &lt; f[v][1] &amp;&amp; d[v][1]) || (f[v][0] == f[v][1])) d[u][0] = 1; f[u][1] += f[v][0]; if (d[v][0]) d[u][1] = 1; &#125;&#125;int main() &#123; ios::sync_with_stdio(false); while (init() != 0) &#123; cin &gt;&gt; a, p[a] = id = 1; for (int i = 2; i &lt;= n; i++) &#123; cin &gt;&gt; a &gt;&gt; b; if (!p[a]) p[a] = ++id; if (!p[b]) p[b] = ++id; add_edge(p[a], p[b]); &#125; dfs(1, 0); printf(\"%d %s\\n\", max(f[1][0], f[1][1]), (f[1][0] == f[1][1]) || (f[1][0] &gt; f[1][1] &amp;&amp; d[1][0]) || (f[1][0] &lt; f[1][1] &amp;&amp; d[1][1]) ? \"No\" : \"Yes\"); &#125; return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"https://memset0.cn/categories/Solution/"}],"tags":[{"name":"树形DP","slug":"树形DP","permalink":"https://memset0.cn/tags/树形DP/"}]},{"title":"洛谷3701 -「伪模板」主席树","slug":"solution/luogu/3701","date":"2018-08-20T02:19:00.000Z","updated":"2018-10-10T12:14:53.320Z","comments":true,"path":"solution/luogu/3701/","link":"","permalink":"https://memset0.cn/solution/luogu/3701/","excerpt":"去他妈的NOI难度 从 $S$ 到 byx 的每个人连条容量为生命的边，从手气君的每个人到 $E$ 连条容量为生命的边；如果 byx 的这个人能打赢对方的某个人连一条容量为 $1$ 的边，$+1s$ 的话直接加到生命里，最后跑一遍最大流即可。","text":"去他妈的NOI难度 从 $S$ 到 byx 的每个人连条容量为生命的边，从手气君的每个人到 $E$ 连条容量为生命的边；如果 byx 的这个人能打赢对方的某个人连一条容量为 $1$ 的边，$+1s$ 的话直接加到生命里，最后跑一遍最大流即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;int read() &#123; int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;&#125;int readc() &#123; char c = getchar(), t; while (!isupper(c)) c = getchar(); t = getchar(); while (isupper(t)) t = getchar(); return c;&#125;const int maxn = 2010, maxm = 100010;int n, m, ans, cnt;struct people &#123; char kind; int health;&#125; a[maxn], b[maxn];int tot = 2, hed[maxn], nxt[maxm], to[maxm], val[maxm];void add_edge(int u, int v, int w) &#123; nxt[tot] = hed[u]; to[tot] = v; val[tot] = w; hed[u] = tot++; nxt[tot] = hed[v]; to[tot] = u; val[tot] = 0; hed[v] = tot++;&#125;const int inf = 2e9 + 7;int u, s, e, flag, flow;int cur[maxn], pre[maxn], dep[maxn], gap[maxn];#define v (to[i])int max_flow() &#123; int ans = 0; for (int i = 1; i &lt;= e; i++) cur[i] = hed[i]; u = s, pre[u] = 0, gap[0] = e; while (dep[u] &lt; e) &#123; flag = 0; for (int &amp;i = cur[u]; i; i = nxt[i]) if (val[i] &amp;&amp; dep[u] == dep[v] + 1) &#123; u = v; pre[v] = i; flag = 1; break; &#125; if (!flag) &#123; if (!--gap[dep[u]]) break; dep[u] = e; for (int i = hed[u]; i; i = nxt[i]) if (val[i] &amp;&amp; dep[v] + 1 &lt; dep[u]) &#123; dep[u] = dep[v] + 1; cur[u] = i; &#125; ++gap[dep[u]]; if (u != s) u = to[pre[u] ^ 1]; &#125; if (u == e) &#123; flow = inf; for (int i = pre[e]; i; i = pre[to[i ^ 1]]) flow = min(flow, val[i]); for (int i = pre[e]; i; i = pre[to[i ^ 1]]) val[i] -= flow, val[i ^ 1] += flow; ans += flow; u = s; &#125; &#125; return ans;&#125;#undef vint main() &#123; n = read(), m = read(); for (int i = 1; i &lt;= n; i++) a[i].kind = readc(); for (int i = 1; i &lt;= n; i++) b[i].kind = readc(); for (int i = 1; i &lt;= n; i++) a[i].health = read(); for (int i = 1; i &lt;= n; i++) b[i].health = read(); cnt = 0; for (int i = 1; i &lt;= n; i++) if (a[i].kind == 'Y') cnt++; for (int i = 1; i &lt;= n; i++) if (a[i].kind == 'J') a[i].health += cnt; cnt = 0; for (int i = 1; i &lt;= n; i++) if (b[i].kind == 'Y') cnt++; for (int i = 1; i &lt;= n; i++) if (b[i].kind == 'J') b[i].health += cnt; s = (n &lt;&lt; 1) + 1, e = (n + 1) &lt;&lt; 1; for (int i = 1; i &lt;= n; i++) add_edge(s, i, a[i].health); for (int i = 1; i &lt;= n; i++) add_edge(i + n, e, b[i].health); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) &#123;#define A (a[i].kind)#define B (b[j].kind) if ((A == 'W' &amp;&amp; (B == 'E' || B == 'Y')) || (A == 'J' &amp;&amp; (B == 'H' || B == 'W')) || (A == 'E' &amp;&amp; (B == 'Y' || B == 'J')) || (A == 'Y' &amp;&amp; (B == 'H' || B == 'J')) || (A == 'H' &amp;&amp; (B == 'W' || B == 'E'))) add_edge(i, j + n, 1);#undef A#undef B &#125; ans = min(max_flow(), m); printf(\"%d\\n\", ans); return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"https://memset0.cn/categories/Solution/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"https://memset0.cn/tags/网络流/"},{"name":"最大流","slug":"最大流","permalink":"https://memset0.cn/tags/最大流/"}]},{"title":"树状数组 区间修改 & 区间查询（LOJ132）","slug":"algorithm/树状数组","date":"2018-08-19T14:13:21.000Z","updated":"2018-10-10T12:14:53.314Z","comments":true,"path":"algorithm/树状数组/","link":"","permalink":"https://memset0.cn/algorithm/树状数组/","excerpt":"单点修改 &amp; 区间查询 傻逼都会。 区间修改 &amp; 单点查询 假设 $a$ 数组为我们当前维护的数组，定义 $b_i = a_i - a_{i - 1}$ ，则 $a_i = \\sum_{j = 1}^{i}b_j$ 。用单点修改 &amp; 区间查询的树状数组维护 $b$ ，修改区间 $l$ 到 $r$ 只需使 $b_{l-1} + value$ 且 $b_r - value$ ，查询 $a_i$ 只需求 $\\sum_{j = 1}^{i}b_j$ 。 区间修改 &amp; 区间查询 同 2 的假设下，求 $\\sum_{i=l}^{r} a_i$ 即求 $\\sum_{i=1}^{r} a_i - \\sum_{i=1}^{l-1} a_i$ ，我们只需考虑如何求 $\\sum_{i=1}^{k} a_i$ 。 $\\sum_{i=1}^{k} a_i = \\sum_{i=1}^{k} \\sum_{j=1}^{i} b_j = \\sum_{i=1}^{k} b_i \\times (i + 1 - x) = (k+1) \\times \\sum_{i=1}^{k} b_i + \\sum_{i=1}^{k} (i \\times b_i)$ 所以我们开两个树状数组，分别维护 $b_i$ 和 $i \\times b_i$ 即可。","text":"单点修改 &amp; 区间查询 傻逼都会。 区间修改 &amp; 单点查询 假设 $a$ 数组为我们当前维护的数组，定义 $b_i = a_i - a_{i - 1}$ ，则 $a_i = \\sum_{j = 1}^{i}b_j$ 。用单点修改 &amp; 区间查询的树状数组维护 $b$ ，修改区间 $l$ 到 $r$ 只需使 $b_{l-1} + value$ 且 $b_r - value$ ，查询 $a_i$ 只需求 $\\sum_{j = 1}^{i}b_j$ 。 区间修改 &amp; 区间查询 同 2 的假设下，求 $\\sum_{i=l}^{r} a_i$ 即求 $\\sum_{i=1}^{r} a_i - \\sum_{i=1}^{l-1} a_i$ ，我们只需考虑如何求 $\\sum_{i=1}^{k} a_i$ 。 $\\sum_{i=1}^{k} a_i = \\sum_{i=1}^{k} \\sum_{j=1}^{i} b_j = \\sum_{i=1}^{k} b_i \\times (i + 1 - x) = (k+1) \\times \\sum_{i=1}^{k} b_i + \\sum_{i=1}^{k} (i \\times b_i)$ 所以我们开两个树状数组，分别维护 $b_i$ 和 $i \\times b_i$ 即可。 由于树状数组中不能有 0 我们需要将下标整体右移一位 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;int read() &#123; int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;&#125;#define lowbit(i) ((i)&amp;(-(i)))const int maxn = 1000010;int n, m, l, r, x, opt, a[maxn];ll s[maxn], c[2][maxn];void modify(int k, ll x) &#123; for (int i = k; i &lt;= n; i += lowbit(i)) c[0][i] += x, c[1][i] += x * (k + 1);&#125;ll query(int k) &#123; ll ans = 0; for (ll i = k; i &gt; 0; i -= lowbit(i)) ans += c[0][i] * (k + 1) - c[1][i]; return ans;&#125;int main() &#123; n = read(), m = read(); for (int i = 1; i &lt;= n; i++) a[i] = read(), s[i] = s[i - 1] + a[i]; for (int i = 1; i &lt;= m; i++) &#123; opt = read(); if (opt == 1) &#123; l = read(), r = read(), x = read(); modify(l, x), modify(r + 1, -x); &#125; else &#123; l = read(), r = read(); printf(\"%lld\\n\", query(r + 1) - query(l) + s[r] - s[l - 1]); &#125; &#125; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://memset0.cn/categories/Algorithm/"}],"tags":[{"name":"树状数组","slug":"树状数组","permalink":"https://memset0.cn/tags/树状数组/"}]},{"title":"Tarjan求割点（洛谷3388）","slug":"algorithm/割点","date":"2018-08-19T07:23:54.000Z","updated":"2018-10-10T12:14:53.313Z","comments":true,"path":"algorithm/割点/","link":"","permalink":"https://memset0.cn/algorithm/割点/","excerpt":"用 tarjan 遍历整个图，如果某个点是割点，当且仅当以下两种情况 当前点是根节点，且当前节点出发独立的联通分量至少有两个 当前点不是根节点，且当前节点出发的独立分量能回溯到的最早的点在当前节点之后 转换过来就是下面两个条件 u == root &amp;&amp; child &gt;= 2 u != root &amp;&amp; low[v] &gt;= dfn[u] 其他与 tarjan 算法无异。","text":"用 tarjan 遍历整个图，如果某个点是割点，当且仅当以下两种情况 当前点是根节点，且当前节点出发独立的联通分量至少有两个 当前点不是根节点，且当前节点出发的独立分量能回溯到的最早的点在当前节点之后 转换过来就是下面两个条件 u == root &amp;&amp; child &gt;= 2 u != root &amp;&amp; low[v] &gt;= dfn[u] 其他与 tarjan 算法无异。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;using namespace std;int read() &#123; int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;&#125;const int maxn = 100010;int n, m, u, v, pos, ans, dfn[maxn], low[maxn], cut[maxn];int tot = 2, hed[maxn], nxt[maxn &lt;&lt; 1], to[maxn &lt;&lt; 1];void add_edge(int u, int v) &#123; nxt[tot] = hed[u]; to[tot] = v; hed[u] = tot++;&#125;void tarjan(int u, int root) &#123; dfn[u] = low[u] = ++pos; int child = 0; for (int i = hed[u], v = to[i]; i; i = nxt[i], v = to[i]) &#123; if (!dfn[v]) &#123; tarjan(v, root); low[u] = min(low[u], low[v]); if (low[v] &gt;= dfn[u] &amp;&amp; u != root) cut[u] = 1; child++; &#125; else &#123; low[u] = min(low[u], dfn[v]); &#125; &#125; if (u == root &amp;&amp; child &gt;= 2) cut[u] = 1;&#125;int main() &#123; n = read(), m = read(); for (int i = 1; i &lt;= m; i++) &#123; u = read(), v = read(); add_edge(u, v); add_edge(v, u); &#125; for (int i = 1; i &lt;= n; i++) if (!dfn[i]) tarjan(i, i); for (int i = 1; i &lt;= n; i++) ans += cut[i]; printf(\"%d\\n\", ans); for (int i = 1; i &lt;= n; i++) if (cut[i]) printf(\"%d \", i); puts(\"\"); return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://memset0.cn/categories/Algorithm/"}],"tags":[{"name":"tarjan","slug":"tarjan","permalink":"https://memset0.cn/tags/tarjan/"},{"name":"图论","slug":"图论","permalink":"https://memset0.cn/tags/图论/"}]},{"title":"Windown10美化计划","slug":"geek/windows-beauty","date":"2018-08-15T08:05:17.000Z","updated":"2018-10-10T12:14:53.315Z","comments":true,"path":"geek/windows-beauty/","link":"","permalink":"https://memset0.cn/geek/windows-beauty/","excerpt":"本文不定时持续更新！ 所有用到的资源可到 cloud.memset0.cn/分享/Windows10美化计划 中下载 成品效果如上","text":"本文不定时持续更新！ 所有用到的资源可到 cloud.memset0.cn/分享/Windows10美化计划 中下载 成品效果如上 更换壁纸壁纸来自 simpledesktops.com，建议做适当修改，步骤： 进入分享文件夹，进入壁纸，下载你喜欢的样式 （可选）参考自定义文件夹的内容进行修改 应用到桌面壁纸 替换鼠标样式此处选用仿 Mac OS X 的鼠标样式，步骤： 进入分享文件夹，下载Mac OS X 鼠标样式.zip并解压 右键AutoSetup.inf选择安装 进入设置 / 控制面板中进行鼠标样式设置 任务栏全透明主流两款应用对比： StartIsBack++：老牌商业软件，有成熟的破解版，支持任务栏透明和 Windows 7 样式的开始菜单和更换 Windows 图标功能，可在 Win8 ~ 10 中使用，曾与 Windows 10 最新版本出现过兼容性问题。 TranslucentTB：新兴开源软件，由于调用了 Windows10 相关 API ，只能在 Windows 10 下运行，但功能纯粹简单，还有毛玻璃效果。 综上，此处选用 TranslucentTB ，有需要的读者可自行搜索 StartIsBack++ 下载。 TranslucentTB 使用步骤： 进入分享文件夹，下载TranslucentTB.zip并解压 添加TranslucentTB.exe到开机自启动任务中 双击TranslucentTB.exe运行 右键任务栏中的 TranslucentTB 图标更改样式 关于任务栏显示文字其实是通过在壁纸上做手脚实现的，可参考上面更换壁纸的第二步。提供了一个 psd 文件，分别对应了大任务栏模式和小任务栏模式下的文字位置，图片大小对应 4K 显示器可适当调整。 个性化设置以下内容仁者见仁智者见智，仅供参考 调整主题色 设置主题色为灰色 设置主题色应用到标题栏 （灵感来源 Sublime Text 官网） 使用小任务栏按钮SB都会，效果可参考上面的截图 隐藏语言栏（有需要的话）此处使用 Windows 10 最新版做演示，往前的版本网上都有教程（偏偏最新版没有哼~） 进入设置 -&gt; 时间和语言 -&gt; 区域和语言 -&gt; 高级键盘设置 取消选中使用桌面语言栏(如果可用)，重新选中使用桌面语言栏(如果可用) 点击语言栏选项，弹出窗口 在弹出窗口中选择语言栏 -&gt; 隐藏(H)，点击确定 如果不行重复上述操作再试一次 后续有什么建议可以在评论中提出。 短时不考虑 Rainmeter / 核心破解装主题 / StartIsBack++ / MacType / 火萤视频桌面，如果有需要可以自行谷歌，建议提前了解可能带来的兼容性问题。","categories":[{"name":"Geek","slug":"Geek","permalink":"https://memset0.cn/categories/Geek/"}],"tags":[{"name":"美化","slug":"美化","permalink":"https://memset0.cn/tags/美化/"}]},{"title":"线性基（洛谷3812）","slug":"algorithm/线性基","date":"2018-08-14T13:55:36.000Z","updated":"2018-10-10T12:14:53.314Z","comments":true,"path":"algorithm/线性基/","link":"","permalink":"https://memset0.cn/algorithm/线性基/","excerpt":"线性基是一种解决异或相关问题的算法。 感谢 mwh 与我分享关于线性基的理解，让我了解线性基。 概念线性基理论上来说是一种贪心的思路。一般情况下，我们需要从（二进制）高位到低位贪心，然而这样可能会产生其他影响（例如当前数的选择与否会影响到之前已选择的数）。线性基就巧妙的解决了这个问题。 假设我们已经有了一个集合 $S$ ，集合中有一数为 $P$ ，现在我们需要插入 $X$ ，则插入 $X$ 和插入 $ X xor P $ 是等价的，理性证明： 假设集合 $S$ 中任意个数其中包含 $P$ 的异或和的集合为 $S1$ ，不包含 $P$ 的为 $S2$ 。则插入 $X$ 后的 $S$ 中任意数的异或和集合 $S’ = X xor S1 + X xor S2$ ；插入 $X xor P$ 后 $S$ 中任意数的异或集合 $S’’ = (X xor P) xor S1 + (X xor P) xor S2 = X xor (P xor S1) + X xor (P xor S2) = X xor S2 + X xor S1$ 。所以 $S’ = S’’$ 插入 $X$ 和插入 $X xor P$ 等价，证毕。","text":"线性基是一种解决异或相关问题的算法。 感谢 mwh 与我分享关于线性基的理解，让我了解线性基。 概念线性基理论上来说是一种贪心的思路。一般情况下，我们需要从（二进制）高位到低位贪心，然而这样可能会产生其他影响（例如当前数的选择与否会影响到之前已选择的数）。线性基就巧妙的解决了这个问题。 假设我们已经有了一个集合 $S$ ，集合中有一数为 $P$ ，现在我们需要插入 $X$ ，则插入 $X$ 和插入 $ X xor P $ 是等价的，理性证明： 假设集合 $S$ 中任意个数其中包含 $P$ 的异或和的集合为 $S1$ ，不包含 $P$ 的为 $S2$ 。则插入 $X$ 后的 $S$ 中任意数的异或和集合 $S’ = X xor S1 + X xor S2$ ；插入 $X xor P$ 后 $S$ 中任意数的异或集合 $S’’ = (X xor P) xor S1 + (X xor P) xor S2 = X xor (P xor S1) + X xor (P xor S2) = X xor S2 + X xor S1$ 。所以 $S’ = S’’$ 插入 $X$ 和插入 $X xor P$ 等价，证毕。 实现我们考虑维护一个集合S，S[i]表示（二进制）最高位是 1 的某个数，这样的数在集合中有且仅有一个。 枚举a[1...n]中的每一个数字： 假设当前数字的最高位为 j 如果S[j]为空，则S[j] = a[i]，退出 如果S[j]不为空，则a[i] xor= S[j]，回到 1 这样对于每个a[i]，只可能插入到S中一次，如果没有插入，则a[i]将会变成 0 ，异或 0 是没有意义的，可以直接省略。 接下来对于 S ，我们只需要前面所说的贪心即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;ll read() &#123; ll x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;&#125;const int maxn = 60;int n;ll ans;ll _2[maxn], a[maxn], f[maxn];int main() &#123; n = read(); for (int i = 1; i &lt;= n; i++) a[i] = read(); _2[0] = 1; for (int i = 1; i &lt;= 50; i++) _2[i] = _2[i - 1] &lt;&lt; 1; for (int i = 1; i &lt;= n; i++) for (int j = 50; j &gt;= 0; j--) if (a[i] &amp; _2[j]) &#123; if (f[j]) a[i] xor= f[j]; else &#123; f[j] = a[i]; break; &#125; &#125; for (int j = 50; j &gt;= 0; j--) if ((ans &amp; _2[j]) == 0) &#123; ans xor= f[j]; &#125; printf(\"%lld\\n\", ans); return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://memset0.cn/categories/Algorithm/"}],"tags":[{"name":"数学，数论","slug":"数学，数论","permalink":"https://memset0.cn/tags/数学，数论/"}]},{"title":"主席树（洛谷P3834）","slug":"algorithm/主席树","date":"2018-08-12T23:20:00.000Z","updated":"2018-10-10T12:14:53.313Z","comments":true,"path":"algorithm/主席树/","link":"","permalink":"https://memset0.cn/algorithm/主席树/","excerpt":"在 mwh 大佬的指引下，我最近学习了主席树。 思想主席树是一种特殊的线段树，能够存储线段树的历史版本，我们称这种性质叫做可持久化。 主席树的可持久化通过这样来实现：我们每次修改单个节点，必然只会经过 $log_2n​$ 条“线段”，对于这些线段，我们都新开节点来存储。显然对于每一次修改操作，根节点都会被新建。那么我们只要存储下来每一次修改说对应的根节点即可。空间占用 $O(n log n)​$ 具体思路可参考https://www.luogu.org/blog/LonecharmRiver/zhu-xi-shu中的图片。 关于模板题我们要维护静态区间第 k 小。可以先把数组离散化，比如： 123离散化前 4 1 1 2 8 9 4 4 3离散化后 4 1 1 2 5 6 4 4 3离散数组 1 2 3 4 8 9 我们根据离散数组作为所维护的区间。第 i 棵树存储[1, i]内各数值出现的次数。","text":"在 mwh 大佬的指引下，我最近学习了主席树。 思想主席树是一种特殊的线段树，能够存储线段树的历史版本，我们称这种性质叫做可持久化。 主席树的可持久化通过这样来实现：我们每次修改单个节点，必然只会经过 $log_2n​$ 条“线段”，对于这些线段，我们都新开节点来存储。显然对于每一次修改操作，根节点都会被新建。那么我们只要存储下来每一次修改说对应的根节点即可。空间占用 $O(n log n)​$ 具体思路可参考https://www.luogu.org/blog/LonecharmRiver/zhu-xi-shu中的图片。 关于模板题我们要维护静态区间第 k 小。可以先把数组离散化，比如： 123离散化前 4 1 1 2 8 9 4 4 3离散化后 4 1 1 2 5 6 4 4 3离散数组 1 2 3 4 8 9 我们根据离散数组作为所维护的区间。第 i 棵树存储[1, i]内各数值出现的次数。 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;int read() &#123; int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;&#125;const int maxn = 200010, maxm = maxn * 21;int n, m, tn, l, r, x;int a[maxn], b[maxn];int tot, hed[maxn], sum[maxm], lc[maxm], rc[maxm];void build(int &amp;u, int l, int r) &#123; u = ++tot; if (l == r) return; int mid = (l + r) &gt;&gt; 1; build(lc[u], l, mid); build(rc[u], mid + 1, r);&#125;void modify(int &amp;u, int f, int l, int r, int k) &#123; u = ++tot, sum[u] = sum[f] + 1; if (l == r) return; int mid = (l + r) &gt;&gt; 1; if (k &lt;= mid) modify(lc[u], lc[f], l, mid, k), rc[u] = rc[f]; else modify(rc[u], rc[f], mid + 1, r, k), lc[u] = lc[f];&#125;int query(int p, int q, int l, int r, int k) &#123; if (l == r) return b[l]; int mid = (l + r) &gt;&gt; 1; if (sum[lc[q]] - sum[lc[p]] &gt;= k) return query(lc[p], lc[q], l, mid, k); else return query(rc[p], rc[q], mid + 1, r, k + sum[lc[p]] - sum[lc[q]]);&#125;int main() &#123; n = read(), m = read(); for (int i = 1; i &lt;= n; i++) b[i] = a[i] = read(); sort(b + 1, b + n + 1); tn = unique(b + 1, b + n + 1) - b - 1; for (int i = 1; i &lt;= n; i++) a[i] = lower_bound(b + 1, b + tn + 1, a[i]) - b; build(hed[0], 1, tn); for (int i = 1; i &lt;= n; i++) modify(hed[i], hed[i - 1], 1, tn, a[i]); while (m--) &#123; l = read(), r = read(), x = read(); printf(\"%d\\n\", query(hed[l - 1], hed[r], 1, tn, x)); &#125; return 0;&#125; 后续 &amp; 参考资料需要注意： 我们需要事先建一棵空树； 由于上一条，我们需要n + n log n的空间。 参考资料： https://www.luogu.org/blog/LonecharmRiver/zhu-xi-shu","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://memset0.cn/categories/Algorithm/"}],"tags":[{"name":"可持久化线段树","slug":"可持久化线段树","permalink":"https://memset0.cn/tags/可持久化线段树/"},{"name":"主席树","slug":"主席树","permalink":"https://memset0.cn/tags/主席树/"}]},{"title":"高斯消元（洛谷3389）","slug":"algorithm/gauss","date":"2018-08-11T00:45:31.000Z","updated":"2018-10-10T12:14:53.312Z","comments":true,"path":"algorithm/gauss/","link":"","permalink":"https://memset0.cn/algorithm/gauss/","excerpt":"最近的模拟赛出现了一道坑爹的数学题，正解是上一篇博文所讲的数学插值。然而高斯消元还是可以拿到 65 分的成绩，没办法，凭借着我对其原理的依稀记忆我只能考场上手推高斯消元。 原理高斯消元其实是个很简单的东西，无非就小学奥数的难度罢了。按照小学奥数的加减消元和代入消元即可完成。模板题给了你 n 个的 n 元一次多项式求解。我们可以通过加减消元合并为 n - 1 个 n - 1 元的一次多项式（合并相邻两个）；于是，经过 n - 1 次合并我们就可以得到一个一元一次方程，可以很方便的得到解。我们再将解回代，即可解出方程。","text":"最近的模拟赛出现了一道坑爹的数学题，正解是上一篇博文所讲的数学插值。然而高斯消元还是可以拿到 65 分的成绩，没办法，凭借着我对其原理的依稀记忆我只能考场上手推高斯消元。 原理高斯消元其实是个很简单的东西，无非就小学奥数的难度罢了。按照小学奥数的加减消元和代入消元即可完成。模板题给了你 n 个的 n 元一次多项式求解。我们可以通过加减消元合并为 n - 1 个 n - 1 元的一次多项式（合并相邻两个）；于是，经过 n - 1 次合并我们就可以得到一个一元一次方程，可以很方便的得到解。我们再将解回代，即可解出方程。 代码其实没什么好说的，直接看代码就行。鉴于大部分洛谷题解的质量堪忧（经常被 Hack ），所以这篇代码也是经过了重重考验吧。欢迎 Hack 。 为避免误会，事先声明洛谷此题有无数组解和无解都属于 No solution. 如果这两种情况要分开来你可能需要另外一种写法，我也会给出。 需要注意一下无解的情况和主元不能为 0 ，大部分题解被 Hack 也都是因为这个原因。 AC 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 110;const double inf = 1e10;int n;double t, ans[maxn], f[maxn][maxn];int work() &#123; for (int i = 1; i &lt;= n; i++) &#123; // f[i][i]即所谓的主元 if (f[i][i] == 0) &#123; // 主元不能为0，要交换 int j = i + 1; while (f[j][i] == 0 &amp;&amp; j &lt;= n) j++; if (j &gt; n) return -1; // 肯定无解 swap(f[i], f[j]); &#125; for (int j = i + 1; j &lt;= n; j++) &#123; t = -f[j][i] / f[i][i]; for (int k = i; k &lt;= n + 1; k++) f[j][k] += f[i][k] * t; &#125; &#125; for (int i = n; i &gt;= 1; i--) &#123; for (int j = i + 1; j &lt;= n; j++) f[i][n + 1] -= ans[j] * f[i][j]; ans[i] = f[i][n + 1] / f[i][i]; &#125; return 0;&#125;int main() &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n + 1; j++) scanf(\"%lf\", &amp;f[i][j]); if (work() == -1) printf(\"No Solution\\n\"); else for (int i = 1; i &lt;= n; i++) printf(\"%.2lf\\n\", ans[i]); return 0;&#125; 可以区分无数解和无解的算法，无数解在有些题目中是可行的（也许有 SPJ ），叫做自由元，你可以取任意一个值： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 110;const double inf = 1e10;int n;double t, ans[maxn], f[maxn][maxn];int work() &#123; for (int i = 1; i &lt;= n; i++) &#123; if (f[i][i] == 0) &#123; int j = i + 1; while (f[j][i] == 0 &amp;&amp; j &lt;= n) j++; swap(f[i], f[j]); &#125; for (int j = i + 1; j &lt;= n; j++) &#123; t = -f[j][i] / f[i][i]; for (int k = i; k &lt;= n + 1; k++) f[j][k] += f[i][k] * t; &#125; &#125; for (int i = n; i &gt;= 1; i--) &#123; for (int j = i + 1; j &lt;= n; j++) f[i][n + 1] -= ans[j] * f[i][j]; if (f[i][i] == 0) &#123; if (ans[i] == 0) return -1; // 无数解 else return -2; // 无解 &#125; ans[i] = f[i][n + 1] / f[i][i]; &#125; return 0;&#125;int main() &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n + 1; j++) scanf(\"%lf\", &amp;f[i][j]); if (work() &lt; 0) printf(\"No Solution\\n\"); else for (int i = 1; i &lt;= n; i++) printf(\"%.2lf\\n\", ans[i]); return 0;&#125; 后续 &amp; 参考资料哦，对了，还记得我开头说的那个模拟赛上的高斯消元么？因为某些原因其实不是正解只有 65 分，另外由于那题的某些限制，任意元不能取 0 ，所以只有 45 了，还好那场模拟赛大家分都不高，勉强凑活啦。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://memset0.cn/categories/Algorithm/"}],"tags":[{"name":"数学，数论","slug":"数学，数论","permalink":"https://memset0.cn/tags/数学，数论/"}]},{"title":"关于最近的集训的一些事情","slug":"diary/关于最近的集训","date":"2018-08-10T13:11:05.000Z","updated":"2018-12-08T15:34:01.394Z","comments":true,"path":"diary/关于最近的集训/","link":"","permalink":"https://memset0.cn/diary/关于最近的集训/","excerpt":"","text":"这两天一直在信奥集训也没时间休息，基本上处于 早上七点不到起床 =&gt; 上午八点模拟赛 =&gt; 中午十一点半去吃饭 =&gt; 下午一点继续上课 =&gt; 下午五点去吃晚饭 =&gt; 晚饭吃完继续搞信奥 =&gt; 晚上九点多回家 =&gt; 继续刷题直到晚上十一点半 =&gt; 睡觉 的状态。也没有时间休息，今天好不容易暂时放假了，然而还是轻松不了，不过来水一篇博文的时间还是有的。 这段时间新学了很多算法（网络流乱搞 / 树上乱搞 / 数论乱搞 / 平衡树乱搞 等等），感觉自己学了很多知识。原本对于自己来说感觉很难很难的知识现在基本研究个几个小时也能解决了，比如 Splay （我还写了几篇有关她的博文）。当然本来感觉很充足的睡觉时间和休息时间现在也基本 disappear 了。谁说的期末考考完就轻松了给我站出来！ 最近也新换了一处博客，毕竟新学了一些东西，觉得原来写的一些博文质量都很不高，打算重新开始。这当然也需要时间和过程，所以可能在很长的一段时间内我可能会一直维持两个博客都开着但只维护这里的状态。 我对博客的看法也发生了改变，也许当初是觉得新鲜，对此非常兴奋，浪费大量时间。不过现在心态也转变了，也觉得自己的博客是写给自己看的，其实别人看不看也没有什么关系，更何况本来看的人就屈指可数呢。","categories":[{"name":"Diary","slug":"Diary","permalink":"https://memset0.cn/categories/Diary/"}],"tags":[{"name":"日记","slug":"日记","permalink":"https://memset0.cn/tags/日记/"}]},{"title":"拉格朗日插值（洛谷4781）","slug":"algorithm/拉格朗日插值","date":"2018-08-10T10:33:50.000Z","updated":"2018-10-10T12:14:53.314Z","comments":true,"path":"algorithm/拉格朗日插值/","link":"","permalink":"https://memset0.cn/algorithm/拉格朗日插值/","excerpt":"给你平面上的 n 个点，可以唯一确定一个多项式。 现在告诉你这些点的坐标和 k ，请你求出多项式在 k 的取值。 思路显然我们可以根据题意列出 n 个方程，利用高斯消元求解后带入。时间复杂度O(n ^ 3)。 我们可以利用插值法求解并使得时间复杂度降至O(n ^ 2)。","text":"给你平面上的 n 个点，可以唯一确定一个多项式。 现在告诉你这些点的坐标和 k ，请你求出多项式在 k 的取值。 思路显然我们可以根据题意列出 n 个方程，利用高斯消元求解后带入。时间复杂度O(n ^ 3)。 我们可以利用插值法求解并使得时间复杂度降至O(n ^ 2)。 拉格朗日插值拉格朗日基本多项式为： 对于这个多项式，他有一个神奇的性质，如果你带入 x[j]，可以获得 1 （分子分母相同）；如果带入 x[i]，可以获得 0 （其中必有一项的分子值为 0 ）。由此，我们可以列出这个 n 次多项式。 由于某些前面所述的基本多项式的性质，带入 x[i] 可以获得 y[i] ，即该函数的图像经过题目所要求的 n 个点。可以经过严格的数学证明（知乎上有）可以证明这个多项式即所求的。 然鹅我们并不需要了解那么多，既然这个多项式就是所求多项式，我们带进去用就可以了。另外，由于其中涉及到除法和取模，我们可以考虑乘法逆元。同时，我们可以每次处理出分子和分母再求逆元（而不是实时求逆元），即可保证时间复杂度为O(n ^ 2)。 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;int read() &#123; int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;&#125;const int maxn = 2010, Mod = 998244353;int n, k;ll s1, s2, ans;ll x[maxn], y[maxn];ll inv(ll x) &#123; if (x == 0 || x == 1) return 1; if (x &lt; 0) return inv((x % Mod + Mod) % Mod); return (Mod - Mod / x) * inv(Mod % x) % Mod;&#125;int main() &#123; n = read(), k = read(); for (int i = 1; i &lt;= n; i++) x[i] = read(), y[i] = read(); for (int i = 1; i &lt;= n; i++) &#123; s1 = s2 = 1; for (int j = 1; j &lt;= n; j++) if (i != j) &#123; s1 = s1 * (k - x[j]) % Mod; s2 = s2 * (x[i] - x[j]) % Mod; &#125; ans = (ans + s1 * inv(s2) % Mod * y[i] % Mod + Mod) % Mod; &#125; printf(\"%lld\\n\", ans); return 0;&#125; 参考资料题目链接： 洛谷4781 【模板】拉格朗日插值 参考资料： http://www.ebola.pro/article/notes/Lagrange https://www.luogu.org/blog/user11773/solution-p4781","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://memset0.cn/categories/Algorithm/"}],"tags":[{"name":"数学，数论","slug":"数学，数论","permalink":"https://memset0.cn/tags/数学，数论/"}]},{"title":"非旋 Treap 模板（普通平衡树）","slug":"algorithm/fhq-treap","date":"2018-08-09T13:12:00.000Z","updated":"2018-10-10T12:14:53.312Z","comments":true,"path":"algorithm/fhq-treap/","link":"","permalink":"https://memset0.cn/algorithm/fhq-treap/","excerpt":"前言和 Splay 一样，非旋 Treap （又名 fhq-treap）也是平衡树的一种。由于其不需要进行旋转操作，故可利用其进行可持久化。 写一颗非旋 Treap，我们只需要合并、分离操作，其他的只要有颗脑子就会了啦！ 定义我们定义类FhqTreap为非旋 Treap 主体，结构体node为其节点。 123456789101112131415161718class FhqTheap &#123; private: struct node &#123; int val, rnd; // val =&gt; 该点存储的值，rnd =&gt; 该点键值，随机产生 int siz, ch[2]; // siz =&gt; 该点包括其子树的节点大小，ch[2] =&gt; 指向左/右儿子 &#125; e[maxn]; int tot, root; // tot =&gt; 节点总数，root =&gt; 根节点 int x, y, z; // 操作过程中的临时变量 // Your Code Goes Here... public: // Your Code Goes Here... &#125; s;","text":"前言和 Splay 一样，非旋 Treap （又名 fhq-treap）也是平衡树的一种。由于其不需要进行旋转操作，故可利用其进行可持久化。 写一颗非旋 Treap，我们只需要合并、分离操作，其他的只要有颗脑子就会了啦！ 定义我们定义类FhqTreap为非旋 Treap 主体，结构体node为其节点。 123456789101112131415161718class FhqTheap &#123; private: struct node &#123; int val, rnd; // val =&gt; 该点存储的值，rnd =&gt; 该点键值，随机产生 int siz, ch[2]; // siz =&gt; 该点包括其子树的节点大小，ch[2] =&gt; 指向左/右儿子 &#125; e[maxn]; int tot, root; // tot =&gt; 节点总数，root =&gt; 根节点 int x, y, z; // 操作过程中的临时变量 // Your Code Goes Here... public: // Your Code Goes Here... &#125; s; 辅助操作update()更新当前节点的siz； newnode()用于新建节点。 1234567891011void update(int x) &#123; e[x].siz = e[e[x].ch[0]].siz + e[e[x].ch[1]].siz + 1;&#125;int newnode(int val) &#123; tot++; e[tot].siz = 1; e[tot].ch[0] = e[tot].ch[1] = 0; e[tot].val = val, e[tot].rnd = rand(); return tot;&#125; 合并将树 x 与树 y 合并，默认 x &lt; y。 如果其中一颗是空树，返回另一颗； 如果树 x 的根节点的rnd小于树 y 的根节点，把 x 的右子树与 y 合并后成为 x 的右子树； 如果树 x 的根节点的rnd大于树 y 的根节点，把 y 的左子树与 x 合并后成为 y 的左子树； 等于的话随意。 123456789101112int merge(int x, int y) &#123; if (!x || !y) return x + y; if (e[x].rnd &lt; e[y].rnd) &#123; e[x].ch[1] = merge(e[x].ch[1], y); update(x); return x; &#125; else &#123; e[y].ch[0] = merge(x, e[y].ch[0]); update(y); return y; &#125;&#125; 分离把以某一节点为根的子树以 k 为值分为两部分。 12345678void split(int u, int k, int &amp;x, int &amp;y) &#123; if (!u) return (void)(x = y = 0); if (e[u].val &lt;= k) x = u, split(e[x].ch[1], k, e[x].ch[1], y); else y = u, split(e[y].ch[0], k, x, e[y].ch[0]); update(u);&#125; 查找第 k 大利用其平衡树的性质，递归写法。 12345int kth(int u, int k) &#123; if (k &lt;= e[e[u].ch[0]].siz) return kth(e[u].ch[0], k); if (k == e[e[u].ch[0]].siz + 1) return u; return kth(e[u].ch[1], k - e[e[u].ch[0]].siz - 1);&#125; 其余操作十分简单，略。 123456789101112131415161718192021222324252627282930313233343536void insert(int val) &#123; split(root, val, x, y); root = merge(merge(x, newnode(val)), y);&#125;void erase(int val) &#123; split(root, val, x, z); split(x, val - 1, x, y); y = merge(e[y].ch[0], e[y].ch[1]); root = merge(merge(x, y), z);&#125;int rank(int val) &#123; split(root, val - 1, x, y); int ret = e[x].siz + 1; merge(x, y); return ret;&#125;int atrank(int k) &#123; return e[kth(root, k)].val;&#125;int lower_bound(int val) &#123; split(root, val - 1, x, y); int ret = e[kth(x, e[x].siz)].val; merge(x, y); return ret;&#125;int upper_bound(int val) &#123; split(root, val, x, y); int ret = e[kth(y, 1)].val; merge(x, y); return ret;&#125; 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define y1 this_is_not_y1#define y2 this_is_not_y2#define ll long longusing namespace std;int read() &#123; int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;&#125;const int maxn = 100010;int n, opt;class FhqTheap &#123; private: struct node &#123; int val, rnd; int siz, ch[2]; &#125; e[maxn]; int tot, root, x, y, z; void update(int x) &#123; e[x].siz = e[e[x].ch[0]].siz + e[e[x].ch[1]].siz + 1; &#125; int newnode(int val) &#123; tot++; e[tot].siz = 1; e[tot].ch[0] = e[tot].ch[1] = 0; e[tot].val = val, e[tot].rnd = rand(); return tot; &#125; int merge(int x, int y) &#123; if (!x || !y) return x + y; if (e[x].rnd &lt; e[y].rnd) &#123; e[x].ch[1] = merge(e[x].ch[1], y); update(x); return x; &#125; else &#123; e[y].ch[0] = merge(x, e[y].ch[0]); update(y); return y; &#125; &#125; void split(int u, int k, int &amp;x, int &amp;y) &#123; if (!u) return (void)(x = y = 0); if (e[u].val &lt;= k) x = u, split(e[x].ch[1], k, e[x].ch[1], y); else y = u, split(e[y].ch[0], k, x, e[y].ch[0]); update(u); &#125; int kth(int u, int k) &#123; if (k &lt;= e[e[u].ch[0]].siz) return kth(e[u].ch[0], k); if (k == e[e[u].ch[0]].siz + 1) return u; return kth(e[u].ch[1], k - e[e[u].ch[0]].siz - 1); &#125; public: void insert(int val) &#123; split(root, val, x, y); root = merge(merge(x, newnode(val)), y); &#125; void erase(int val) &#123; split(root, val, x, z); split(x, val - 1, x, y); y = merge(e[y].ch[0], e[y].ch[1]); root = merge(merge(x, y), z); &#125; int rank(int val) &#123; split(root, val - 1, x, y); int ret = e[x].siz + 1; merge(x, y); return ret; &#125; int atrank(int k) &#123; return e[kth(root, k)].val; &#125; int lower_bound(int val) &#123; split(root, val - 1, x, y); int ret = e[kth(x, e[x].siz)].val; merge(x, y); return ret; &#125; int upper_bound(int val) &#123; split(root, val, x, y); int ret = e[kth(y, 1)].val; merge(x, y); return ret; &#125; &#125; s;int main() &#123; n = read(); while (n--) &#123; opt = read(); switch(opt) &#123; case 1: s.insert(read()); break; case 2: s.erase(read()); break; case 3: printf(\"%d\\n\", s.rank(read())); break; case 4: printf(\"%d\\n\", s.atrank(read())); break; case 5: printf(\"%d\\n\", s.lower_bound(read())); break; case 6: printf(\"%d\\n\", s.upper_bound(read())); break; &#125; &#125; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://memset0.cn/categories/Algorithm/"}],"tags":[{"name":"平衡树","slug":"平衡树","permalink":"https://memset0.cn/tags/平衡树/"}]},{"title":"Splay 非指针模板（普通平衡树）","slug":"algorithm/Splay基本操作","date":"2018-08-09T10:27:16.000Z","updated":"2018-10-10T12:14:53.313Z","comments":true,"path":"algorithm/Splay基本操作/","link":"","permalink":"https://memset0.cn/algorithm/Splay基本操作/","excerpt":"踏上平衡树征程的第一步… 前言Splay 是一种简单且功能丰富的平衡树结构，其算法核心 Splay 操作能维持其均摊复杂度维持在 $O(logn)$ 。 定义我们将整棵 Splay 定义在结构体中。 并定义结构体node来表示 Splay 的每一个节点。 宏定义e[0].ch[1]为根节点， $1e9 + 10$ 为INF，并在结构体尾取消定义。 1234567891011121314struct Splay &#123; #define root (e[0].ch[1]) #define inf (1e9+10) struct node &#123; int val; // 当前节点存储的值 int cnt; // 当前节点存储的值出现的次数 int siz; // 当前节点包括其左右子树中包含的数的个数（不是节点数！） int father; // 当前节点的父亲节点 int ch[2]; // 当前节点的孩子节点，ch[0]表示左孩子，ch[1]表示右孩子 &#125; // your code goes here... #undef root #undef inf&#125;","text":"踏上平衡树征程的第一步… 前言Splay 是一种简单且功能丰富的平衡树结构，其算法核心 Splay 操作能维持其均摊复杂度维持在 $O(logn)$ 。 定义我们将整棵 Splay 定义在结构体中。 并定义结构体node来表示 Splay 的每一个节点。 宏定义e[0].ch[1]为根节点， $1e9 + 10$ 为INF，并在结构体尾取消定义。 1234567891011121314struct Splay &#123; #define root (e[0].ch[1]) #define inf (1e9+10) struct node &#123; int val; // 当前节点存储的值 int cnt; // 当前节点存储的值出现的次数 int siz; // 当前节点包括其左右子树中包含的数的个数（不是节点数！） int father; // 当前节点的父亲节点 int ch[2]; // 当前节点的孩子节点，ch[0]表示左孩子，ch[1]表示右孩子 &#125; // your code goes here... #undef root #undef inf&#125; 基础操作update()操作用于更新当前节点的siz值； connect()操作用于连接节点； identify()操作用于确认当前节点是其父亲的左孩子还是右孩子。 12345678910void update(int x) &#123; e[x].siz = e[e[x].ch[0]].siz + e[e[x].ch[1]].siz + e[x].cnt;&#125;void connect(int x, int f, int son) &#123; e[x].father = f; e[f].ch[son] = x;&#125;int identify(int x) &#123; return x == e[e[x].father].ch[0] ? 0 : 1;&#125; 旋转平衡树的必备知识。 rotate(x)表示把x节点上旋到其父亲的位置。 12345678910void rotate(int x) &#123; int f = e[x].father, fson = identify(x); int ff = e[f].father, ffson = identify(f); int y = e[x].ch[fson ^ 1]; connect(y, f, fson); connect(f, x, fson ^ 1); connect(x, ff, ffson); update(f); update(x);&#125; SplaySplay 是 Splay 的核心操作。用于把一个节点旋转到指定位置。 需要注意的是，Splay在每次完成查询操作后都要将被查询的节点 Splay 到根。 12345678910void splay(int at, int to) &#123; if (!at) return; to = e[to].father; while (e[at].father != to) &#123; int up = e[at].father; if (e[up].father == to) rotate(at); else if (identify(at) == identify(up)) rotate(up), rotate(at); else rotate(at), rotate(at); &#125;&#125; 新建 / 擦除节点为 插入 / 删除 操作提供铺垫。 12345678910111213void crepoint(int val, int father) &#123; int x = ++pos; e[x].val = val; e[x].father = father; e[x].cnt = e[x].siz = 1; e[x].ch[0] = e[x].ch[1] = 0;&#125;void delpoint(int x) &#123; e[x].val = 0; e[x].father = 0; e[x].cnt = e[x].siz = 0; e[x].ch[0] = e[x].ch[1] = 0;&#125; 插入如果是空节点需要特判； 如果可以在树中找到一个值相同的节点那么直接使其cnt++； 其余情况根据平衡树的性质找到一个可行位置并插入。 12345678910111213141516171819202122232425void insert(int val) &#123; int u = root; points++; if (points == 1) &#123; // 特判无点状态（看个人写法？） crepoint(val, 0); root = pos; return; &#125; while (u) &#123; e[u].siz++; if (e[u].val == val) &#123; e[u].cnt++; splay(u, root); return; &#125; int son = val &lt; e[u].val ? 0 : 1; if (!e[u].ch[son]) &#123; crepoint(val, u); e[u].ch[son] = pos; splay(pos, root); return; &#125; u = e[u].ch[son]; &#125;&#125; 删除首先将要删除的节点旋转到根节点的位置。 如果要被删除的节点（注意现在它在根的位置）没有左孩子，那么直接摧毁这个节点，并将它的右孩子变成根。 如果自己有左孩子，那么就先把左子树中值最大的元素旋转到根的左孩子位置，然后将根节点的右孩子变成根节点的左孩子的右孩子，然后摧毁节点，并将左孩子变成根。 这样子做是为了使删除节点后的树维持平衡。 123456789101112131415161718192021void erase(int val) &#123; int u = find(val); points--; if (e[u].cnt &gt; 1) &#123; e[u].cnt--; e[u].siz--; return; &#125; if (!e[u].ch[0]) &#123; connect(e[u].ch[1], 0, 1); root = e[u].ch[1]; &#125; else &#123; int lft = e[u].ch[0], rit = e[u].ch[1]; while (e[lft].ch[1]) lft = e[lft].ch[1]; splay(lft, e[u].ch[0]); connect(rit, lft, 1); connect(lft, 0, 1); update(lft); &#125; delpoint(u);&#125; 排名 rank()查询 x 数的排名（定义为比当前数小的数的个数 +1 ) atrank()查询排名为 x 的数 12345678910111213141516171819202122int rank(int val) &#123; int u = root, ans = 0; while (u) &#123; if (val == e[u].val) &#123; ans += e[e[u].ch[0]].siz + 1; splay(u, root); return ans; &#125; if (val &lt; e[u].val) u = e[u].ch[0]; else ans += e[e[u].ch[0]].siz + e[u].cnt, u = e[u].ch[1]; &#125;&#125;int atrank(int x) &#123; int u = root; while (u) &#123; if (x &lt;= e[e[u].ch[0]].siz) u = e[u].ch[0]; else if (x &lt;= e[e[u].ch[0]].siz + e[u].cnt) &#123; splay(u, root); return e[u].val; &#125; else x -= e[e[u].ch[0]].siz + e[u].cnt, u = e[u].ch[1]; &#125;&#125; 前驱 &amp; 后继根据平衡树的性质即可。 需要注意的是相等时仍需要继续查找，那么等号的用法就特别讲究。 此份代码中将其特别突出。 123456789101112131415161718int lower(int val) &#123; int u = root, result = -inf, cho = 0; while (u) &#123; if (e[u].val &lt; val &amp;&amp; e[u].val &gt; result) result = e[u].val, cho = u; u = e[u].ch[val &lt;= e[u].val ? 0 : 1]; &#125; splay(cho, root); return result;&#125;int upper(int val) &#123; int u = root, result = inf, cho = 0; while (u) &#123; if (e[u].val &gt; val &amp;&amp; e[u].val &lt; result) result = e[u].val, cho = u; u = e[u].ch[val &gt;= e[u].val ? 1 : 0]; &#125; splay(cho, root); return result;&#125; 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;int read() &#123; int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;&#125;const int maxn = 100010;int n, opt;struct Splay &#123; #define root (e[0].ch[1]) #define inf (1e9 + 10) struct node &#123; int cnt, siz, val; int father, ch[2]; &#125; e[maxn]; int pos, points; void update(int x) &#123; e[x].siz = e[e[x].ch[0]].siz + e[e[x].ch[1]].siz + e[x].cnt; &#125; void connect(int x, int f, int son) &#123; e[x].father = f; e[f].ch[son] = x; &#125; int identify(int x) &#123; return x == e[e[x].father].ch[0] ? 0 : 1; &#125; void rotate(int x) &#123; int f = e[x].father, fson = identify(x); int ff = e[f].father, ffson = identify(f); int y = e[x].ch[fson ^ 1]; connect(y, f, fson); connect(f, x, fson ^ 1); connect(x, ff, ffson); update(f); update(x); &#125; void splay(int at, int to) &#123; if (!at) return; to = e[to].father; while (e[at].father != to) &#123; int up = e[at].father; if (e[up].father == to) rotate(at); else if (identify(at) == identify(up)) rotate(up), rotate(at); else rotate(at), rotate(at); &#125; &#125; void crepoint(int val, int father) &#123; int x = ++pos; e[x].val = val; e[x].father = father; e[x].cnt = e[x].siz = 1; e[x].ch[0] = e[x].ch[1] = 0; &#125; void delpoint(int x) &#123; e[x].val = 0; e[x].father = 0; e[x].cnt = e[x].siz = 0; e[x].ch[0] = e[x].ch[1] = 0; &#125; int find(int val) &#123; int u = root; while (u) &#123; if (val == e[u].val) &#123; splay(u, root); return u; &#125; u = e[u].ch[val &lt; e[u].val ? 0 : 1]; &#125; &#125; void insert(int val) &#123; int u = root; points++; if (points == 1) &#123; crepoint(val, 0); root = pos; return; &#125; while (u) &#123; e[u].siz++; if (e[u].val == val) &#123; e[u].cnt++; splay(u, root); return; &#125; int son = val &lt; e[u].val ? 0 : 1; if (!e[u].ch[son]) &#123; crepoint(val, u); e[u].ch[son] = pos; splay(pos, root); return; &#125; u = e[u].ch[son]; &#125; &#125; void erase(int val) &#123; int u = find(val); points--; if (e[u].cnt &gt; 1) &#123; e[u].cnt--; e[u].siz--; return; &#125; if (!e[u].ch[0]) &#123; connect(e[u].ch[1], 0, 1); root = e[u].ch[1]; &#125; else &#123; int lft = e[u].ch[0], rit = e[u].ch[1]; while (e[lft].ch[1]) lft = e[lft].ch[1]; splay(lft, e[u].ch[0]); connect(rit, lft, 1); connect(lft, 0, 1); update(lft); &#125; delpoint(u); &#125; int rank(int val) &#123; int u = root, ans = 0; while (u) &#123; if (val == e[u].val) &#123; ans += e[e[u].ch[0]].siz + 1; splay(u, root); return ans; &#125; if (val &lt; e[u].val) u = e[u].ch[0]; else ans += e[e[u].ch[0]].siz + e[u].cnt, u = e[u].ch[1]; &#125; &#125; int atrank(int x) &#123; int u = root; while (u) &#123; if (x &lt;= e[e[u].ch[0]].siz) u = e[u].ch[0]; else if (x &lt;= e[e[u].ch[0]].siz + e[u].cnt) &#123; splay(u, root); return e[u].val; &#125; else x -= e[e[u].ch[0]].siz + e[u].cnt, u = e[u].ch[1]; &#125; &#125; int lower(int val) &#123; int u = root, result = -inf, cho = 0; while (u) &#123; if (e[u].val &lt; val &amp;&amp; e[u].val &gt; result) result = e[u].val, cho = u; u = e[u].ch[val &lt;= e[u].val ? 0 : 1]; &#125; splay(cho, root); return result; &#125; int upper(int val) &#123; int u = root, result = inf, cho = 0; while (u) &#123; if (e[u].val &gt; val &amp;&amp; e[u].val &lt; result) result = e[u].val, cho = u; u = e[u].ch[val &gt;= e[u].val ? 1 : 0]; &#125; splay(cho, root); return result; &#125; #undef root #undef inf&#125; s;int main() &#123; n = read(); while (n--) &#123; opt = read(); switch(opt) &#123; case 1: s.insert(read()); break; case 2: s.erase(read()); break; case 3: printf(\"%d\\n\", s.rank(read())); break; case 4: printf(\"%d\\n\", s.atrank(read())); break; case 5: printf(\"%d\\n\", s.lower(read())); break; case 6: printf(\"%d\\n\", s.upper(read())); break; &#125; &#125; return 0;&#125; 备注 &amp; 参考资料本文只是模板向的 Splay 教程，请在理解 Splay 后查看。 题目链接： 3369 【模板】普通平衡树 - 洛谷 参考资料： https://www.luogu.org/blog/user19027/solution-p3369, 题解 P3369 【【模板】普通平衡树（Treap/SBT）】","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://memset0.cn/categories/Algorithm/"}],"tags":[{"name":"平衡树","slug":"平衡树","permalink":"https://memset0.cn/tags/平衡树/"}]},{"title":"Splay 实现区间翻转（文艺平衡树）","slug":"algorithm/Splay翻转","date":"2018-08-09T04:33:46.000Z","updated":"2018-10-10T12:14:53.313Z","comments":true,"path":"algorithm/Splay翻转/","link":"","permalink":"https://memset0.cn/algorithm/Splay翻转/","excerpt":"思路之前我们讲到了用 Splay 写普通平衡树，这次我们将用 Splay 来完成区间操作。 之前的 Splay 是按照权值排序，而这里的 Splay 则是要按照编号排序。 不难想到，整棵树的编号第 k 大点即数列中的第 k 个，整棵树的中序遍历即被维护的数列。 假设我们要翻转区间[l, r]，那么我们先把l - 1旋转到根节点，再把r + 1旋转到根节点的右孩子。那么r + 1的左子树即区间[l, r]。翻转该区间只需要把该区间内的每个节点的左右子树交换即可。 参考线段树的 lazytag，我们也使用一个类似于懒标记的方法，保证复杂度为O(log n)。","text":"思路之前我们讲到了用 Splay 写普通平衡树，这次我们将用 Splay 来完成区间操作。 之前的 Splay 是按照权值排序，而这里的 Splay 则是要按照编号排序。 不难想到，整棵树的编号第 k 大点即数列中的第 k 个，整棵树的中序遍历即被维护的数列。 假设我们要翻转区间[l, r]，那么我们先把l - 1旋转到根节点，再把r + 1旋转到根节点的右孩子。那么r + 1的左子树即区间[l, r]。翻转该区间只需要把该区间内的每个节点的左右子树交换即可。 参考线段树的 lazytag，我们也使用一个类似于懒标记的方法，保证复杂度为O(log n)。 基本操作和普通平衡树一样。 12345678910void update(int x) &#123; e[x].sum = e[e[x].ch[0]].sum + e[e[x].ch[1]].sum + e[x].cnt;&#125;int identify(int x) &#123; return e[e[x].father].ch[1] == x;&#125;void connect(int u, int f, int son) &#123; e[u].father = f; e[f].ch[son] = u;&#125; 懒标记下放把当前节点的懒标记传给两个孩子，同时交换两个孩子的指针。 12345678void pushdown(int x) &#123; if (e[x].tag) &#123; swap(e[x].ch[0], e[x].ch[1]); e[e[x].ch[0]].tag ^= 1; e[e[x].ch[1]].tag ^= 1; e[x].tag = 0; &#125;&#125; 上旋 &amp; Splay和普通平衡树的操作相同，只不过需要先pushdown()改变了的节点。 123456789101112131415161718192021void rotate(int x) &#123; int f = e[x].father, ff = e[f].father; pushdown(f), pushdown(x); int fson = identify(x), ffson = identify(f); int y = e[x].ch[fson ^ 1]; connect(y, f, fson); connect(f, x, fson ^ 1); connect(x, ff, ffson); update(f); update(x);&#125;void splay(int at, int to) &#123; to = e[to].father; while (e[at].father != to) &#123; int up = e[at].father; pushdown(up), pushdown(at); if (e[up].father == to) rotate(at); else if (identify(at) == identify(up)) rotate(up), rotate(at); else rotate(at), rotate(at); &#125;&#125; 查找与普通平衡树的查找第 k 大相同。 由于只会在reverse操作中被调用所以没有 splay 到根。 12345678910int find(int x) &#123; int u = root; while (u) &#123; pushdown(u); int mincost = e[e[u].ch[0]].sum + e[u].cnt; if (e[e[u].ch[0]].sum &lt; x &amp;&amp; x &lt;= mincost) return u; if (x &lt; mincost) u = e[u].ch[0]; else x -= mincost, u = e[u].ch[1]; &#125;&#125; 建树setroot()操作用于在外部定义根节点。 build()操作类似于线段树，直接建树比写insert()操作插入节点要快。 123456789101112131415void setroot(int x) &#123; root = x;&#125;void build(int l, int r, int f) &#123; if (l &gt; r) return; int m = (l + r) &gt;&gt; 1; e[m].val = m, e[m].father = f; e[m].cnt = e[m].sum = 1; e[m].ch[0] = e[m].ch[1] = 0; if (m &lt; f) e[f].ch[0] = m; else e[f].ch[1] = m; build(l, m - 1, m); build(m + 1, r, m); update(m);&#125; 翻转参照之前的图。需要注意的是这样的写法需要下文初始化的配合 123456void reverse(int l, int r) &#123; int x = find(l - 1), y = find(r + 1); splay(x, root); splay(y, e[x].ch[1]); e[e[y].ch[0]].tag ^= 1;&#125; 初始化我们先使用build()操作建树。其中2 ~ n + 1节点表示数列的第1 ~ n个。 插入1和n + 2节点是为了保证被查找的树必定在区间内简化代码量。 12s.setroot((n + 3) &gt;&gt; 1);s.build(1, n + 2, 0); 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114// ==============================// author: memset0// website: https://memset0.cn// ==============================#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;int read() &#123; int x = 0; bool m = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; c != '-') c = getchar(); if (c == '-') m = 1, c = getchar(); while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); if (m) return -x; else return x;&#125;const int maxn = 100010;int n, m, l, r;struct Splay &#123; #define root (e[0].ch[1]) struct node &#123; int val, sum, cnt, tag; int father, ch[2]; &#125; e[maxn]; void setroot(int x) &#123; root = x; &#125; void update(int x) &#123; e[x].sum = e[e[x].ch[0]].sum + e[e[x].ch[1]].sum + e[x].cnt; &#125; int identify(int x) &#123; return e[e[x].father].ch[1] == x; &#125; void connect(int u, int f, int son) &#123; e[u].father = f; e[f].ch[son] = u; &#125; void pushdown(int x) &#123; if (e[x].tag) &#123; swap(e[x].ch[0], e[x].ch[1]); e[e[x].ch[0]].tag ^= 1; e[e[x].ch[1]].tag ^= 1; e[x].tag = 0; &#125; &#125; void rotate(int x) &#123; int f = e[x].father, ff = e[f].father; pushdown(f), pushdown(x); int fson = identify(x), ffson = identify(f); int y = e[x].ch[fson ^ 1]; connect(y, f, fson); connect(f, x, fson ^ 1); connect(x, ff, ffson); update(f); update(x); &#125; void splay(int at, int to) &#123; to = e[to].father; while (e[at].father != to) &#123; int up = e[at].father; pushdown(up), pushdown(at); if (e[up].father == to) rotate(at); else if (identify(at) == identify(up)) rotate(up), rotate(at); else rotate(at), rotate(at); &#125; &#125; int find(int x) &#123; int u = root; while (u) &#123; pushdown(u); int mincost = e[e[u].ch[0]].sum + e[u].cnt; if (e[e[u].ch[0]].sum &lt; x &amp;&amp; x &lt;= mincost) return u; if (x &lt; mincost) u = e[u].ch[0]; else x -= mincost, u = e[u].ch[1]; &#125; &#125; void build(int l, int r, int f) &#123; if (l &gt; r) return; int m = (l + r) &gt;&gt; 1; e[m].val = m, e[m].father = f; e[m].cnt = e[m].sum = 1; e[m].ch[0] = e[m].ch[1] = 0; if (m &lt; f) e[f].ch[0] = m; else e[f].ch[1] = m; if (l == r) return; build(l, m - 1, m); build(m + 1, r, m); update(m); &#125; void reverse(int l, int r) &#123; int x = find(l - 1), y = find(r + 1); splay(x, root); splay(y, e[x].ch[1]); e[e[y].ch[0]].tag ^= 1; &#125; #undef root&#125; s;int main() &#123; n = read(), m = read(); s.setroot((n + 3) &gt;&gt; 1); s.build(1, n + 2, 0); while (m--) &#123; l = read(), r = read(); s.reverse(l + 1, r + 1); &#125; for (int i = 1; i &lt;= n; i++) printf(\"%d \", s.find(i + 1) - 1); putchar('\\n'); return 0;&#125; 备注 &amp; 参考资料参考资料： 题解 P3391 【模板】文艺平衡树（Splay） - zcysky 题解 P3391 【模板】文艺平衡树（Splay） - yybyyb Splay处理区间操作——翻转操作(Reverse) - _pks ‘w 代码提交： 洛谷 3391 【模板】文艺平衡树（Splay） LOJ #105. 文艺平衡树","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://memset0.cn/categories/Algorithm/"}],"tags":[{"name":"平衡树","slug":"平衡树","permalink":"https://memset0.cn/tags/平衡树/"}]},{"title":"Splay Q&A","slug":"algorithm/splay-q-and-a","date":"2018-08-08T14:51:00.000Z","updated":"2018-10-10T12:14:53.313Z","comments":true,"path":"algorithm/splay-q-and-a/","link":"","permalink":"https://memset0.cn/algorithm/splay-q-and-a/","excerpt":"最近正在学习 Splay 平衡树，其中也遇到了不少问题，正是分享的时候。 代码来自于我的另外两篇博文中的 Splay 板子。 求前驱后继时为什么要取等号？123456789int lower(int val) &#123; int u = root, result = -inf, cho = 0; while (u) &#123; if (e[u].val &lt; val &amp;&amp; e[u].val &gt; result) result = e[u].val, cho = u; u = e[u].ch[val &lt;= e[u].val ? 0 : 1]; &#125; splay(cho, root); return result;&#125; Q: 以Splay::lower()的代码为例，在u更新时，我们使用的是e[u].val &lt;= e[u].val ? 0 : 1而非val &lt; e[u].val ? 0 : 1，为什么？ A: 根据平衡树的性质，小于当前节点的数在左边，而e[u].val的前驱显然不能是e[u].val本身，而是在其左子树中，所以要写等于号。","text":"最近正在学习 Splay 平衡树，其中也遇到了不少问题，正是分享的时候。 代码来自于我的另外两篇博文中的 Splay 板子。 求前驱后继时为什么要取等号？123456789int lower(int val) &#123; int u = root, result = -inf, cho = 0; while (u) &#123; if (e[u].val &lt; val &amp;&amp; e[u].val &gt; result) result = e[u].val, cho = u; u = e[u].ch[val &lt;= e[u].val ? 0 : 1]; &#125; splay(cho, root); return result;&#125; Q: 以Splay::lower()的代码为例，在u更新时，我们使用的是e[u].val &lt;= e[u].val ? 0 : 1而非val &lt; e[u].val ? 0 : 1，为什么？ A: 根据平衡树的性质，小于当前节点的数在左边，而e[u].val的前驱显然不能是e[u].val本身，而是在其左子树中，所以要写等于号。 为什么你除了 find() 以外的操作也要 splay 到根？123456789101112int rank(int val) &#123; int u = root, ans = 0; while (u) &#123; if (val == e[u].val) &#123; ans += e[e[u].ch[0]].sum + 1; splay(u, root); return ans; &#125; if (val &lt; e[u].val) u = e[u].ch[0]; else ans += e[e[u].ch[0]].sum + e[u].cnt, u = e[u].ch[1]; &#125;&#125; Q: 我看的洛谷题解就不是这样的！你这样不会拖慢常数吗？ A: 你让题解过一下洛谷第12个点？ A: 这样子做能使经常被访问的点提高到根，尽量避免 Splay 被卡，然而还是可能会被良心出题人针对。。。 为什么要先 update(f) 再 update(x)12345678910void rotate(int x) &#123; int f = e[x].father, fson = identify(x); int ff = e[f].father, ffson = identify(f); int y = e[x].ch[fson ^ 1]; connect(y, f, fson); connect(f, x, fson ^ 1); connect(x, ff, ffson); update(f); update(x);&#125; Q: 而不是相反？ A: 因为经过我们的旋转，f已经是x的子节点了，所以要自下到上更新。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://memset0.cn/categories/Algorithm/"}],"tags":[{"name":"平衡树","slug":"平衡树","permalink":"https://memset0.cn/tags/平衡树/"}]},{"title":"Dev C++ 更改主题","slug":"geek/devc更改主题","date":"2018-08-08T09:27:53.000Z","updated":"2018-12-09T02:04:17.945Z","comments":true,"path":"geek/devc更改主题/","link":"","permalink":"https://memset0.cn/geek/devc更改主题/","excerpt":"Dev C++ 是目前OIer使用最多的IDE，然而原始界面却丑的一逼。所以让我们来美化它233。 Before usingDev C++ 的主题默认存储在C:/Users/&lt;your name&gt;/AppData/Roaming/Dev-Cpp目录下，在该目录新建&lt;文件名&gt;.syntax添加配色。 在 Dev C++ 的菜单栏中选择工具[T]&gt;编辑器属性&gt;语法&gt;预设应用配色（可在选项中找到你之前新建的配色）；同时也可直接在 Dev C++ 中方便的调色（点击右侧自动跳转到对应内容）并保存（如果文件名与已存在的相同则默认替换）。 修改完后，务必在工具[T]&gt;编辑器属性&gt;基本中更改高亮显示当前行的颜色，以符合背景。 另外，推荐在使用暗色主题时关闭 Dev C++ 自带的各种工具栏！","text":"Dev C++ 是目前OIer使用最多的IDE，然而原始界面却丑的一逼。所以让我们来美化它233。 Before usingDev C++ 的主题默认存储在C:/Users/&lt;your name&gt;/AppData/Roaming/Dev-Cpp目录下，在该目录新建&lt;文件名&gt;.syntax添加配色。 在 Dev C++ 的菜单栏中选择工具[T]&gt;编辑器属性&gt;语法&gt;预设应用配色（可在选项中找到你之前新建的配色）；同时也可直接在 Dev C++ 中方便的调色（点击右侧自动跳转到对应内容）并保存（如果文件名与已存在的相同则默认替换）。 修改完后，务必在工具[T]&gt;编辑器属性&gt;基本中更改高亮显示当前行的颜色，以符合背景。 另外，推荐在使用暗色主题时关闭 Dev C++ 自带的各种工具栏！ 下面推荐两款暗色主题 qwq： Monokai.syntax经典的暗色配色，来自 Github 1234567891011121314151617181920[Editor.Custom]Assembler=$0099FFFF, clNone, 0, 0, 0Character=$0099FFFF, clNone, 0, 0, 0Comment=$00787878, clNone, 0, 1, 0Float=$0099FFFF, clNone, 0, 0, 0Hexadecimal=$0099FFFF, clNone, 0, 0, 0Identifier=clWhite, clNone, 0, 0, 0Illegal Char=clAqua, clNone, 0, 0, 0Number=$00FF55AA, clNone, 0, 0, 0Octal=$0099FFFF, clNone, 0, 0, 0Preprocessor=$007F2AFF, clNone, 0, 0, 0Reserved Word=$00FFD455, clNone, 0, 0, 0Space=clWindowText, $001E1E1E, 0, 0, 0String=$0099FFFF, clNone, 0, 0, 0Symbol=$007F2AFF, clNone, 0, 0, 0Selected text=16777215, 5921370Gutter=7895160, 1973790Break points=16777215, 13209Error Line=1973790, 10092543Active Breakpoints=16777215, 10040115 memset0.syntax（20180916更新）我个人修改出来的配色，高亮显示当前行颜色：Red: 46; Green: 52; Blue: 54; 123456789101112131415161718192021[Editor.Custom]Assembler=clPurple, $0036342E, 0, 0, 0Character=$00A062FF, $001D1D1D, 0, 0, 0Comment=$00C8C8C8, $001D1D1D, 0, 1, 0Float=$00A062FF, $001D1D1D, 0, 0, 0Hexadecimal=$0099FFFF, clNone, 0, 0, 0Identifier=$00FAFAFA, $001D1D1D, 0, 0, 0Illegal Char=clGray, $001D1D1D, 0, 0, 0Number=$00A062FF, $001D1D1D, 0, 0, 0Octal=$0099FFFF, clNone, 0, 0, 0Preprocessor=$003CF03C, $001D1D1D, 0, 0, 0Reserved Word=$00FF8F06, $001D1D1D, 0, 0, 0Space=clWindowText, $001D1D1D, 0, 0, 0String=$00FF99FF, $001D1D1D, 0, 0, 0Symbol=$0000DDDD, $001D1D1D, 0, 0, 0Selected text=1907997, 14604246Gutter=16777215, 1907997Breakpoints=16777215, 219Error line=1973790, 124158Active breakpoints=16777215, 11877436Folding lines=536870911, 536870911","categories":[{"name":"Geek","slug":"Geek","permalink":"https://memset0.cn/categories/Geek/"}],"tags":[{"name":"美化","slug":"美化","permalink":"https://memset0.cn/tags/美化/"}]},{"title":"十行求解 $O(n \\log n)$ 求最长上升子序列","slug":"algorithm/最长上升子序列","date":"2018-07-18T04:06:00.000Z","updated":"2018-10-10T12:14:53.313Z","comments":true,"path":"algorithm/最长上升子序列/","link":"","permalink":"https://memset0.cn/algorithm/最长上升子序列/","excerpt":"","text":"12345678910#include &lt;bits/stdc++.h&gt;int n, x, f[100001];int main() &#123; std::memset(f, 63, sizeof(f)); std::scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) std::scanf(\"%d\", &amp;x), *std::lower_bound(f + 1, f + n + 1, x) = x; std::printf(\"%d\\n\", std::lower_bound(f + 1, f + n + 1, f[0]) - f - 1); return 0;&#125; 个人认为在保障可读性的情况下的最佳优化 主要优化有： 包bits库，省两行 不用using namespace std，省一行 输入和修改压到一行，省两行 用STL，省很多行 你还可以接着压行： 把第四行和第五行用逗号连在一起 把变量定义转移到for循环或main函数定义里 把所有语句压倒一行去","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://memset0.cn/categories/Algorithm/"}],"tags":[{"name":"最长上升子序列","slug":"最长上升子序列","permalink":"https://memset0.cn/tags/最长上升子序列/"}]},{"title":"洛谷2962 - 灯","slug":"solution/luogu/2962","date":"2018-07-16T08:20:00.000Z","updated":"2018-10-10T12:14:53.320Z","comments":true,"path":"solution/luogu/2962/","link":"","permalink":"https://memset0.cn/solution/luogu/2962/","excerpt":"一道非常神奇的题目。 尽管洛谷题解给的都是高斯消元，但实际上这题“普通”的DFS就可以AC。 因为直接DFS一遍的复杂度高达 $O(2 ^ n)$ ，所以我们从两边开始搜索，并把状态存在map里，复杂度降低为 $O(n \\times 2 ^ {\\frac{n}{2}})$ ，可以水过此题。","text":"一道非常神奇的题目。 尽管洛谷题解给的都是高斯消元，但实际上这题“普通”的DFS就可以AC。 因为直接DFS一遍的复杂度高达 $O(2 ^ n)$ ，所以我们从两边开始搜索，并把状态存在map里，复杂度降低为 $O(n \\times 2 ^ {\\frac{n}{2}})$ ，可以水过此题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;#define isnum(c) ('0' &lt;= c &amp;&amp; c &lt;= '9')#define read(x) do &#123;\\ R::c = getchar(); R::m = 0; x = 0;\\ while (!isnum(R::c) &amp;&amp; R::c != '-') R::c = getchar();\\ if (R::c == '-') R::c = getchar(), R::m = 1;\\ while (isnum(R::c)) x = x * 10 + R::c - '0', R::c = getchar();\\ if (R::m) x = -x;\\&#125; while(false)namespace R &#123; char c; bool m; &#125;using namespace std;const int maxn = 40;int n, m, lim, ans, l, r, tx, ty;long long a[maxn], check[maxn], FULL_STACK;bool found, vis[maxn], G[maxn][maxn];map &lt; long long, int &gt; Map;void reader() &#123; read(n); read(m); for (int i = 1; i &lt;= n; i++) G[i][i] = 1; for (int i = 1; i &lt;= m; i++) &#123; read(tx); read(ty); G[tx][ty] = 1; G[ty][tx] = 1; &#125; &#125;void printer(long long x) &#123; for (int i = 1; i &lt;= n; i++) if (check[i] &amp; x) putchar('1'); else putchar('0'); printf(\"(%lld)\", x); putchar('\\n'); &#125;void DFS1(int u, long long pin, int step) &#123; if (u &gt; lim) return ; if (Map.find(pin) != Map.end()) Map[pin] = min(Map[pin], step); else Map[pin] = step; DFS1(u + 1, pin, step); DFS1(u + 1, pin ^ a[u + 1], step + 1);&#125;void DFS2(int u, long long pin, int step) &#123; if (u &gt; n) return ; if (Map.find(FULL_STACK ^ pin) != Map.end()) ans = min(ans, step + Map[FULL_STACK ^ pin]); DFS2(u + 1, pin, step); DFS2(u + 1, pin ^ a[u + 1], step + 1);&#125;int main() &#123; reader(); ans = n; for (int i = 1; i &lt;= n; i++) &#123; for (int j = n; j &gt; 0; j--) if (G[i][j]) a[i] = a[i] &lt;&lt; 1 | 1; else a[i] = a[i] &lt;&lt; 1; &#125; FULL_STACK = check[1] = 1; for (int i = 2; i &lt;= n; i++) &#123; FULL_STACK = FULL_STACK &lt;&lt; 1 | 1; check[i] = (check[i - 1] &lt;&lt; 1); &#125; lim = (n + 1) &gt;&gt; 1; DFS1(0, 0, 0); DFS2(lim, 0, 0); printf(\"%d\\n\", ans); return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"https://memset0.cn/categories/Solution/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://memset0.cn/tags/DFS/"}]},{"title":"洛谷2921 - 在农场万圣节","slug":"solution/luogu/2921","date":"2018-06-29T08:35:00.000Z","updated":"2018-10-10T12:14:53.320Z","comments":true,"path":"solution/luogu/2921/","link":"","permalink":"https://memset0.cn/solution/luogu/2921/","excerpt":"解法可以看做一张有n个节点的图，每个节点有且仅有一条向外连接的边（可以连自己）。那么图中只可能是环与链的组合。而且链的终点是环，进入环后就不会从环中出去，故一个链只可能接一个环，一个环只可能被一或多的链接。 故我们可以把整个分隔为一个个的环，并把接到他们的链找出来。 环内节点的答案 = 环的长度； 环外节点的答案 = 环的长度 + 当前节点到环的距离。 几趟 $O(n)$ 的搜索就可以搞定问题！","text":"解法可以看做一张有n个节点的图，每个节点有且仅有一条向外连接的边（可以连自己）。那么图中只可能是环与链的组合。而且链的终点是环，进入环后就不会从环中出去，故一个链只可能接一个环，一个环只可能被一或多的链接。 故我们可以把整个分隔为一个个的环，并把接到他们的链找出来。 环内节点的答案 = 环的长度； 环外节点的答案 = 环的长度 + 当前节点到环的距离。 几趟 $O(n)$ 的搜索就可以搞定问题！ 代码R7868116 评测详情 - 洛谷12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;#define isnum(c) ('0' &lt;= c &amp;&amp; c &lt;= '9')#define read(x) &#123; \\ x = 0, rd::c = getchar(), rd::m = 0; \\ while (!isnum(rd::c) &amp;&amp; rd::c != '-') rd::c = getchar(); \\ if (rd::c == '-') rd::m = 1, rd::c = getchar(); \\ while (isnum(rd::c)) x = x * 10 + rd::c - '0', rd::c = getchar(); \\ if (rd::m) x *= -1; \\ &#125;namespace rd &#123; char c; bool m;&#125;using namespace std;const int maxn = 100010;int n, u, v, l, r, q[maxn];struct Node &#123; int e, cnt, val; bool nod, cld; vector &lt; int &gt; linkin;&#125; a[maxn];int main() &#123; read(n); for (int i = 1; i &lt;= n; i++) &#123; read(a[i].e); a[a[i].e].cnt += 1; a[a[i].e].linkin.push_back(i); &#125; for (int i = 1; i &lt;= n; i++) if (!a[i].cnt) &#123; a[i].nod = 1; q[++r] = i; &#125; l = 1; while (l &lt;= r) &#123; u = q[l++]; a[a[u].e].cnt--; if (!a[a[u].e].cnt) &#123; a[a[u].e].nod = 1; q[++r] = a[u].e; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (!a[i].nod) &#123; q[1] = i, r = 1; while (1) &#123; a[q[r]].nod = 1; q[r + 1] = a[q[r]].e; r++; if (a[q[r]].nod) &#123; r--; break; &#125; &#125; for (int i = 1; i &lt;= r; i++) &#123; a[q[i]].val = r; a[q[i]].cld = 1; &#125; &#125; &#125; l = 1, r = 0; for (int i = 1; i &lt;= n; i++) if (a[i].cld) q[++r] = i; while (l &lt;= r) &#123; u = q[l++]; for (int i = 0; i &lt; a[u].linkin.size(); i++) &#123; v = a[u].linkin[i]; if (!a[v].cld) &#123; a[v].cld = 1; a[v].val = a[u].val + 1; q[++r] = v; &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) printf(\"%d\\n\", a[i].val); return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"https://memset0.cn/categories/Solution/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://memset0.cn/tags/图论/"}]},{"title":"C++ 中的 __gcd() 函数探源","slug":"algorithm/gcd-from","date":"2018-05-25T14:21:00.000Z","updated":"2018-10-10T12:14:53.312Z","comments":true,"path":"algorithm/gcd-from/","link":"","permalink":"https://memset0.cn/algorithm/gcd-from/","excerpt":"","text":"最近在做一道需要用到 gcd 的题，正当我急于回忆 gcd 怎么写时，忽然听说有个叫__gcd()的内置函数。 知乎 上说这是个built-in函数（也许可以简单地理解为内置函数）。 但我对它的时间复杂度一直很担忧，想看看它到底是怎么实现的，便在C++内置库bits/stl_algo.h的 1512 - 1527 行找到可能的实现： 12345678910111213141516 /** * This is a helper function for the rotate algorithm specialized on RAIs. * It returns the greatest common divisor of two integer values. */ template&lt;typename _EuclideanRingElement&gt; _EuclideanRingElement __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n) &#123; while (__n != 0)&#123; _EuclideanRingElement __t = __m % __n; __m = __n; __n = __t;&#125; return __m; &#125; bits/stl_algo.h是C++的一个内置库，你引用algorithm库时就会引入这个库","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://memset0.cn/categories/Algorithm/"}],"tags":[{"name":"GCD","slug":"GCD","permalink":"https://memset0.cn/tags/GCD/"}]},{"title":"Python 模拟登陆 hustoj","slug":"geek/python-login-hostoj","date":"2018-05-25T14:14:00.000Z","updated":"2018-10-10T12:14:53.315Z","comments":true,"path":"geek/python-login-hostoj/","link":"","permalink":"https://memset0.cn/geek/python-login-hostoj/","excerpt":"前言最近闲着无聊准备写写Python爬虫，爬一下我们学校的oj用来横向比对做题量。但由于我校OJ对没有登录的账号有浏览限制，因此想要获取数据，就必须要登录账号。以前我一直手动生成Cookie，然后到浏览器里用该Cookie登录，这样的话没过一会儿又要重来比较麻烦。于是我就学习了一下用Python来POST数据的方式实现登录功能。 说明 感谢hiuseues大佬对我的指导！ 此处以我校OJ为例 请不要使用此测试账号（账号来自某外校团队）来浏览我校题目或交题，否则我将把密码改掉 我习惯于使用Python2写爬虫，主要因为我校电脑和我的VPS预装的都是这个版本。可能会和hiuseues大佬产生代沟，不要在意。当然，这个脚本的核心部分在Python3中完全可以运行，希望这样的话代沟可以小一点。","text":"前言最近闲着无聊准备写写Python爬虫，爬一下我们学校的oj用来横向比对做题量。但由于我校OJ对没有登录的账号有浏览限制，因此想要获取数据，就必须要登录账号。以前我一直手动生成Cookie，然后到浏览器里用该Cookie登录，这样的话没过一会儿又要重来比较麻烦。于是我就学习了一下用Python来POST数据的方式实现登录功能。 说明 感谢hiuseues大佬对我的指导！ 此处以我校OJ为例 请不要使用此测试账号（账号来自某外校团队）来浏览我校题目或交题，否则我将把密码改掉 我习惯于使用Python2写爬虫，主要因为我校电脑和我的VPS预装的都是这个版本。可能会和hiuseues大佬产生代沟，不要在意。当然，这个脚本的核心部分在Python3中完全可以运行，希望这样的话代沟可以小一点。 分析登录页面我们进入loginpage.php，可以看到一个登陆的界面。 使用“审查元素”功能查看一下这个登录框的源代码。 其中的核心代码如下（其他内容并没有什么卵用）： 12345&lt;form action=\"login.php\" method=\"post\" role=\"form\"&gt; &lt;input name=\"user_id\"&gt; &lt;input name=\"password\"&gt; &lt;button&gt;登录&lt;/button&gt;&lt;/form&gt; 即使你把代码删到只剩这么点，你照样可以登录：只不过界面难看点罢了。 分析数据那么我们来讲讲这段“最简代码”讲了什么： 最外层的form中定义了需要post到的页面 &lt;=&gt; action=&quot;login.php&quot; 同时也定义了数据的传输方式 &lt;=&gt; method=&quot;post&quot; 两个input提供了两个输入框，也是需要post到对应页面的数据 &lt;=&gt; &lt;input name=&quot;user_id&quot;&gt;、&lt;input name=&quot;password&quot;&gt; 最后你会发现还有一个button，你点一下数据就会被发送过去啦！ 该系统使用了明文密码传输的方式，因此比较容易分析。现在为了安全，越来越多的网站都在避免明文密码传输，但原理基本都是有互通之处的。不过在中国这个网络大环境下，完全有可能上级一个领导电话过来向你要xxx用户的密码，你程序员要是不存明文密码那行啊（ε=(´ο｀*)))唉） 那么你需要做的，就是给”/login.php”这个页面发送两个分别叫user_id和password的数据即可！ 如何post数据此处我们使用urllib和urllib2来操作，前者用于编码post的数据，后者用于发送请求。这两个库的名称和用法在python3略有改变，请参照下面的代码（下面的代码采用try的方式确保了在py2和py3中的兼容性，我以后的代码可能只会在py2中生效，但是你完全可以用同样的修改方式让它在py3中运行）。当然，你也可以使用requests等第三方库。值得一提的是，requests库在处理post文件的操作时非常方便。 我们用urllib库中的urlencode()方法来编码我们需要post的数据，在py2中的代码如下 1data = urllib.urlencode(&#123;\"user_id\": username, \"password\": password&#125;) 接着你需要使用urllib2库中的urlopen()方法来打开网页，同时post数据（data） 1urllib2.urlopen(\"http://www.h2zbmh.com:8080/html/JudgeOnline/index.php\", data) 构建opener也许你在想，这就没了？结果你在尝试打开下一个页面时会发现，我还是没法获取那些需要登陆的页面啊！ 那么你可能需要一个opener来维持你打开页面的状态。接着使用opener.open(url)来代替urllib2.urlopen(url)并保留登陆状态。 在构建opener的同时，我们也会把当前自身的cookie保存到文件中，方便进一步的调试。 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445# encoding=utf8try: # python2的引入 import urllib import urllib2 import cookielibexcept ImportError: # python3的引入 import urllib.parse as urllib import urllib.request as urllib2 import http.cookiejar as cookielib # 利用try实现同时兼容py2和py3的效果username = 'LJB001590'password = '123' # 测试账号，账号密码来自某团队rooturl = 'http://www.h2zbmh.com:8080/html/JudgeOnline/'def geturl(url): return rooturl + url;def Build(): global opener # 引入全局变量 filename = 'cookie.txt' # 保存cookie的文件 cookie = cookielib.MozillaCookieJar(filename) # 创建一个实例 handler = urllib2.HTTPCookieProcessor(cookie) # 创建urllib2的cookie处理器 opener = urllib2.build_opener(handler) # 通过之前的cookie处理器构造opener opener.open(geturl('index.php')) # “随机”打开一个页面来获得cookie cookie.save(ignore_discard=True, ignore_expires=True) # 保存cookie到文件def Login(): global username, password, rooturl, opener # 引入全局变量 url = geturl('login.php') # 对应的网址 data = urllib.urlencode(&#123;\"user_id\": username, \"password\": password, &#125;) # 需要post的数据 try: response = opener.open(url, data=data) # post数据 即 发送登录请求 except TypeError: response = opener.open(url, data=data.encode('utf-8')) # python3中的解决方式Build()Login()open(\"ans.html\", \"wb+\").write(opener.open(geturl('problemset.php')).read()) # 利用构建好的opener打开网页并输出到ans.html文件中（如果不显示“请登陆后继续操作！”说明成功）# 再次感谢hiuseues大佬","categories":[{"name":"Geek","slug":"Geek","permalink":"https://memset0.cn/categories/Geek/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://memset0.cn/tags/Python/"}]},{"title":"2018浙大校赛&图森未来杯(4.7) 游记","slug":"diary/2018浙大校赛游记","date":"2018-04-30T08:04:00.000Z","updated":"2018-10-10T12:14:53.314Z","comments":true,"path":"diary/2018浙大校赛游记/","link":"","permalink":"https://memset0.cn/diary/2018浙大校赛游记/","excerpt":"这其实是一个比赛啊啊啊啊啊！ 反正考得超级辣鸡的！ 这是我第一次参加ACM类的比赛，估计也是我的第一次写游记吧。这次参加浙大校赛的，不光有他们大学生，还有各路中学生；同时，我也在队伍里面发现了小学生的踪影（就差幼儿园的了）。整体的氛围还是比较愉快的，可能是因为三个人一起做题的关系吧，没有OI那么压抑。 这次比赛给了我们一点经验，也让我们看到了很多不足的地方（同时我现场领悟了如何数组模拟链表，thanks to fjk）","text":"这其实是一个比赛啊啊啊啊啊！ 反正考得超级辣鸡的！ 这是我第一次参加ACM类的比赛，估计也是我的第一次写游记吧。这次参加浙大校赛的，不光有他们大学生，还有各路中学生；同时，我也在队伍里面发现了小学生的踪影（就差幼儿园的了）。整体的氛围还是比较愉快的，可能是因为三个人一起做题的关系吧，没有OI那么压抑。 这次比赛给了我们一点经验，也让我们看到了很多不足的地方（同时我现场领悟了如何数组模拟链表，thanks to fjk） update 2018.4.10 然后当时我们F题一直没有打出来，直到今天我才发现这不就是一道简单的DP+贪心吗。 那么我们开始吧 上午等待我们到的很早，当时门口几乎没有什么人。还好，我及时地找到了我的队友并一起坐在fjk的车里打pvz2.话说外面还真冷啊！ 开幕式开幕式就是领导讲话+吹牛逼，有些同学在玩游戏，但是我还是认真听的。据称每一年的校赛都有个传统——开幕式时会给一点提示。这次老师告诉我们说： 这次换了个新人出题，新手上路嘛，难度可能掌握的不太好。于是呢我就让他给我看了一下：题目不难，但是也没有很简单的题。最好的方法是一个人从头往后看，一个人从后往前看，还有一个人从中间看。 事实证明这话非常有用，嗯对，你马上就知道了。。。 上机练习只听到广播里一直响着不要碰电脑，于是我们就半个多小时没有碰电脑——直到看到绝大部分人都开始打上午的这套练习题为止。A题C题好水啊，B题貌似就是一个有两个条件的SPFA（雾）？D题是什么鬼，来考高中数理化啊。貌似因为早上的只是试机，好多人都提前走了，也没看到有人去做B题。话说找提交代码的地方用了十多分钟，不过还好上午就发现了。 中午吃中饭浙大的校园就是大，食堂也大，比我们学校的食堂不知道高端到哪里去。 买文具吃完中饭我们去旁边的超市逛逛。 其实本来只是fjk和yyf想买瓶水的，结果我带头买了一堆印着浙大校徽的笔记本（坑钱）我还买了两只笔。。。 下午终于要开始比赛了233 开考前我们提早一刻钟到了，试卷摆在桌子上，然后我问监考老师：我：试卷可以看吗监考老师：我也不知道诶，我帮你去问一下……监考老师：他们说不可以的，现在不可以拆试卷我：可是这信封本来就是打开的监考老师：那是他们包装的不专业（一脸无奈） 开考貌似提前了三分钟？后来才知道是钟不准 做题 瞎搞J - PPAP我们按照早上说的那样，分开来看题。很开，fjk就发现最后一题很简单。然后我们就把他切了。 A - Pretty Matrix接着我们看别的题目去了，当时不知道是谁说了一声第一题好难啊，然后我们就都没有去看第一题。直到…我们把每道题都看完了以后刷新下rank榜才发现第一题那么水。 于是认真地看了看，A掉了 G - Traffic Light当时fjk想出了这道题的这道题的优化方法：某些点一定是走奇数才能到的，某些点一定是走偶数步才能到的。于是我们就可以把原来动态的图变成静态的，我们也决定先打这一题。 然而，明明想到正解的我们却去打了个DFS打DFS也就算了，还是个WA的DFS。后来好不容易对拍出来又是TLE，然后写了个记忆化的DFS还是TLE。最后fjk一发BFS就A了。 考后，他们说不用那样优化也能A。心里那叫一个凄凉。 C - Mergeable Stack在G题不断WA/TLE的同时，我们也开始做C题。 我第一眼以为是数据结构题，觉着以我们这种垃圾的水平应该是做不出来的于是很快就放弃了。后来fjk一看说这不就是道模拟题吗，数组模拟链表就好了。我一看，还真是，于是就愉快地打了个代码，WA了。 后来才发现，有那么个很小的情况转移时没有将被移走的栈删除，然后就呵呵了。其实也没有那么难。 F - Schrödinger’s Knapsack一道神奇的背包题，我们最后一个小时都押宝在这道题上了。一开始我们想了个贪心，O(n log n)的，总是WA。 后来想了想这题数据给的很明显就是让我们用O(n ^ 2)啊，然而我却以为是n方的贪心。 最后一刻钟yyf才想出来DP，十分钟敲完却样例都过不去。于是只能遗憾收场。 事后证明因为当时考虑不周全没仔细看题，当时多写了个- 1。回来一测，去掉就A了。而且跑的还贼快，要知道我们隔壁队都是卡时限才过了的。 总结这次的成绩不怎么理想，至少F题本来应该打出来，其他题不应该错那么多次。不然排名进前30应该是没有问题的。主要还是我的原因吧，全场脑子比较混乱，根本没有能力把我们队管理好，然而还是逞强想去当队长。 英文题面也导致我们对题目难度的评估失误：他们认为很简单思考了很久的B题和E题结果是最难的两个题（浪费了他们两个近两个小时的时间吧） 也只能说：下次加油吧","categories":[{"name":"Diary","slug":"Diary","permalink":"https://memset0.cn/categories/Diary/"}],"tags":[{"name":"游记","slug":"游记","permalink":"https://memset0.cn/tags/游记/"}]},{"title":"欧拉筛求质数","slug":"algorithm/欧拉筛","date":"2018-02-03T14:51:00.000Z","updated":"2018-10-10T12:14:53.314Z","comments":true,"path":"algorithm/欧拉筛/","link":"","permalink":"https://memset0.cn/algorithm/欧拉筛/","excerpt":"欧拉筛是一种优秀的筛质数方法。","text":"欧拉筛是一种优秀的筛质数方法。 埃氏筛一般的筛法，时间复杂度 $O(n \\times log_2 n \\times log_2 n)$ 。 12345678910111213void sieve(int n)&#123; cnt = 0; memset(flag, 0, sizeof(flag)); for (int i = 2; i &lt;= sqrt(n); i++) &#123; if (!flag[i]) &#123; prime[cnt++] = i; for (int j = i * i; j &lt;= n; j += i) &#123; flag[j] = true; &#125; &#125; &#125;&#125; 欧拉筛欧拉筛可以保证每个数只会被筛到一次，故时间复杂度为 $O(n)$ 。1234567891011121314void sieve(int n)&#123; cnt = 0; memset(flag, 0, sizeof(flag)); for (int i = 2; i &lt;= n; i++) &#123; if (!flag[i]) prime[cnt++] = i; for (int j = 0; i * prime[j] &lt;= n; j++) &#123; flag[i * prime[j]] = true; if (i % prime[j] == 0) break; &#125; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://memset0.cn/categories/Algorithm/"}],"tags":[{"name":"数学，数论","slug":"数学，数论","permalink":"https://memset0.cn/tags/数学，数论/"}]}]}